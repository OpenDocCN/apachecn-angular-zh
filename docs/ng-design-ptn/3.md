# 三、经典模式

TypeScript 是一种面向对象的编程语言，因此，我们可以利用数十年来关于面向对象体系结构的知识。在本章中，我们将探讨一些最有用的面向对象设计模式，并学习如何从角度应用它们。

Angular 本身就是一个面向对象的框架，它迫使您以某种方式进行大部分开发。例如，您需要具有组件、服务、管道等。强制使用这些构建块有助于构建一个好的体系结构，非常类似于 Zend 框架对 PHP 的作用，或者 Ruby on Rails 对 Ruby 的作用。当然，框架的存在是为了让您的生活更轻松，加快开发时间。

虽然设计事物的角度远高于平均水平，但我们总能做得更好。我并不是说我在本章中介绍的是最终设计，也不是说你可以用它来解决任何问题，从面包房一号寻呼机到火星一号任务的仪表盘。不幸的是，这样的设计并不存在，但它将最终改善你的工具带。

在本章中，我们将看到以下经典模式：

*   组件
*   单身汉
*   观察员

# 组件

在本书的前三章中，我们看到了大量的角度分量。角度`Component`是角度应用程序的主要构建块之一，例如，`services`、`pipes`等。作为提醒，TypeScript 类使用以下注释成为角度组件：

```ts
import { Component } from '@angular/core'; 

@Component({ 
  selector: 'app-root', 
  templateUrl: './app.component.html', 
  styleUrls: ['./app.component.css'] 
}) 
export class AppComponent { 
  title = 'app'; 
} 
```

这里，`AppComponent`类通过`selector`、`templateUrl`和`styleUrls`角组件的行为进行增压。

# 独生子女

用于前端应用程序的另一个方便模式是 singleton。singleton 确保程序中只存在给定对象的一个实例。此外，它还提供了对象的全局访问点。

以下是它在实践中的表现：

```ts
export class MySingleton{ 

    //The constructor is private so we  
    //can't do `let singleton:MySingleton = new MySingleton();` 
    private static instance:MySingleton = null; 

    private constructor(){ 

    } 

    public static getInstance():MySingleton{ 
        if(MySingleton.instance == null){ 
            MySingleton.instance = new MySingleton(); 
        }
```

```ts
        return MySingleton.instance; 
    } 
} 
 let singleton:MySingleton = MySingleton.getInstance();
```

我们有一个具有`private static instance:MySingleton`属性的类。然后，我们有一个私有构造函数，它会导致以下失败：

```ts
let singleton:MySingleton = new MySingleton(); 
```

请注意，它失败是因为您的 TypeScript transpiler 抱怨可见性问题。但是，如果将`MySingleton`类转换为 JavaScript 并将其导入到另一个 TypeScript 项目中，则可以使用*新的*运算符，因为转换后的 TypeScript 没有任何可见性。

这种相当简单的单例模式实现的问题是并发性。事实上，如果两个进程同时命中`getInstance():MySingleton`，那么程序中将有两个`MySingleton`实例。为了确保不会发生这种情况，我们可以使用一种称为早期实例化的技术：

```ts
export

 class MySingleton
 {
   private static instance : MySingleton = new MySingleton();

 private constructor()
  {

  }

 }

singleton: MySingleton = MySingleton.getInstance();
```

虽然您可以在 TypeScript 中实现您的单例，但您也可以利用创建单例的角度方式：服务！实际上，在 Angular 中，服务只实例化一次并注入到任何需要它的组件中。这是一个通过`NgModule`进行服务和注入的示例，我们在本书中已经见过：

```ts

 import { Injectable } from '@angular/core'; 

@Injectable() 
export class ApiService { 

  private static increment:number = 0; 

  public constructor(){ 
    ApiService.increment++; 
  } 

  public toString() :string { 
    return "Current instance: " + ApiService.increment; 
  } 

} 

 // ./app.component.ts

 import { Component } from '@angular/core'; 
import { ApiService } from './api.service'; 

@Component({ 
  selector: 'app-root', 
  templateUrl: './app.component.html', 
  styleUrls: ['./app.component.css'] 
}) 
export class AppComponent { 
  title = 'app'; 

  public constructor(api:ApiService){ 
    console.log(api); 
  } 
} 

 // ./other/other.component.ts

 import { Component, OnInit } from '@angular/core'; 
import { ApiService } from './../api.service'; 

@Component({ 
  selector: 'app-other', 
  templateUrl: './other.component.html', 
  styleUrls: ['./other.component.css'] 
}) 
export class OtherComponent implements OnInit { 

  public constructor(api:ApiService){ 
    console.log(api); 
  } 

  ngOnInit() { 
  } 

} 

 //app.module.ts

 import { BrowserModule } from '@angular/platform-browser'; 
import { NgModule } from '@angular/core'; 
import { MySingleton } from './singleton'; 

import { AppComponent } from './app.component'; 
import { OtherComponent } from './other/other.component'; 

import { ApiService } from './api.service'; 

@NgModule({ 
  declarations: [ 
    AppComponent, 
    OtherComponent 
  ], 
  imports: [ 
    BrowserModule 
  ], 
  providers: [ApiService], 
  bootstrap: [AppComponent] 
}) 
export class AppModule { 

} 
```

在上述代码中，我们有以下内容：

*   `APIService`，它显示了`@Injectable()`注释，使得它可以注射。此外，`APIService`还有一个`increment:number`属性，该属性在每次创建新实例时递增。由于`increment:number`是静态的，它将准确地告诉我们程序中有多少实例。最后，`APIService`有一个`toString:string`方法返回当前实例号。
*   `AppComponent`是接受`APIService`注射的经典组件。
*   `OtherComponent`是另一种接受`APIService`注射的经典成分。
*   `/app.module.ts`包含`NgModule`。在`NgModule`中，本书已经讨论了此处显示的大多数声明。新颖性来自于`providers: [APIService]`部分。这里，我们为`APIService`本身声明一个提供者。由于`APIService`没有做任何太疯狂的事情，它本身就足够了，可以通过使用类的引用来提供。更复杂的服务（例如，它们本身需要注入）需要定制的提供者。

现在，如果我们导航到这两个组件，结果如下：

```ts
Current instance: 1
Current instance: 1
```

这证明只创建了一个实例，并且将相同的实例注入到两个组件中。因此，我们有一个独生子女。然而，这种单身虽然方便，但并不真正安全。你为什么问？那么，`APIService`也可以在组件级提供，比如：

```ts
import { Component } from '@angular/core'; 
import { ApiService } from './api.service'; 

@Component({ 
  selector: 'app-root', 
  templateUrl: './app.component.html', 
  styleUrls: ['./app.component.css'] 
}) 
export class AppComponent { 
  title = 'app'; 

  public constructor(api:ApiService){ 
    console.log(api); 
  } 
} 
 // ./other.component.ts

 @Component({ 
  selector: 'app-root', 
  templateUrl: './app.component.html', 
  styleUrls: ['./app.component.css'] 
  providers: [APIService],
 })
 export class OtherComponent implements OnInit { 

  public constructor(api:ApiService){ 
    console.log(api); 
  } 

  ngOnInit() { 
  } 

} 
```

在这种情况下，将创建两个单独的实例，从而产生以下输出：

```ts
Current instance: 1
Current instance: 2
```

因此，使用 Angular 服务，您无法强制执行 singleton 模式，这与其普通的 TypeScript 对应。此外，普通类型脚本将比角度服务快一个数量级，因为我们完全跳过了注入过程。确切的数字在很大程度上取决于您机器的 CPU/RAM。

对于 singleton，唯一需要回答的问题是何时使用它，或者哪个实现性能最好。singleton 只强制程序中给定类的一个实例。因此，它非常适合任何与后端的通信或任何硬件访问。例如，在与后端通信的情况下，可能希望只有一个`APIService`处理 API 密钥、API 限制和`csrf`令牌，而不必确保我们在所有组件、模型等中传递相同的服务实例。在硬件访问的情况下，您可能希望确保只有一个连接打开到我们用户的网络摄像头或麦克风，以便在使用完后可以正确释放它们。

在性能方面，以下是每个实现的结果（以毫秒为单位）。每个版本我都运行了 100 次，排除了异常值（最好和最差的 5%），并在下表中对剩余的 90 个调用取平均值：

| **单身懒汉** | **单身早期** | **服务注入** |
| 196ms | 183ms | 186ms |

我运行的代码如下所示：

```ts
import { Component } from '@angular/core';

 import {MySingleton} from './singleton';
 import { SingletonService } from './singleton.service';

 @Component({
   selector: 'app-root',
   templateUrl: './app.component.html',
   styleUrls: ['./app.component.css']
 })
 export class AppComponent {
   title = 'app works!';

   constructor(private singleton:SingletonService){
     singleton.doStuff();
   }
   //OR
   constructor(){
     MySingleton.getInstance().doStuff();
   }
 }
```

对于服务注入的实验，我必须在`app.module.ts: providers: [SingletonService]`中添加以下行。

令我惊讶的是，从一种方法到另一种方法的结果相当接近。利用早期实例化的单例实现的性能仅比更实际的服务注入高 2%。具有延迟实例化的单例将以 196 毫秒的成绩登上领奖台（比单例早期实例化差 7%，比服务注入差 5%）。

# 工厂法

假设我们有一个`User`类，它有两个私有变量：`lastName:string`和`firstName:string`。另外，这个简单的类提出了打印`"Hi I am", this.firstName, this.lastName`的`hello`方法：

```ts
class User{
     constructor(private lastName:string, private firstName:string){
     }
     hello(){
         console.log("Hi I am", this.firstName, this.lastName);
     }
 }
```

现在，考虑我们通过 JSON API 接收用户。它很可能看起来像这样：

```ts
[{"lastName":"Nayrolles","firstName":"Mathieu"}...].  
```

通过以下代码片段，我们可以创建一个`User`：

```ts
let userFromJSONAPI: User = JSON.parse('[{"lastName":"Nayrolles","firstName":"Mathieu"}]')[0];
```

直到现在，TypeScript 编译器还没有抱怨，它执行得很顺利。它之所以有效，是因为`parse`方法返回`any`（例如，Java 对象的 TypeScript 等价物）。果然，我们可以将`any`转换为`User`。然而，`userFromJSONAPI.hello();`将产生以下结果：

```ts
json.ts:19
 userFromJSONAPI.hello();
                  ^
 TypeError: userFromUJSONAPI.hello is not a function
     at Object.<anonymous> (json.ts:19:18)
     at Module._compile (module.js:541:32)
     at Object.loader (/usr/lib/node_modules/ts-node/src/ts-node.ts:225:14)
     at Module.load (module.js:458:32)
     at tryModuleLoad (module.js:417:12)
     at Function.Module._load (module.js:409:3)
     at Function.Module.runMain (module.js:575:10)
     at Object.<anonymous> (/usr/lib/node_modules/ts-node/src/bin/ts-node.ts:110:12)
     at Module._compile (module.js:541:32)
     at Object.Module._extensions..js (module.js:550:10)
```

为什么？当然，赋值的左侧被定义为`User`，但当我们将其转换为 JavaScript 时，它将被删除。

类型安全的 TypeScript 方法如下所示：

```ts
let validUser = JSON.parse('[{"lastName":"Nayrolles","firstName":"Mathieu"}]')
 .map((json: any):User => {
     return new User(json.lastName, json.firstName);
 })[0];
```

有趣的是，函数的类型对您也没有帮助。在这两种情况下，它将显示`object`而不是`User`，因为 JavaScript 中不存在用户的概念。

虽然直接类型安全方法可以工作，但它既不具有很强的可扩展性，也不具有可重用性。实际上，map 回调方法必须在接收到 JSON 用户的任何地方复制。最方便的方法是通过`Factory`模式。工厂用于对象，而不向客户机公开实例化逻辑。

如果我们有一个工厂来创建用户，它将如下所示：

```ts

 export class POTOFactory{

     /**
      * Builds an User from json response
      * @param  {any}  jsonUser
      * @return {User}         
      */
     static buildUser(jsonUser: any): User {

         return new User(
             jsonUser.firstName,
             jsonUser.lastName
         );
     }

 }
```

在这里，我们有一个名为`buildUser`的`static`方法，该方法接收一个 JSON 对象，并获取 JSON 对象内部的所有必需值，以使用正确的属性调用一个假设的`User`构造函数。该方法是静态的，就像此类工厂的所有方法一样。实际上，我们不需要在工厂中保存任何状态或实例绑定变量；我们只封装了用户的可怕创造。请注意，您的工厂可能会与其他 POTO 共享。

# 观察者

允许一个对象（称为主体）跟踪其他对象（称为观察者）的可观察模式对主体状态感兴趣。当主体状态改变时，它会通知其观察者。这背后的机制非常简单。

让我们来看看下面的观察者/主题实现在纯 TypeScript（没有角度 2 或任何类型的框架，只是 TypeScript 稿）。首先，我定义了一个`Observer`接口，任何具体实现都必须实现该接口：

```ts
export interface Observer{ 
    notify(); 
}
```

此接口仅定义`notify()`方法。当主体（观察者正在观察的对象）的状态发生变化时，将调用此方法。然后，我有一个接口的实现，名为`HumanObserver`：

```ts
export class HumanObserver implements Observer{ 
    constructor(private name:string){}

    notify(){

        console.log(this.name, 'Notified');
    } 
} 
```

此实现利用了 TypeScript 属性构造函数，您可以在构造函数中定义类的属性。此符号与以下符号 100%等效，但长度较短：

```ts
private name:string; 
constructor(name:string){

        this.name = name;
}
```

根据`Observer`接口和`HumanObserver`的定义，我们可以进入主题。我定义了一个管理观察者的主题类。该类有三种方法：`attachObserver`、`detachObserver`和`notifyObservers`：

```ts
export class Subject{ 
private observers:Observer[] = [];

/**
* Adding an observer to the list of observers
*/
attachObserver(observer:Observer):void{

        this.observers.push(observer);
}

/**
* Detaching an observer
*/
detachObserver(observer:Observer):void{

    let index:number = this.observers.indexOf(observer);

    if(index > -1){

        this.observers.splice(index, 1);
    }else{

        throw "Unknown observer";
    }
}

/**
* Notify all the observers in this.observers
*/
protected notifyObservers(){

    for (var i = 0; i < this.observers.length; ++i) {

        this.observers[i].notify();
    }
} 
} 
```

`attachObserver`方法将新的观察者推入`observers`属性，而`detachObserver`将其移除。

主题实现通常带有附加/分离、订阅/取消订阅或添加/删除前缀。

最后一个方法是`notifyObservers`，它迭代观察者并调用其 notify 方法。允许我们展示可观察机制的最后一个类是 IMDB，它扩展了`subject`。添加电影时，它将通知观众：

```ts
export class IMDB extends Subject{

    private movies:string[] = [];

     public addMovie(movie:string){

         this.movies.push(movie);
         this.notifyObservers();
     }
 }
```

为了使作品相互交流，我们必须：创建一个`Subject`，创建一个`Observer`，将`Observer`附加到`Subject`，并通过`addMovie`方法改变主体的状态。

更具体地说，这里是前面列表的一个实现：

```ts
let imdb:IMDB = new IMDB();
 let mathieu:HumanObserver = new HumanObserver("Mathieu");
 imbd.attachObserver(mathieu);
 imbd.addMovie("Jaws");
```

为了加快我们的开发过程，我们将安装`ts-node`。这个节点包将把 TypeScript 文件转换成 JavaScript，并解决所述文件之间的依赖关系。

输出为`Mathieu Notified`。我们可以尝试分离`mathieu`并添加另一部电影：

```ts
imdb.detachObserver(mathieu);
 imdb.addMovie("Die Hard");
```

输出仍然是`Mathieu Notified`，这发生在我们添加`Jaws`电影之后。第二个添加的电影（`Die Hard`）不会触发控制台上的`Mathieu Notified`打印，因为它已被分离。

# 带有参数的 TypeScript 可观察对象

因此，这是观察者模式的基本实现。然而，它并不是完全成熟的，因为`HumanObserver`只知道它观察到的一个主题中发生了变化。因此，它必须迭代它观察到的所有主体，并对照其当前状态检查其先前状态，以确定发生了什么变化以及发生了什么变化。更好的方法是修改`Observer`的`notify`以使其包含更多信息。例如，我们可以添加如下可选参数：

```ts
export interface Observer{

     notify(value?:any, subject?:Subject);
 }

 export class HumanObserver implements Observer{

     constructor(private name:string){}

     notify(value?:any, subject?:Subject){

         console.log(this.name, 'received', value, 'from', subject);
     }
 }
```

`notify()`方法现在接受一个可选的值参数，该参数表示`subject`对象的新状态。我们还可以接收对`Subject`对象本身的引用。这在观察者观察多个主题时非常有用。在这种情况下，我们需要能够区分它们。因此，我们必须稍微更改主题和 IMDB，以便他们使用新的 notify：

```ts
export class Subject{

     private observers:Observer[] = [];

     attachObserver(oberver:Observer):void{

         this.obervers.push(oberver);
     }

     detachObserver(observer:Observer):void{
         let index:number = this.obervers.indexOf(observer);
         if(index > -1){
             this.observers.splice(index, 1);

         }else{

             throw "Unknown observer";
         }
     }

     protected notifyObservers(value?:any){

         for (var i = 0; i < this.obervers.length; ++i) {

             this.observers[i].notify(value, this);
         }
     }
 }

 export class IMDB extends Subject{

     private movies:string[] = [];

     public addMovie(movie:string){

         this.movies.push(movie);
         this.notifyObservers(movie);
     }
 }
```

最后，输出如下：

```ts
 Mathieu received Jaws from IMDB {

   observers: [ HumanObserver { name: 'Mathieu' } ],
   movies: [ 'Jaws' ] }
```

这比`Mathieu Notified`更具表现力。现在，当我们使用`Observer`模式进行异步编程时，我们真正的意思是我们要求一些东西，而不想在处理过程中等待做任何事情。相反，我们所做的是订阅响应事件，以便在响应到来时收到通知。在下面的部分中，我们将使用相同的模式和机制来处理角度。

# 观察 HTTP 响应

在本节中，我们将构建一个 JSON API，根据搜索参数返回电影。我们将利用 observer 设计模式的强大功能，让用户知道我们正在等待，并在需要时执行其他流程，而不是简单地等待 HTTP 查询完成。第一件事：我们需要一个数据源，用于类似 IMDB 的应用程序。如今，构建和部署能够解释 HTTP 查询并相应地发送结果的服务器端应用程序相对简单。然而，这超出了本书的范围。相反，我们要做的是获取托管在[的静态 JSON 文件 http://bit.ly/mastering-angular2-marvel](http://bit.ly/mastering-angular2-marvel) 。此文件包含惊奇漫画电影世界的一些最新电影。它包含一个 JSON 数组，将 14 部电影描述为 JSON 对象。这是第一部电影：

```ts
 {
 "movie_id" : 1,
 "title" : "The Incredible Hulk",
 "phase" : "Phase One: Avengers Assembled",
 "category_name" : "Action",
 "release_year" : 2005,
 "running_time" : 135,
 "rating_name" : "PG-13",
 "disc_format_name" : "Blu-ray",
 "number_discs" : 1,
 "viewing_format_name" : "Widescreen",
 "aspect_ratio_name" : " 2.35:1",
 "status" : 1,
 "release_date" : "June 8, 2008",
 "budget" : "150,000,000",
 "gross" : "263,400,000",
 "time_stamp" : "2018-06-08"
 },
```

您可以找到类似 IMDB 的应用程序将提供的标准信息，如发布年份、运行时间等。我们的目标是设计一个异步 JSON API，使每个字段都可以搜索。

在获取静态 JSON 文件时（我们不会插入、更新或删除任何元素），可接受的 API 调用如下：

```ts
IMDBAPI.fetchOneById(1);
 IMDBAPI.fetchByFields(MovieFields.release_date, 2015);
```

第一次调用只获取带有`movie_id = 1`的电影；第二个调用更通用，适用于任何字段。为了防止 API 使用者请求电影中不存在的字段，我们使用`Movie`类中定义的枚举器限制字段值。现在，这里重要的部分是这些调用的实际返回。事实上，它们将触发一个可观察机制，其中调用者将自己附加到一个可观察的 HTTP 调用。然后，当 HTTP 调用完成并且结果已根据查询参数进行过滤时，被调用方将通知调用方响应。因此，呼叫者不必等待被呼叫者（`IMDBAPI`，因为当请求完成时会通知他们。

# 实施

让我们深入了解一下实现。首先，我们需要使用 Angular CLI 创建一个新的 Angular 项目：

```ts
mkdir angular-observable
 ng init
 ng serve
```

接下来，我们需要一个模型来表示电影概念。我们将使用`ng g class`models/Movie 命令行生成此类。然后，我们可以添加一个构造函数来定义`Movie`模型的所有私有字段，这与我们对 getter 和 setter 所做的相同：

```ts
export class Movie {

     public constructor(
         private _movie_id:number,
         private _title: string,
         private _phase: string,
         private _category_name: string,
         private _release_year: number,
         private _running_time: number,
         private _rating_name: string,
         private _disc_format_name: string,
         private _number_discs: number,
         private _viewing_format_name: string,
         private _aspect_ratio_name: string,
         private _status: string,
         private _release_date: string,
         private _budget: number,
         private _gross: number,
         private _time_stamp:Date){
     }

     public toString = () : string => {

         return `Movie (movie_id: ${this._movie_id},
         title: ${this._title},
         phase: ${this._phase},
         category_name: ${this._category_name},
         release_year: ${this._release_year},
         running_time: ${this._running_time},
         rating_name: ${this._rating_name},
         disc_format_name: ${this._disc_format_name},
      number_discs: ${this._number_discs},
         viewing_format_name: ${this._viewing_format_name},
         aspect_ratio_name: ${this._aspect_ratio_name},
         status: ${this._status},
         release_date: ${this._release_date},
         budget: ${this._budget},
         gross: ${this._gross},
         time_stamp: ${this._time_stamp})`;

     }
    //GETTER
    //SETTER
 }

 export enum MovieFields{
     movie_id,
     title,
     phase,
     category_name,
     release_year,
     running_time,
     rating_name,
     disc_format_name,
     number_discs,
     viewing_format_name,
     aspect_ratio_name,
     status,
     release_date,
     budget,
     gross,
     time_stamp
 }
```

这里，电影 JSON 定义的每个字段都使用构造函数属性声明映射到`Movie`类的私有成员中

TypeScript 稿。我们还重写了`toString`方法，以便它打印每个字段。在`toString`方法中，我们利用了 backtick（```ts 提供的多行字符串和`${}`语法，该语法允许字符串和不同变量的串联。然后，我们有一个名为`MovieFields`的枚举器，它允许我们限制可搜索字段。

接下来，我们需要生成`IMDBAPI`类。由于`IMDBAPI`类在我们的程序中可能无处不在，我们将使其成为一种服务。优点是可以将服务注入任何组件或指令。此外，我们可以选择是希望 Angular 2 在每次注入时创建一个`IMDBAPI`实例，还是始终注入相同的实例。如果`IMDBAPI`的提供程序是在应用程序级别创建的，那么`IMDBAPI`的相同实例将提供给任何请求它的人。然而，在组件级，`IMDBAPI`的新实例将在每次实例化所述组件时创建并提供给该组件。在我们的例子中，只有一个`IMDBAPI`实例更有意义，因为它不会有任何特定的状态，这些状态很容易在组件之间发生变化。让我们生成`IMDBAPI`服务（`ng g s``services/IMDBAPI`并实现前面定义的两种方法：

```
IMDBAPI.fetchOneById(1);
 IMDBAPI.fetchByFields(MovieFields.release_date, 2015);
```ts

以下是使用`fetchOneById`方法的 IMDAPI 服务：

```
import { Injectable } from '@angular/core';
 import { Http }  from '@angular/http';
 import { Movie, MovieFields } from '../models/movie';
 import { Observable } from 'rxjs/Rx';
 import 'rxjs/Rx';

 @Injectable()

 export class IMDBAPIService {

   private moviesUrl:string = "app/marvel-cinematic-universe.json";

   constructor(private http: Http) { }
   /**
    * Return an Observable to a Movie matching id
    * @param  {number}           id
    * @return {Observable<Movie>}  
    */
   public fetchOneById(id:number):Observable<Movie>{
     console.log('fetchOneById', id);

         return this.http.get(this.moviesUrl)
         /**
         * Transforms the result of the HTTP get, which is observable
         * into one observable by item.
         */
         .flatMap(res => res.json().movies)

         /**
         * Filters movies by their movie_id

         */
         .filter((movie:any)=>{

             console.log("filter", movie);
             return (movie.movie_id === id)
         })

         /**
         * Map the JSON movie item to the Movie Model
         */
         .map((movie:any) => {

             console.log("map", movie);

             return new Movie(

                 movie.movie_id,
                 movie.title,
                 movie.phase,
                 movie.category_name,
                 movie.release_year,
                 movie.running_time,
                 movie.rating_name,
                 movie.disc_format_name,
                 movie.number_discs,
                 movie.viewing_format_name,
                 movie.aspect_ratio_name,
                 movie.status,
                 movie.release_date,
                 movie.budget,
                 movie.gross,
                 movie.time_stamp
             );
         });
   }
 }
```ts

# 了解执行情况

让我们把它一块一块地分解。首先，服务的声明非常标准：

```
import { Injectable } from '@angular/core'; 
import { Http } from '@angular/http'; 

import { Movie, MovieFields } from '../models/movie'; 
import { Observable } from 'rxjs/Rx'; 
import 'rxjs/Rx';

@Injectable()
 export class IMDBAPIService {
  private moviesUrl:string = "app/marvel-cinematic-universe.json";
  constructor(private http: Http) { }
```ts

服务是可注入的。因此，我们需要导入并添加`@Injectable`注释。我们还进口`Http`、`Movie`、`MovieFields`、`Observable`和`Rxjs`的操作商。**RxJS**代表 JavaScript 的**反应式扩展。它是执行观察者、迭代器和函数编程的 API。在 Angular 2 中，当谈到异步时，您在很大程度上依赖 RxJS。**

需要注意的一点是，我们使用 RxJS 5.0，这是一个完全重写，基于 RxJS 4.0 的相同概念。

`IMDBAPIService`还有一个对 JSON 文件路径的引用和一个用于接收 HTTP 服务注入的构造函数。在`fetchOneById`方法的实现中，我们可以看到四个相互链接的不同操作：`get`、`flatMap`、`filter`和`map`。`Get`返回 HTTP 请求主体上的可观察值。`flatMap`通过应用为源`Observable`发出的每个项目指定的函数来转换`get Observable`，该函数返回一个发出项目的`Observable`。`FlatMap`然后合并这些结果`Observables`的发射，将这些合并结果作为其序列发射。在我们的例子中，这意味着我们将对从 HTTPGET 接收的所有项目应用接下来的两个操作（filter 和 map）。过滤器检查当前电影的 ID 是否是我们要将电影的 JSON 表示映射为电影的 typeScript 表示（如`Movie`类）的 ID。

最后一个操作虽然违反直觉，但却是强制性的。实际上，人们可能会认为 JSON 表示和 TypeScript 表示是相同的，因为它们拥有相同的字段。但是，TypeScript 表示及其属性定义了函数，如`toString`、getter 和 setter。移除地图将返回一个包含`Movie`所有字段的`Object`实例，而不是一个。此外，类型转换在这方面也帮不了你。事实上，TypeScript transpiler 允许您将一个`Object`转换成`Movie`，但它仍然没有`Movie`类中定义的方法，因为当 TypeScript 转换成 JavaScript 时，静态类型的概念就消失了。以下内容在执行时将无法传输：

```
movie.movie_id(25) TypeError: movie.movie_id is not a function at Object.<anonymous>
movie: Movie = JSON.parse(`{
                             "movie_id" : 1,
                              "title" : "Iron Man",
                              "phase" : "Phase One: Avengers Assembled",
                             "category_name" : "Action",
                             "release_year" : 2015,
                              "running_time" : 126,
                              "rating_name" : "PG-13",
                              "disc_format_name" : "Blu-ray",
                              "number_discs" : 1,
                              "viewing_format_name" : "Widescreen",
                              "aspect_ratio_name" : " 2.35:1",
                              "status" : 1,
                              "release_date" : "May 2, 2008",
                              "budget" : "140,000,000",
                              "gross" : "318,298,180",
                              "time_stamp" : "2015-05-03"
        }`);
 Console.log(movie.movie_id(25));
```ts

现在，如果我们想使用`IMDB`服务，需要对 Angular CLI 生成的代码进行进一步修改。首先，我们需要修改`main.ts`使其看起来像这样：

```
import{ bootstrap } from '@angular/platform-browser-dynamic';
 import{ enableProdMode } from '@angular/core';
 import{ AngularObservableAppComponent, environment } from './app/';
 import{ IMDBAPIService } from './app/services/imdbapi.service';
 import { HTTP_PROVIDERS } from '@angular/http';
 if(environment.production)  {
     enableProdMode();
}

```ts

```
 bootstrap(AngularObservableAppComponent, 
    [IMDBAPIService , HTTP_PROVIDERS]
);
```ts

粗体的线条表示已添加的内容。我们进口我们的`IMDBService`和`HTTP_PROVIDERS`。这两个提供程序都是在应用程序级别声明的，这意味着将注入控制器或指令的实例将始终相同。

然后，我们修改生成的`angular-observable.component.ts`文件并添加以下内容：

```
import { Component } from '@angular/core';
import { IMDBAPIService } from './services/imdbapi.service';
import { Movie } from './models/movie';

@Component({
  moduleId: module.id, 
  selector: 'angular-observable-app', 
  templateUrl: 'angular-observable.component.html', 
  styleUrls: ['angular-observable.component.css']
 })
 export class AngularObservableAppComponent {
   title = 'angular-observable works!'; 
   private movies:Movie[] = [];
   private error:boolean = false; 
   private finished:boolean = false;

 constructor(private IMDBAPI:IMDBAPIService){
    this.IMDBAPI.fetchOneById(1).subscribe(
       value => {this.movies.push(value); console.log("Component",value)},
       error => this.error = true, 
       () => this.finished =true 
      )
   }
 }
```ts

[T1，T3]增加了【几个属性】。第一个属性是将存储查询结果的`Movie`数组，第二个和第三个属性标记是`error`和`termination`。在构造函数中，我们有一个`IMDBAPIService`的注入，我们同意`fetchOneById`方法的结果。`subscribe`方法需要三次回调：

*   **观察者：**通过观察方法接收价值收益率。它相当于我们在本章前面看到的通知方法。
*   **错误****可选**：当被观察对象产生错误时触发。
*   **完成****可选**：完成时触发

最后，我们可以修改`angular-ob``servable.component.html`文件来映射`AngularObservableAppComponent`数组的`movie`属性：

```
<h1>
  {{title}}
</h1>

<ul>
   <li *ngFor = "let movie of movies">{{movie}}</li> 
</ul>
```ts

我们可以看到，第一个电影项目已正确插入到我们的`ul`/`li`HTML 结构中。这段代码真正有趣的是执行的顺序。分析日志有助于我们掌握 RxJS 在 Angular 中异步的真正威力。以下是执行代码后控制台的外观：

```
javascript fetchOneById 1 :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:34 map Object :4200/app/angular-observable.component.js:21 Component Movie_aspect_ratio_name: " 2.35:1"_budget: "140,000,000"_category_name: "Action"_disc_format_name: "Blu-ray"_gross: "318,298,180"_movie_id: 1_number_discs: 1_phase: "Phase One: Avengers Assembled"_rating_name: "PG-13"_release_date: "May 2, 2008"_release_year: 2015_running_time: 126_status: 1_time_stamp: "2015-05-03"_title: "Iron Man"_viewing_format_name: "Widescreen"aspect_ratio_name: (...)budget: (...)category_name: (...)disc_format_name: (...)gross: (...)movie_id: (...)number_discs: (...)phase: (...)rating_name: (...)release_date: (...)release_year: (...)running_time: (...)status: (...)time_stamp: (...)title: (...)toString: ()viewing_format_name: (...)__proto__: Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object :4200/app/services/imdbapi.service.js:30 filter Object
```ts

正如您所看到的，`AngularObservableAppComponent`在 filter 函数分析所有项目之前被通知找到了与查询匹配的电影。作为提醒，ID 在`fetchOneById`中的操作顺序为：`get`、`flatMap`、`filter`和`map`，我们在`filter`和`map`方法中也有一条日志语句。因此，这里，`filter`操作分析第一个项目，它恰好是我们要查找的项目（`movie_id===1`，并将其转发给映射操作，映射操作将其转换为`Movie`。此`Movie`立即发送至`AngularObservableAppComponent`。我们可以清楚地看到，`AngularObservableAppComponent`组件中接收到的对象来自`Movie`类型，因为控制台提供了我们对`toString`方法的覆盖。然后，筛选操作将继续处理其余项目。他们都不匹配。因此，我们没有更多的通知。让我们用第二种方法`IMDBAPI.fetchByField`进一步测试这一点：

```

 public fetchByField(field:MovieFields, value:any){
 console.log('fetchByField', field, value); 
 return this.http.get (this.moviesUrl)
      .flatMap(res => res.json().movies)
 /**
 * Filters movies by their field
 */
 .filter((movie:any) =>{

     console.log("filter" , movie);
     return (movie[MovieFields[field]] === value)
  })

 /**
 * Map the JSON movie item to the Movie Model
 */
 .map(( movie: any) => {
     console.log ("map", movie);  
     return new Movie( 
         movie.movie_id, 
         movie.title,  
         movie.phase, 
         movie.category_name, 
         movie.release_year,  
         movie.running_time,  
         movie.rating_name,  
         movie.disc_format_name,  
         movie.number_discs, 
         movie.viewing_format_name,
         movie.aspect_ratio_name,  
         movie.status,
         movie.release_date,
         movie.budget,
         movie.gross,  
         movie.time_stamp
      );
   });
}
```ts

对于`fetchByField`方法，我们使用与`fetchById`相同的机制。毫不奇怪，操作保持不变：`get`、`flatMap`、`filter`和`map`。唯一的变化是过滤操作，我们现在必须过滤作为参数接收的字段：

```
return (movie[MovieFields[field]] === value).
```ts

对于 TypeScript 或 JavaScript 新手来说，这条语句可能有点难以接受。首先，`MovieFields[field]`部分解释为`enum`将被传输到以下 JavaScript 函数中：

```
(function(MovieFields) {
   MovieFields[MovieFields["movie_id"] = 0] = "movie_id";
   MovieFields[MovieFields["title"] = 1] = "title";
   MovieFields[MovieFields["phase"] = 2] = "phase"; 
   MovieFields[MovieFields["category_name"] = 3] = "category_name";
   MovieFields[MovieFields["release_year"] = 4] = "release_year";
   MovieFields[MovieFields["running_time"] = 5] = "running_time"; 
   MovieFields[MovieFields["rating_name"] = 6] = "rating_name";
   MovieFields[MovieFields["disc_format_name"] = 7] ="disc_format_name";
   MovieFields[MovieFields["number_discs"] = 8] = "number_discs";
   MovieFields[MovieFields["viewing_format_name"] = 9] = "viewing_format_name";
 MovieFields[MovieFields["aspect_ratio_name"] = 10] =  "aspect_ratio_name";
 MovieFields[MovieFields["status"] = 11] = "status"; 
 MovieFields[MovieFields["release_date"] = 12] = "release_date";
 MovieFields[MovieFields["budget"] = 13] = "budget";
 MovieFields[MovieFields["gross"] = 14] = "gross";
 MovieFields[MovieFields["time_stamp"] = 15] = "time_stamp";
 })(exports.MovieFields || (exports.MovieFields =  {}));
 var MovieFields = exports.MovieFields;
```ts

因此，`MovieFields.release_year`的值实际上是 4，`MovieFields`是一个静态数组。因此，请求`MovieFields`数组的第四个索引会得到字符串`release_year is`。因此，在我们当前的示例中，`movie[MovieFields[field]]`被解释为`movie["release_year is"]`。

现在，我们有五场比赛，而不是一场。通过对控制台的分析，我们可以看到，只要找到合适的对象，通知仍然会出现，而不是在它们都被过滤后出现：

```
fetchByField 4 2015
 imdbapi.service.js:43  filter Object  {movie_id: 1,  title: "Iron Man", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:47 map Object {movie_id: 1, title: "Iron Man", phase: "Phase One: Avengers Assembled", category_name: "Action",  release_year: 2015...}
 angular-observable.component.js:22 Component Movie {_movie_id: 1, _title: "Iron Man", _phase: "Phase One: Avengers Assembled", _category_name: "Action", _release_year: 2015...}
 imdbapi.service.js:43 filter Object {movie_id: 2, title: "The Incredible Hulk", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2008...}
 imdbapi.service.js:43 filter Object {movie_id: 3, title: "Iron Man 2", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:47map Object {movie_id: 3 =, title: "Iron Man 2", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 angular-observable.component.js:22 Component Movie{_movie_id: 3, _title: "Iron Man 2", _phase: "Phase One: Avengers Assembled", _category_name: "Action", _release_year:2015...}
 imdbapi.service.js:43 filter Object {movie_id: 4, title: "Thor", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year:2011...}
 imdbapi.service.js:43filter Object {movie_id: 5, title: "Captain America", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2011...}
 imdbapi.service.js:43 filter Object {movie_id: 6, title: "Avengers, The", phase: "Phase One: Avengers Assembled", category_name: "Science Fiction", release_year: 2012...}
 imdbapi.service.js:43 filter Object {movie_id: 7, title: "Iron Man 3", phase: "Phase Two", category_name: "Action", release_year : 2015...}
 imdbapi.service.js:47 map Object {movie_id: 7, title: "Iron Man 3", phase: "Phase Two", category_name: "Action", release_year:2015...}
 angular-observable.component.js: 22 Component Movie {_movie_id: 7, _title: "Iron Man 3", _phase: "Phase Two", _category_name:"Action", _release_year: 2015...}
 imdbapi.service.js:43 filter Object {movie_id: 8, title: "Thor: The Dark World", phase: "Phase Two", category_name: "Science Fiction", release_year: 2013...}
 imdbapi.service.js:43 filter Object {movie_id: 9, title: "Captain America: The Winter Soldier", phase: "Phase Two", category_name: "Action", release_year: 2014...}
 imdbapi.service.js:43 filter Object {movie_id: 10, title: "Guardians of the Galaxy", phase: "Phase Two", category_name: "Science Fiction", release_year: 2014...}
 imdbapi.service.js:43 filter Object {movie_id: 11, title: "Avengers: Age of Ultron", phase: "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 imdbapi.service.js:47 map Object {movie_id: 11, title: "Avengers: Age of Ultron", phase:  "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 angular-observable.component.js:22 Component Movie {_movie_id: 11, _title: "Avengers: Age of Ultron", _phase: "Phase Two", _category_name: "Science Fiction", _release_year:2015...}
 imdbapi.service.js:43 filter Object {movie_id: 12, title: "Ant-Man", phase: "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 imdbapi.service.js:47 map Object {movie_id: 12, title: "Ant-Man", phase: "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 angular-observable.component.js:22 Component Movie {_movie_id: 12, _title: "Ant-Man", _phase: "Phase Two", _category_name: "Science Fiction", _release_year: 2015...}
 imdbapi.service.js:43 filter Object {movie_id: 13, title: "Captain America: Civil War",phase: "Phase Three", category_name: "Science Fiction", release_year: 2016...}
imdbapi.service.js:43 filter Object {movie_id: 14, title: "Doctor Strange", phase: "Phase Two", category_name: "Science Fiction", release_year: 2016...}
```ts

现在，这种设计模式的另一个优势是能够取消订阅。为此，您只需获取订阅的引用并调用`unsubscribe()`方法，如下所示：

```
constructor(private IMDBAPI:IMDBAPIService{ 
 let imdbSubscription = this.IMDBAPI.fetchByField(MovieFields.release_year, 2015).subscribe(
       value=> {
            this.movies.push(value);
            console.log("Component", value)
            if(this.movies.length > 2){
                    imdbSubscription.unsubscribe();
             }
      },
     error => this.error = true,
     () => this.finished = true
    );
 }
```ts

在这里，我们在第三次通知后取消订阅。除此之外，可观测物体甚至会检测到没有人再观测它，并停止它正在做的任何事情。事实上，前面带有`unsubscribe`的代码产生：

```
fetchByField 4 2015
 imdbapi.service.js:43 filter Object {movie_id: 1, title: "Iron Man", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:49 map Object {movie_id: 1, title: "Iron Man", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 angular-observable.component.js:24 Component Movie {_movie_id: 1, _title: "Iron Man", _phase: "Phase One: Avengers Assembled", _category_name: "Action", _release_year: 2015...}
 imdbapi.service.js:43 filter Object {movie_id: 2, title: "The Incredible Hulk", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2008...}
 imdbapi.service.js:43 filter Object { movie_id: 3, title: "Iron Man 2", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:49 map Object {movie_id: 3, title: "Iron Man 2", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 angular-observable.component.js:24 Component Movie {_movie_id: 3, _title: "Iron Man 2", _phase:  "Phase One: Avengers Assembled", _category_name: "Action",_release_year: 2015...}
 imdbapi.service.js:43 filter Object {movie_id: 4, title: "Thor", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2011...}
 imdbapi.service.js:43 filter Object {movie_id: 5, title: "Captain America", phase: "Phase One: Avengers Assembled", category_name: "Action",release_year: 2011...}
 imdbapi.service.js:43 filter Object {movie_id: 6, title: "Avengers, The", phase: "Phase One: Avengers Assembled", category_name: "Science Fiction", release_year: 2012...}
 imdbapi.service.js:43 filter Object {movie_id: 7, title: "Iron Man 3", phase: "Phase Two", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:49 map Object {movie_id: 7, title: "Iron Man 3", phase: "Phase Two", category_name: "Action", release_year: 2015...}
 angular-observable.component.js:24 Component Movie {_movie_id: 7, _title: "Iron Man 3", _phase: "Phase Two", _category_name: "Action", _release_year: 2015...}
```ts

在第三次通知后，一切都停止。

# 承诺

promise 是 Angular 2 提供的另一个有用的异步概念。它承诺提供与`Observer`相同的功能：处理某些内容，并异步通知调用方答案可用。那么，为什么要让两个概念做同样的事情呢？嗯，`Observer`的冗长允许`Promise`没有的一件事：取消订阅。因此，如果您从未计划使用 observer 模式的取消订阅功能，那么最好使用`Promises`，在我看来，这在他们的写作和理解中更直观。为了强调观察者和承诺之间的区别，我们将采用与从 JSON API 获取电影之前相同的示例。`AngularObservableAppComponent`将对`IMDBAPIService`进行异步调用，并在应答后更新 HTML 视图。

以下是使用`Promise`代替`Observable`的`fetchOneById`方法：

```

 /**
 * Return a Promise to a Movie matching id
 *@param  {number}  id
 *@return {Promise<Movie>}
 */
 public fetchOneById(id:number) : Promise <Movie>{
 console.log('fecthOneById', id);

      return this.http.get(this.moviesUrl)
     /**
     * Transforms the result of the HTTP get, which is observable
     * into one observable by item.
     */
     .flatMap(res => res.json().movies)
     /**
     * Filters movies by their movie_id
     */
    .filter((movie:any) =>{
        console.log("filter", movie);
       return (movie.movie_id === id)
   })
   .toPromise()
   /**
 * Map the JSON movie item to the Movie Model
 */
    .then((movie:any) => {

       console.log("map", movie);
       return new Movie(
              movie.movie_id,
              movie.title,
              movie.phase,
              movie.category_name,
              movie.release_year,
              movie.running_time,
              movie.rating_name,
              movie.disc_format_name,
              movie.number_discs,
              movie.viewing_format_name,
              movie.aspect_ratio_name,
              movie.status,
              movie.release_date,
              movie.budget,
              movie.gross,
              movie.time_stamp
      )
});
 }
```ts

如此代码所示，我们从`flatMap`、`filter`、`map`、到`flatMap`、`filter`、`Promise`、`then`。新操作`toPromise`和`then`正在创建一个`Promise`对象，该对象将包含`filter`操作的结果，并且在`filter`操作完成后，将执行`then`操作。`then`操作可以看作是一张地图；它做同样的事情。要使用此代码，我们还必须将`AngularObservableAppComponent`中调用`IMDBAPIService`的方式更改为以下方式：

```

 this.IMDBAPI.fetchOneById(1).then(
        value => {
              this.movies.push(value);

              console.log("Component", value)
       },
       error => this.error = true
 );
```ts

再次，我们可以看到一个`then`操作，该操作将在`IMDBAPIService.FetchOneById`的承诺完成时执行。`then`操作接受两个回调：`onCompletion`和`onError`。第二个回调`onError`是可选的。现在，`onCompletion`回调只会在承诺完成后执行一次，如控制台所示：

```
imdbapi.service.js:30 filter Object {movie_id: 2, title: "The Incredible Hulk", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2008...}
 imdbapi.service.js:30 filter Object {movie_id: 3, title: "Iron Man 2", phase : "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:30 filter Object {movie_id: 4, title: "Thor", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2011...}
 imdbapi.service.js:30 filter Object {movie_id: 5, title: "Captain America", phase:  "Phase One: Avengers Assembled", category_name: "Action", release_year: 2011...}
 imdbapi.service.js:30 filter Object {movie_id: 6, title: "Avengers, The", phase: "Phase One: Avengers Assembled", category_name:"Science Fiction", release_year: 2012...}
 imdbapi.service.js:30 filter Object {movie_id: 7, title: "Iron Man 3", phase: "Phase Two", category_name: "Action", release_year: 2015...}
 imdbapi.service.js:30 filter Object {movie_id: 8, title: "Thor: The Dark World", phase: "Phase Two", category_name: "Science Fiction", release_year: 2013...}
 imdbapi.service.js:30 filter Object {movie_id: 9, title: "Captain America: The Winter Soldier", phase: "Phase Two", category_name: "Action",release_year: 2014...}
 imdbapi.service.js:30 filter Object {movie_id: 10, title: "Guardians of the Galaxy", phase: "Phase Two", category_name: "Science Fiction", release_year: 2014...}
 imdbapi.service.js:30 filter Object { movie_id: 11, title: "Avengers: Age of Ultron", phase: "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 imdbapi.service.js:30 filter Object {movie_id: 12, title: "Ant-Man", phase: "Phase Two", category_name: "Science Fiction", release_year: 2015...}
 imdbapi.service.js:30 filter Object {movie_id: 13, title: "Captain America: Civil War", phase: "Phase Three", category_name: "Science Fiction", release_year: 2016...}
 imdbapi.service.js:30 filter Object {movie_id: 14, title: "Doctor Strange", phase: "Phase Two", category_name: "Science Fiction", release_year: 2016...}
 imdbapi.service.js:35 map Object {movie_id: 1, title: "Iron Man", phase: "Phase One: Avengers Assembled", category_name: "Action", release_year: 2015...}
 angular-observable.component.js:23 Component Movie {_movie_id: 1, _title: "Iron Man", _phase: "Phase One: Avengers Assembled", _category_name: "Action",  _release_year: 2015...}
```ts

虽然`fetchOneById`方法对`IMDBAPIService`的修改最小，但我们必须对`fetchByField`进行更显著的修改。事实上，`onComplete`回调只执行一次，因此我们需要返回一个`Movie`数组，而不仅仅是一个`Movie`。以下是`fetchByField`方法的实现：

```
public fetchByField(field: MovieFields, value: any) :Promise<Movie[]>{
       console.log('fetchByField', field, value);
       return this.http.get(this.moviesUrl)
          .map(res => res.json().movies.filter(
              (movie)=>{
                  return (movie[MovieFields[field]] === value)
              })
         )
         .toPromise()
         /**
          * Map the JSON movie items to the Movie Model
         */
        .then((jsonMovies:any[]) => {
           console.log("map",jsonMovies);
           let movies:Movie[] = [];
           for (var i = 0; i < jsonMovies.length; i++) {
               movies.push(
                  new Movie(
                      jsonMovies[i].movie_id,
                      jsonMovies[i].title,
                      jsonMovies[i].phase,
                      jsonMovies[i].category_name,
                      jsonMovies[i].release_year,
                      jsonMovies[i].running_time,
                      jsonMovies[i].rating_name,
                      jsonMovies[i].disc_format_name,
                      jsonMovies[i].number_discs, 
                      jsonMovies[i].viewing_format_name, 
                      jsonMovies[i].aspect_ratio_name, 
                      jsonMovies[i].status,
                      jsonMovies[i].release_date, 
                      jsonMovies[i].budget, 
                      jsonMovies[i].gross,
                      jsonMovies[i].time_stamp
                  )
                )
              }
              return movies;  
           });
 }
```ts

为了实现这一点，我用`flatMap`交换经典地图作为第一个操作。在映射中，我直接获取对 JSON`movie`数组的引用，并应用字段过滤器。结果转化为承诺并在`then`中处理。`then`操作接收 JSON`movies`数组并将其转换为`Movie`数组。这将生成一个`Movie`数组，作为承诺的结果返回给调用者。`AngularObservableAppComponent`中的调用也有点不同，因为我们现在期望一个数组：

```

 this.IMDBAPI.fetchByField(MovieFields.release_year, 2015).then(
     value => {
        this.movies = value;
        console.log("Component", value)
     },
     error => this.error = true
 )
```ts

另一种使用`Promise`的方法是通过 fork/join 范式。实际上，可以启动许多进程（fork）并等待所有承诺完成，然后再将聚合结果发送给调用方（join）。因此，对`fetchByField`方法进行增压是相对容易的，因为它可以在许多具有逻辑或逻辑的领域中运行。以下是我们需要实现逻辑或的三种非常简短的方法：

```

 /**
 * Private member storing pending promises
 */
 private promises:Promise<Movie[]>[] = [];
 /**
  * Register one promise for field/value. Returns this
  * for chaining i.e.
  *
  * byField(Y, X)
  * .or(...)
  * .fetch()
  *
  * @param {MovieFields} field
  * @param {any}         value
  * @return {IMDBAPIService}
  */
public byField(field:MovieFields, value:any):IMDBAPIService{

   this.promises.push(this.fetchByField(field, value));
   return this; 
 }
 /**
 * Convenient method to make the calls more readable, i.e.
 *
 * byField(Y, X)
 * .or(...)
 * .fetch()
 *
 * instead of
 *
 * byField(Y, X)
 * .byField(...)
 * .fetch()
 *
 * @param {MovieFields} field
 * @param {any}         value
 * @return {IMDBAPIService}
 */
public or(field:MovieFields, value:any):IMDBAPIService{
 return this.byField(field, value);

}

 /** 
  * Join all the promises and return the aggregated result. 
  * 
  *@return {Promise<Movie[]>} 
  */
public fetch():Promise<Movie[]>{
 return Promise.all(this.promises).then((results:any) => {
         //result is an array of movie arrays. One array per
         //promise. We need to flatten it.
         return [].concat.apply([], results);
 }); 
}
```ts

在这里，我提供了两种方便的方法，`field`和`or`，它们将一个`MovieField`和一个值作为参数，并创建一个新的承诺。他们都返回`this`进行链接。`fetch`方法将所有承诺连接在一起，并合并它们各自的结果。在`AngularObservableAppComponent`中，我们现在有以下内容：

```

 this.IMDBAPI.byField(MovieFields.release_year, 2015) 
             .or(MovieFields.release_year, 2014)
             .or(MovieFields.phase, "Phase Two") 
             .fetch()
             .then (
                value => {
                    this.movies = value;
                    console.log("Component", value)
                },
            error => this.error = true
        );
```

这非常容易阅读和理解，同时保留 Angular 2 的所有异步功能。

# 总结

在本章中，我们学习了如何使用一些最有用的经典模式：组件模式、单例模式和观察者模式。我们学习了如何使用纯 TypeScript 以及 Angular 2 构建块来实现它。本章代码可在此处找到：[https://github.com/MathieuNls/Angular-Design-Patterns-and-Best-Practices/tree/master/chap4](https://github.com/MathieuNls/Angular-Design-Patterns-and-Best-Practices/tree/master/chap4) 。

在下一章中，我们将重点讨论模式，旨在简化和组织 Angular 2 应用程序中的导航。