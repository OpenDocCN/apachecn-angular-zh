# 四、深度 Angular 指令

**指令**无处不在。它们是Angular测量的基本构件。应用的每次扩展都导致我们创建了新的**组件指令**。这些组件指令进一步消耗了**属性指令**（如`NgClass`和`NgStyle`）和**结构指令**（如`NgIf`和`NgFor`）来扩展它们的行为。

虽然我们已经构建了许多组件指令和一个单独的属性指令，但仍然有一些指令构建的概念值得探索。属性和结构指令尤其如此，我们还将详细介绍它们。

本章将介绍的主题包括：

*   **构建指令**：我们构建多个指令，并了解指令在哪里有用，它们与组件的区别，以及指令如何相互通信和/或它们的主组件。我们研究了所有指令类型，包括*成分指令*、*属性指令*和*结构指令*。
*   **异步验证**：Angular 可以轻松验证需要服务器交互的规则，因此本质上是异步的。在本章中，我们将构建第一个异步验证器。
*   **使用渲染器进行视图操作**：渲染器允许以平台无关的方式进行视图操作。我们将利用 busy indicator 指令的渲染器，并了解其 API。
*   **主机绑定**：主机绑定允许指令与其*主机元素*进行通信。本章介绍如何将这些绑定用于指令。
*   **指令注入**：Angular DI 框架允许基于指令在 HTML 层次结构中声明的位置进行指令注入。我们将介绍与此类注射相关的多种情况。
*   **使用视图子项和内容子项**：组件能够将外部视图模板包含到自己的视图中。我们将在这里介绍如何使用注入内容。

*   **理解 NgIf 平台指令**：我们将深入了解`NgIf`平台指令，并尝试理解*结构指令*如`NgIf`的工作原理。
*   **Angular 组件的视图封装**：我们将学习 Angular 如何使用源自*web 组件*的概念来支持视图和样式封装。

# 构建远程验证程序指令

我们结束了[第 3 章](03.html)、*支持服务器数据持久化*，在 MongoDB 商店中有*训练跑步者*能够管理训练。由于每个训练都应该有一个唯一的名称，因此我们需要强制实施唯一性约束。因此，在创建/编辑训练时，每次用户更改训练名称时，我们都可以查询 MongoDB 以验证名称是否已存在。

与任何远程调用一样，此检查是异步的，因此需要一个*远程验证器*。我们将使用 Angular 的*异步验证器支持*构建这个远程验证器。

**异步验证器**与标准自定义验证器类似，只是验证检查的返回值不是返回键值对象映射或 null，而是一个**承诺**。此承诺最终通过设置验证状态（如果存在错误）或 null（在验证成功时）来解决。

我们将创建一个验证指令，用于检查训练名称。此类指令有两种可能的实施方法：

*   我们可以创建一个专门用于唯一名称验证的指令
*   我们可以创建一个可以执行任何远程验证的通用指令

Validation directives
While we are building a validation directive here, we could have built a standard custom validator class. The advantage of creating a directive is that it allows us to incorporate the directive in a template-driven form approach, where the directive can be embedded in the view HTML. Or, if the form has been generated using a model (reactive approach), we can directly use the validator class while creating the `Control` objects.

首先，针对数据源（即*mLab*数据库）检查重复名称的要求似乎过于具体，无法由通用验证器处理。但是，通过一些合理的假设和设计选择，我们仍然可以实现一个验证器，它可以处理所有类型的远程验证，包括训练名称验证。

计划是创建一个验证程序，将实际的验证逻辑具体化。指令将以验证函数作为输入。这意味着实际的验证逻辑不是验证器的一部分，而是实际需要验证输入数据的组件的一部分。指令的任务只是调用函数并根据函数的返回值返回相应的错误键。

让我们将这一理论付诸实践，并构建我们的远程验证指令，恰当地命名为`RemoteValidatorDirective`。

The companion code base for the following section is Git branch `checkpoint6.1`. You can work along with us or check out the implementation available in the aforementioned folder. Or if you are not using Git, download the snapshot of `checkpoint6.1` (a ZIP file) from GitHub location [http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.

# 使用异步验证程序验证训练名称

与自定义验证器一样，异步验证器也从同一`Validator`类继承；但这一次，异步验证器没有返回对象映射，而是返回一个`Promise`。

让我们看看验证器的定义。从 GitHub 复制验证器的定义（[http://bit.ly/ng6be-6-1-remote-validator-directive-ts](http://bit.ly/ng6be-6-1-remote-validator-directive-ts) 文件夹，并将其添加到`shared`模块文件夹中。验证程序定义如下所示：

```ts
import { Directive, Input } from '@angular/core';
import { NG_ASYNC_VALIDATORS, FormControl } from '@angular/forms';

@Directive({
  selector: '[abeRemoteValidator][ngModel]',
  providers: [{ provide: NG_ASYNC_VALIDATORS, useExisting: RemoteValidatorDirective, multi: true }]
})
export class RemoteValidatorDirective {

  @Input() abeRemoteValidator: string;
  @Input() validateFunction: (value: string) => Promise<boolean>;

  validate(control: FormControl): { [key: string]: any } {
    const value: string = control.value;
    return this.validateFunction(value).then((result: boolean) => {
      if (result) {
        return null;
      }
      else {
        const error: any = {};
        error[this.abeRemoteValidator] = true;
        return error;
      }
    });
  }
} 
```

请记住从共享模块导出此指令，以便我们在训练生成器模块中使用它。

由于我们将验证器注册为指令，而不是使用`FormControl`实例注册（通常在使用*反应式方法*构建表单时使用），因此我们需要使用以下语法进行额外的提供者配置设置（在前面的`@Directive`元数据中添加）：

```ts
 providers:[{ provide: NG_ASYNC_VALIDATORS, useExisting: RemoteValidatorDirective,  multi: true }] 
```

此语句向现有异步验证器注册验证器。

The strange directive selector, `selector: `[abeRemoteValidator][ngModel]``, used in the preceding code will be covered in the next section, where we will build a busy indicator directive.

在深入研究验证器实现之前，让我们将其添加到训练名称输入中。这将帮助我们将验证器的行为与其使用关联起来。

使用验证器声明更新训练名称输入（`workout.component.html`）：

```ts
<input type="text" name="workoutName" ... 
 abeRemoteValidator="workoutname"[validateFunction]="validateWorkoutName"> 
```

Prefixing the directive selector
Always prefix your directives with an identifier (`abe` as you just saw) that distinguishes them from framework directives and other third-party directives.

**注**：如果`ngModelOptions`、`updateOn`设置为`submit,`则将其更改为`blur`。

指令实现需要两个输入：用于设置*错误键*的*验证键*通过指令属性`abeRemoveValidator,`，以及调用*验证函数*（`validateFunction`来验证控件的值。这两个输入都用`@Input`装饰符进行注释。

The input parameter `@Input("validateFunction") validateFunction: (value: string) => Promise<boolean>;`, binds to a function, not a standard component property. We are allowed to treat the function as a property due to the nature of the underlying language, TypeScript (as well as JavaScript).

当异步验证触发时（更改为`input`时），Angular 调用函数，传入底层`control`。作为第一步，我们提取当前输入值，然后使用此输入调用`validateFunction`函数。`validateFunction`返回一个承诺，该承诺最终应解决`true`或`false`：

*   如果承诺解析为`true`，则验证成功，承诺回调函数返回`null`。
*   如果为`false`，则验证失败，返回错误键值映射。这里的*键*是我们在使用验证器（`a2beRemoteValidator="workoutname"`时设置的字符串文字。

当输入上声明了多个验证器时，这个*键*就派上了用场，允许我们识别失败的验证。

在“训练”组件中，下一步添加此失败的验证消息。在*训练名称*的现有验证`label`后添加此标签声明：

```ts
<label *ngIf="name.control.hasError('workoutname')" class="alert alert-danger validation-message">A workout with this name already exists.</label> 
```

然后将这两个标签包装在一个`div`中，就像我们对*训练标题*错误标签所做的那样。

`hasError`功能检查`'workoutname'`验证密钥是否存在。

此实现的最后一个缺失部分是我们在应用指令（`[validateFunction]="**validateWorkoutName**"`时指定的实际验证函数，但从未实现。

将`validateWorkoutName`功能添加到`workout.component.ts`：

```ts
validateWorkoutName = (name: string): Promise<boolean> => {
    if (this.workoutName === name) { return Promise.resolve(true); }
    return this.workoutService.getWorkout(name).toPromise()
      .then((workout: WorkoutPlan) => {
        return !workout;
      }, error => {
        return true;
      });
  }  
```

在探索前面的函数的作用之前，我们需要对`WorkoutComponent`类进行更多的修复。`validateWorkoutName`功能依赖于`WorkoutService`来获得具有特定名称的训练。让我们在构造函数中注入服务，并在导入部分添加必要的导入：

```ts
import { WorkoutService }  from "../../core/workout.service"; 
... 
constructor(... , private workoutService: WorkoutService) { 
```

然后声明变量`workoutName`和`queryParamsSub`：

```ts
private workoutName: string;
queryParamsSub: Subscription
```

并将此声明添加到`ngOnInit`：

```ts
this.queryParamsSub = this.route.params.subscribe(params => this.workoutName = params['id']); 
```

前面的语句通过观察（订阅）可观察的`route.params`服务来设置当前训练名称。`workoutName`用于在使用原始训练名称的情况下跳过现有训练的训练名称验证。

之前创建的订阅需要清除，以避免内存泄漏，因此将此行添加到`ngDestroy`函数中：

```ts
this.queryParamsSub.unsubscribe();
```

将`validateWorkoutName`函数定义为*实例函数*（使用*箭头操作符*）而不是将其定义为标准函数（在*原型*上声明该函数）的原因是`'this'`范围问题。

查看`RemoteValidatorDirective`中的验证器函数调用（使用`@Input("validateFunction") validateFunction;`声明）：

```ts
return this.validationFunction(value).then((result: boolean) => { ... }); 
```

调用函数（名为`validateFunction`时，`this`引用绑定到`RemoteValidatorDirective`而不是`WorkoutComponent`。由于`execute`引用了前面设置中的`validateWorkoutName`功能，因此对`validateWorkoutName`内部`this`的任何访问都是有问题的。

这会导致`validateWorkoutName`中的`if (this.workoutName === name)`语句失败，因为`RemoteValiatorDirective`没有`workoutName`实例成员。通过将`validateWorkoutName`定义为实例函数，*TypeScript*编译器*在定义函数时围绕`this`的值创建一个闭包*。

在新声明中，`validateWorkoutName`中的`this`始终指向`WorkoutComponent`，无论函数如何调用。

我们还可以查看`WorkoutComponent`的已编译 JavaScript，了解闭包是如何与`validateWorkoutName`相关的。我们感兴趣的生成代码部分如下：

```ts
function WorkoutComponent(...) { 
 var _this = this; 
  ... 
  this.validateWorkoutName = function (name) { 
 if (_this.workoutName === name) 
      return Promise.resolve(true); 
```

如果我们看一下验证函数的实现，就会发现它涉及到查询*mLab*以获取特定的训练名称。`validateWorkoutName`函数在未找到同名训练时返回`true`，在找到同名训练时返回`false`（实际返回*承诺*。

The `getWorkout` function on `WorkoutService` returns an *observable,* but we convert it into a *promise* by calling the `toPromise` function on the observable.

现在可以测试验证指令。创建新训练并输入现有训练名称，如`7minworkout`。查看验证错误消息最终如何显示：

![](img/3f7be3d2-984e-406c-858c-02aca3b262ce.png)

杰出的看起来不错，但还是少了一些东西。未通知用户我们正在验证训练名称。我们可以改进这种经验。

# 构建忙指示符指令

当远程验证训练名称时，我们希望用户能够在后台了解该活动。当远程验证发生时，输入框周围的视觉线索应该可以达到目的。

深思熟虑；有一个带有异步验证器（执行远程验证）的输入框，我们希望在验证过程中为输入框添加可视线索。似乎是要解决的常见模式？确实如此，所以让我们创建另一个指令！

但在我们开始实施之前，必须了解，我们并不是孤军奋战。忙碌指示器指令需要另一个指令`NgModel`的帮助。我们已经使用了[第 2 章](04.html)*私人教练*中`input`元素的`NgModel`指令。`NgModel`帮助我们跟踪输入元素状态。以下示例摘自[第 2 章](02.html)*私人教练*，并强调`NgModel`如何帮助我们验证输入：

```ts
<input type="text" name="workoutName" #name="ngModel"  class="form-control" id="workout-name" ... [(ngModel)]="workout.name" required> 
... 
<label *ngIf="name.control.hasError('required') && (name.touched || submitted)" class="alert alert-danger">Name is required</label>  
```

即使在上一节中完成的唯一训练名称验证也采用了使用`NgModel`检查验证状态的相同技术。

让我们从定义指令的大纲开始。使用`src/app/shared`文件夹中的 CLI 生成器创建`busy-indicator.directive.ts`文件：

```ts
ng generate directive busy-indicator
```

另外，通过将指令添加到共享模块文件`shared.module.ts`中的`exports`数组来导出它。

接下来，使用`NgModel`注入更新指令的构造函数，并从`@angular/forms`导入`NgModel`引用：

```ts
constructor(private model: NgModel) { }
```

这指示 Angular 注入声明该指令的元素的`NgModel`实例。请记住，`NgModel`指令已经出现在`input`（`workoutname`上）：

```ts
<input... name="workoutName" #name="ngModel" [(ngModel)]="workout.name" ...>
```

这足以将我们的新指令集成到“训练”视图中，所以让我们快速完成。

从`workout-builder`打开`workout.component.html`并将忙碌指示灯指令添加到训练名称`input`：

```ts
<input type="text" name="workoutName" ... abeBusyIndicator> 
```

创建一个新的训练或打开一个现有的训练，以查看`BusyIndicatorDirective`是否已加载，以及`NgModel`注射是否正常工作。这可以通过在`BusyIndicatorDirective`构造函数中设置断点来轻松验证。

Angular 将在输入 HTML 中遇到`ngModel`时创建的`NgModel`实例注入到`BusyIndicatorDirective`中。

您可能想知道，如果我们在没有`ngModel`属性的输入元素上应用此指令，或者实际上在任何 HTML 元素/组件上应用此指令，会发生什么情况，例如：

```ts
<div abeBusyIndicator></div> 
<input type="text" abeBusyIndicator> 
```

注射有效吗？

当然不是！我们可以在“创建训练”视图中进行尝试。打开`workout.component.html`并在训练名称`input`上方添加以下`input`。刷新应用：

```ts
<input type="text" name="workoutName1" a2beBusyIndicator> 
```

Angular 引发异常，如下所示：

```ts
 EXCEPTION: No provider for NgModel! (BusyIndicatorDirective -> NgModel)
```

如何避免这种情况？Angular 的 DI 可以拯救我们，因为它允许我们声明一个可选的依赖项。

Remove the `input` control that you just added before proceeding further.

# 使用@optional decorator 注入可选依赖项

Angular 有一个`@Optional`修饰符，当应用于构造函数参数时，如果找不到依赖项，它会指示 Angular*注入器*注入`null`。

因此，繁忙指示器构造函数可以编写如下：

```ts
constructor(@Optional() private model: NgModel) { } 
```

问题解决了吗？不是真的；如前所述，我们要求`BusyIndicatorDirective`的`NgModel`指令起作用。因此，虽然我们学到了一些新的东西，但在当前的情况下，它不是很有用。

Before proceeding further, remember to revert the `workoutname``input` to its original state, with `abeBusyIndicator` applied.

只有当元件上已经存在`NgModel`指令时，才应应用`BusyIndicatorDirective`。

`selector`指令这次将拯救我们的一天。将`BusyIndicatorDirective`选择器更新为：

```ts
selector: `[abeBusyIndicator][ngModel]` 
```

仅当元素上存在`a2beBusyIndicator`与`ngModel`属性的组合时，此选择器才会创建`BusyIndicatorDirective`。问题解决了！

现在是添加实际实现的时候了。

# 实现一–使用渲染器

为了使`BusyIndicatorDirective`能够工作，它需要知道`input`上的异步验证何时启动以及何时结束。此信息仅适用于`NgModel`指令。`NgModel`有一个属性`control`，它是`Control`类的一个实例。这个`Control`类跟踪输入的当前状态，包括以下内容：

*   当前分配的验证程序（同步和异步）
*   当前值
*   输入元素状态，如`pristine`、`dirty`、`touched`
*   输入验证状态，在异步执行验证的情况下，可以是`valid`、`invalid`或`pending`中的任意一种
*   当值更改或验证状态更改时跟踪的事件

`Control`似乎是一个有用的类，我们感兴趣的是`pending`状态！

让我们为`BusyIndicatorDirective`类添加第一个工具。使用以下代码更新类：

```ts
private subscriptions: Array<any> = []; 
ngAfterViewInit(): void {
    this.subscriptions.push(
      this.model.control.statusChanges.subscribe((status: any) => {
        if (this.model.control.pending) {
          this.renderer.setElementStyle(this.element.nativeElement, 'border-width', '3px');
          this.renderer.setElementStyle(this.element.nativeElement, 'border-color', 'gray');
        }
        else {
          this.renderer.setElementStyle(this.element.nativeElement, 'border-width', null);
          this.renderer.setElementStyle(this.element.nativeElement, 'border-color', null);
        }
      }));
  }  
```

当我们在`ngAfterViewInit`函数中使用它们时，需要向构造函数添加两个新的依赖项。更新`BusyIndicatorDirective`构造函数，如下所示：

```ts
constructor(private model: NgModel,  
 private element: ElementRef, private renderer: Renderer) { }
```

并在`'@angular/core'`中增加`ElementRef`和`Renderer`的进口。

`ElementRef`是底层 HTML 元素上的包装器对象（本例中为`input`。`MyAudioDirective`指令使用`ElementRef`获取基础`Audio`元素。

`Renderer`注射值得注意。调用`setElementStyle`是`Renderer`负责管理 DOM 的一个死赠品。但是，在我们深入研究`Renderer`的角色之前，让我们试着了解前面的代码在做什么。

在前面的代码中，模型上的`control`属性`NgModel`实例定义了一个事件`Observable`、`statusChanges`，我们可以订阅该事件，以了解控件验证状态何时发生变化。可用的验证状态为`valid`、`invalid`和`pending`。

订阅检查控件状态是否为`pending`，并相应地使用`Renderer`API 函数`setElementStyle`修饰底层元素。我们设置输入的`border-width`和`border-color`。

前面的实现被添加到`ngAfterViewInit`指令生命周期挂钩中，该挂钩在视图初始化后调用。

让我们试试看。打开创建训练页面或现有的*7 分钟训练*。一旦我们离开训练名称输入，`input`样式将更改，并在训练名称远程验证完成后恢复。美好的

![](img/298a4f9b-ed8c-4e43-8f9d-b98633a24d68.png)

在继续之前，还要将 un 订阅代码添加到`BusyIndicatorDirective`中，以避免内存泄漏。将此功能（生命周期挂钩）添加到`BusyIndicatorDirective`：

```ts
ngOnDestroy() { 
    this.subscriptions.forEach((s) => s.unsubscribe()); 
} 
```

Always unsubscribe from observables
Always remember to unsubscribe from any `Observable`/`EventEmitter` subscription done in the code to avoid memory leaks.

实现看起来不错。`Renderer`正在做它的工作。但还有一些问题没有答案。

为什么不抓住底层 DOM 对象并使用标准 DOM API 来操作输入样式呢？为什么我们需要*渲染器*？

# Angular渲染器，平移层

Angular 2 的主要设计目标之一是使其能够跨环境、框架和设备运行。Angular 通过将核心框架实现划分为**应用层**和**呈现层**实现了这一点。应用层具有我们交互的 API，而呈现层提供了应用层可以使用的抽象，而不必担心实际视图的呈现方式和位置。

通过分离渲染层，Angular 理论上可以在各种设置中运行。这些包括（但不限于）：

*   浏览器
*   出于明显的性能原因，浏览器主线程和 web 辅助线程
*   服务器端渲染
*   本地应用框架；正在努力将 Angular 与`NativeScript`与`ReactNative`整合
*   测试，允许我们在 web 浏览器之外测试应用 UI

The `Renderer` implementation that Angular uses inside our browser is `DOMRenderer`. It is responsible for translating our API calls into browser DOM updates. In fact, we can verify the renderer type by adding a breakpoint in the `BusyIndicatorDirective`'s constructor and seeing the value of `renderer`.

正是出于这个原因，我们避免了直接操纵`BusyIndicatorDirective`中的 DOM 元素。您永远不知道代码将在哪里运行。我们本可以轻松做到这一点：

```ts
this.element.nativeElement.style.borderWidth="3px"; 
```

相反，我们使用`Renderer`以平台不可知的方式做同样的事情。

请看`Renderer`API 函数`setElementStyle`：

```ts
this.renderer.setElementStyle( 
             this.element.nativeElement, "border-width", "3px"); 
```

它接受必须在其上设置样式的元素、要更新的样式属性和要设置的值。`element`引用注入`BusyIndicatorDirective`的`input`元素。

Resetting styles
Styles set by calling `setElementStyle` can be reset by passing a `null` value in the third argument. Check out the `else` condition in the preceding code.

`Renderer`API 还有许多其他方法可用于设置属性、设置属性、侦听事件，甚至创建新视图。无论何时构建新指令，请记住评估用于 DOM 操作的`Renderer`API。

A more detailed explanation of `Renderer` and its application is available as part of Angular's design documents here: [http://bit.ly/ng2-render](http://bit.ly/ng2-render)

我们还没做完！借助 Angular 的强大功能，我们可以改进实现。Angular 允许我们在指令实现中进行*主机绑定*，帮助我们避免大量样板代码。

# 指令中的主机绑定

在Angular域中，指令所附加到的组件/元素称为**宿主元素**：**一个承载我们的指令/组件的容器。对于`BusyIndicatorDirective`，`input`元素是*主机*。**

 **虽然我们可以使用`Renderer`操作主机（我们也这么做了），但Angular数据绑定基础设施可以进一步减少代码。它提供了一种声明方式来管理指令主机交互。使用主机绑定概念，我们可以操纵元素的*属性*和*属性*，并订阅其*事件*。

让我们了解每个主机绑定功能，最后，我们将修复我们的`BusyIndicatorDirective`实现。

# 使用@HostBinding 进行属性绑定

使用**主机属性绑定**将*指令属性*绑定到*主机元素属性*。在更改检测阶段，对指令属性的任何更改都将与链接主机属性同步。

我们只需要在要同步的指令属性上使用`@HostBinding`装饰符。例如，考虑这种绑定：

```ts
@HostBinding("readOnly") get busy() {return this.isbusy}; 
```

当应用于`input`时，当`isbusy`指令属性为`true`时，将`input``readOnly`属性设置为`true`。

Note that `readonly` is also an *attribute* on `input`. What we are referring to here is the input *property* `readOnly`.

# 属性绑定

**属性绑定**将指令属性绑定到主机组件属性。例如，考虑一个具有如下约束的指令：

```ts
@HostBinding("attr.disabled") get canEdit(): string  
  { return !this.isAdmin ? "disabled" : null }; 
```

如果应用于输入，当`isAdmin`标志为`false`时，会在`input`上增加`disabled`属性，否则清除。我们也遵循 HTML 模板中使用的相同属性绑定符号。属性名称的前缀为字符串文字`attr`。

我们也可以用*类*和*样式绑定*做类似的事情。考虑下面的一行：

```ts
@HostBinding('class.valid')  
   get valid { return this.control.valid; } 
```

这一行设置类绑定，下面一行创建样式绑定：

```ts
@HostBinding("style.borderWidth")  
   get focus(): string { return this.focus?"3px": "1px"}; 
```

# 事件绑定

最后，**事件绑定**用于订阅主机组件/元素引发的事件。考虑这个例子：

```ts
@Directive({ selector: 'button, div, span, input' }) 
class ClickTracker { 
  @HostListener('click', ['$event.target']) 
  onClick(element: any) { 
    console.log("button", element, "was clicked"); 
  } 
} 
```

这将在主机事件`click`上设置侦听器。Angular 将为视图上的每个*按钮*、*div*、*span*和*输入*实例化前面的指令，并使用`onClick`功能设置主机绑定。`$event`变量包含引发的事件的事件数据，`target`表示单击的元素/组件。

事件绑定也适用于组件。考虑下面的例子：

```ts
@Directive({ selector: 'workout-runner' }) 
class WorkoutTracker { 
  @HostListener('workoutStarted', ['$event']) 
  onWorkoutStarted(workout: any) { 
    console.log("Workout has started!"); 
  } 
} 
```

使用此指令，我们跟踪在`WorkoutRunner`组件上定义的`workoutStarted`事件。训练开始时调用`onWorkoutStarted`函数，其中包含已开始训练的详细信息。

现在我们了解了这些绑定是如何工作的，我们可以改进我们的`BusyIndicatorDirective`实现。

# 带有主机绑定的双总线指示指令的实现

你可能已经猜到了！我们将使用*主机属性绑定*而不是`Renderer`来设置样式。想试试吗？着手清除现有实现并尝试为`borderWidth`和`borderColor`样式属性设置主机绑定，而不查看以下实现。

这是指令处理主机绑定实现的方式：

```ts
import {Directive, HostBinding} from '@angular/core'; 
import {NgModel} from '@angular/forms'; 

@Directive({ selector: `[abeBusyIndicator][ngModel]`}) 
export class BusyIndicatorDirective {
  private get validating(): boolean {
    return this.model.control != null && this.model.control.pending;
  }
  @HostBinding('style.borderWidth') get controlBorderWidth():
        string { return this.validating ? '3px' : null; }
  @HostBinding('style.borderColor') get controlBorderColor():
        string { return this.validating ? 'gray' : null; }

  constructor(private model: NgModel) { }
}

```

我们将`pending`状态检查移到一个名为`validating`的指令属性中，然后使用`controlBorderWidth`和`controlBorderColor`属性进行样式绑定。这肯定比我们以前的方法更简洁！去测试一下。

如果我们告诉您，这可以在不需要自定义指令的情况下完成，请不要惊讶！我们就是这样做的，只需在训练名称`input`上使用样式绑定：

```ts
<input type="text" name="workoutName" ... 
[style.borderColor]="name.control.pending ? 'gray' : null" [style.borderWidth]="name.control.pending ? '3px' : null">
```

我们得到了同样的效果！

不，我们的努力没有白费。我们确实了解了**渲染器**和**主机绑定**。这些概念将在构建提供复杂行为扩展的指令时派上用场，而不仅仅是设置元素样式。

If you are having a problem with running the code, look at the Git branch `checkpoint6.1` for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of `checkpoint6.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-6-1](http://bit.ly/ng6be-checkpoint-6-1). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.

下一个主题是*指令注入*。

# 定向注射

返回几页，看看使用*呈现程序*的`BusyIndicatorDirective`实现，特别是构造函数：

```ts
constructor(private model: NgModel ...) { } 
```

Angular 自动定位为 directive 元素创建的`NgModel`指令，并将其注入`BusyIndicatorDirective`。这是可能的，因为两个指令都在同一个*主机元素*上声明。

好消息是我们可以影响这种行为。也可以注入在父 HTML 树或子树上创建的指令。接下来的几节将讨论如何跨组件树注入指令，这是一个非常方便的功能，它允许对具有*公共沿袭*（在视图中）的指令进行跨指令通信。

我们将使用 StackBlitz（[https://stackblitz.com/edit/angular-pzljm3](https://stackblitz.com/edit/angular-pzljm3) 来演示这些概念。SlackBlitz 是一个在线 IDE，用于运行Angular应用！

首先，查看文件`app.component.ts`。它有三个指令：`Relation`、**、**`Acquaintance`、`Consumer`，定义了该视图层次结构：

```ts
<div relation="grand-parent" acquaintance="jack"> 
    <div relation="parent"> 
 <div relation="me" consumer> 
        <div relation="child-1"> 
          <div relation="grandchild-1"></div> 
        </div> 
        <div relation="child-2"></div> 
      </div> 
    </div> 
</div> 
```

在接下来的几节中，我们将描述将不同的`relation`和`Acquaintance`指令注入`consumer`指令的各种方式。查看浏览器控制台，了解我们在`ngAfterViewInit`生命周期挂钩期间记录的注入依赖项。

# 注入在同一元素上定义的指令

默认情况下，构造函数注入支持注入在同一元素上定义的指令。构造函数只需要声明我们要注入的指令类型变量：

```ts
variable:DirectiveType 
```

我们在`BusyIndicatorDirective`中进行的`NgModel`注射属于这一类。如果在当前元素上找不到该指令，Angular DI 将抛出错误，除非我们将依赖项标记为`@Optional`。

Optional dependency
The `@Optional` decorator is not limited to directive injection. It's there to mark any type of dependency optional.

从 plunk 示例中，第一次注入（在`Consumer`指令实现中）将具有`me`属性（`relation="me"`的`Relation`指令注入消费者指令：

```ts
constructor(private me:Relation ... 
```

# 从父级注入指令依赖项

在构造函数参数前面加上`@Host`装饰符，指示 Angular 搜索对*当前元素*、*其父元素*或其*父元素*的依赖关系，直到它到达组件边界（在其视图层次结构中某处存在具有该指令的组件）。检查第二次`consumer`注射：

```ts
constructor(..., @Host() private myAcquaintance:Acquaintance  
```

此语句将`Acquaintance`指令实例注入层次结构的两个级别。

Like the `@Option` decorator described previously, the usage of `@Host()` is not limited to directives too. Angular service injection also follows the same pattern. If a service is marked with `@Host`, the search stops at the host component. It does not continue further up the component tree.

`@Skipself`装饰符可用于跳过当前元素进行指令搜索。

从 StackBlitz 示例中，此注入将具有`relation`属性值`parent`（`relation="parent"`的`Relation`指令注入`consumer`：

```ts
@SkipSelf() private myParent:Relation 
```

# 注入子指令（或多个指令）

如果需要将嵌套 HTML 上定义的指令注入父指令/组件中，有四个装饰器可以帮助我们：

*   `@ViewChild`/`@ViewChildren`
*   `@ContentChild`/`@ContentChildren`

正如这些命名约定所建议的那样，有一些装饰器可以注入一个或多个子指令：

为了理解`@ViewChild/@ViewChildren`与`@ContentChild/@ContentChildren`的意义，我们需要看看孩子们是什么样的观点和内容，我们很快就会讨论这个话题。但就目前而言，了解视图子项是组件自己视图的一部分，内容子项是注入组件视图的外部 HTML 就足够了。

看看在 StackBlitz 示例中，`ContentChildren`装饰器是如何将子`Relation`指令注入`Consumer`的：

```ts
@ContentChildren(Relation) private children:QueryList<Relation>; 
```

令人惊讶的是，变量`children`的数据类型不是数组，而是一个自定义类—`QueryList`。`QueryList`类不是一个典型的数组，而是一个集合，每当添加或删除依赖项时，该集合都会由 Angular 保持最新。如果在使用结构指令（如`NgIf`或`NgFor`）时创建/销毁 DOM 树，则可能会发生这种情况。在接下来的章节中，我们还将进一步讨论`QueryList`。

您可能已经注意到，前面的注入不像前面的两个示例那样是构造函数注入。这是有原因的。在基础组件/元素的内容初始化之前，注入的指令将不可用。出于这个确切的原因，我们在`ngAfterViewInit`生命周期钩子中有`console.log`语句。我们应该只访问此生命周期挂钩执行后的内容子级。

前面的示例代码将所有三个子`relation`对象注入`consumer`指令。

# 注入后代指令

标准的`@ContentChildren`装饰符（或者实际上也是`@ViewChildren`装饰符）只注入指令/组件的直接子级，而不是其子级。为了包含其所有后代，我们需要为`Query`提供一个参数：

```ts
@ContentChildren(Relation, {descendants: true}) private 
allDescendents:QueryList<Relation>; 
```

传递`descendants: true`参数将指示 Angular 搜索所有子体。

如果查看控制台日志，前面的语句将注入所有四个子体。

Angular DI 看起来使用起来很简单，但它包含了很多功能。它管理我们的服务、组件和指令，并在正确的时间在正确的地点为我们提供正确的东西。组件和其他指令中的指令注入为指令之间的通信提供了一种机制。这种注入允许一个指令访问另一个指令的公共 API（公共函数/属性）。

现在是探索新事物的时候了。我们将构建一个 Ajax 按钮组件，允许我们将外部视图注入该组件，这个过程也称为**内容****转换**。

# 构建 Ajax 按钮组件

当我们保存/更新一个练习或训练时，总是有可能重复提交（或重复`POST`请求）。当前的实现没有提供任何关于保存/更新操作何时开始以及何时完成的反馈。由于缺乏视觉线索，应用的用户可能会有意或无意地多次单击“保存”按钮。

让我们通过创建一个专门的按钮来解决这个问题，*Ajax 按钮*在单击时提供一些视觉线索，并停止重复的 Ajax 提交。

按钮组件将在这些行上工作。它以函数作为输入。此输入函数（输入参数）应返回与远程请求相关的承诺。单击按钮后，按钮会在内部进行远程调用（使用输入功能），跟踪基本承诺，等待其完成，并在此活动期间显示一些繁忙的线索。此外，在远程调用完成之前，该按钮保持禁用状态，以避免重复提交。

The companion code base for the following section is Git branch `checkpoint6.2`. You can work along with us, or check out the implementation available in the branch. Or if you are not using Git, download the snapshot of `checkpoint6.2` (a ZIP file) from the GitHub location [http://bit.ly/ng6be-checkpoint-6-2](http://bit.ly/ng6be-checkpoint-6-2). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.

让我们创建组件大纲，使事情更清楚。使用以下命令在应用的共享模块（`src/app/shared`和**下创建`ajax-button`组件，然后从`SharedModule`导出组件**：

```ts
ng generate component ajax-button -is
```

同时更新组件定义并从`@angular/core`导入：

```ts
export class AjaxButtonComponent implements OnInit { 
  busy: boolean = null; 
  @Input() execute: any; 
  @Input() parameter: any; 
} 
```

并将以下 HTML 模板添加到`ajax-button.component.html`：

```ts
<button [attr.disabled]="busy" class="btn btn-primary"> 
    <span [hidden]="!busy">
        <div class="ion-md-cloud-upload spin"></div>
    </span>
    <span>Save</span> 
</button> 
```

组件（`AjaxButtonComponent`接受两个属性绑定，`execute`和`parameter`。`execute`属性指向在 Ajax 按钮单击时调用的函数。`parameter`是可以传递到此函数的数据。

查看视图中`busy`标志的用法。当`busy`标志设置时，我们禁用按钮并显示微调器。让我们添加使一切正常工作的实现。将此代码添加到`AjaxButtonComponent`类：

```ts
@HostListener('click', ['$event'])
onClick(event: any) {
    const result: any = this.execute(this.parameter);
    if (result instanceof Promise) {
      this.busy = true;
      result.then(
        () => { this.busy = null; },
        (error: any) => { this.busy = null; });
    }
}
```

我们为`AjaxButtonComponent`上的点击事件设置了*主机事件绑定*。只要点击`AjaxButtonComponent`组件，就会调用`onClick`函数。

`HostListener`导入需要添加到`'@angular/core'`模块中。

`onClick`实现使用一个单独的参数`parameter`调用输入函数。调用的结果存储在`result`变量中。

`if`条件检查`result`是否为`Promise`对象。如果是，`busy`指示灯设置为`true`。然后，按钮使用`then`功能等待承诺得到解决。无论承诺是通过*成功*还是*错误*解决，忙标志都设置为`null`。

The reason the busy flag is set to `null` and not `false` is due to this attribute binding `[attr.disabled]="busy"`. The `disabled` attribute will not be removed unless `busy` is `null`. Remember that in HTML, `disabled="false"` does not enable the button. The attribute needs to be removed before the button becomes clickable again.

如果我们对这一行感到困惑：

```ts
    const result: any = this.execute(this.parameter); 
```

然后，您需要了解组件是如何使用的。打开`workout.component.html`并将`Save`按钮 HTML 替换为以下内容：

```ts
<abe-ajax-button [execute]="save" [parameter]="f"></abe-ajax-button> 
```

`Workout.save`函数与`execute`绑定，`parameter`取`FormControl`对象`f`。

我们需要更改`Workout`类中的`save`函数，以返回`AjaxButtonComponent`工作的承诺。将`save`功能实现更改为：

```ts
save = (formWorkout: any): Promise<Object | WorkoutPlan> => {
    this.submitted = true;
    if (!formWorkout.valid) { return; }
    const savePromise = this.workoutBuilderService.save().toPromise();

    savePromise.then(
      result => this.router.navigate(['/builder/workouts']),
      err => console.error(err)
    );
    return savePromise;
  } 
```

`save`函数现在返回一个*承诺*，我们通过调用`workoutBuilderService.save()`返回的*可观测*上的`toPromise`函数来构建该承诺。

Make note of how we define the `save` function as an *instance function* (with the use of the arrow operator) to create a closure over *this*. It's something we did earlier while building the *remote validator directive*.

是时候测试我们的实现了！刷新应用并打开“创建/编辑训练”视图。单击 Save 按钮并查看 Ajax 按钮的作用：

![](img/998a8485-f94b-4114-ba5b-9830963b9fb3.png)

The preceding animation may be short-lived as we navigate back to the workout list page post save. We can temporarily disable the navigation to see the new changes.

我们开始本节的目的是强调如何将外部元素/组件转移到组件中。让我们现在就做！

# 将外部组件/元素转移到组件中

从一开始，我们就需要理解**转换**的含义。理解这个概念的最好方法是看一个例子。

到目前为止，我们构建的任何组件都没有从外部借用内容。不知道这意味着什么？

请考虑前面提到的例子：

```ts
<ajax-button [execute]="save" [parameter]="f"></ajax-button> 
```

如果我们将`ajax-button`的用法更改为以下内容会怎么样？

```ts
<ajax-button [execute]="save" [parameter]="f">Save Me!</ajax-button> 
```

按钮上会显示`Save Me!`文本吗？它不会尝试的！

`AjaxButtonComponent`组件已经有了一个模板，它拒绝了我们在前面声明中提供的内容。如果我们能够以某种方式将内容（上例中的`Save Me!`加载到`AjaxButtonComponent`中，会怎么样？这种将外部视图片段注入组件视图的行为就是我们所说的**转换**，框架提供了必要的构造来实现转换。

现在是引入两个新概念的时候了，*内容儿童*和*查看儿童*。

# 内容子项和视图子项

为了简洁地定义它，组件内部定义的 HTML 结构（使用`template or templateUrl`）是组件的**视图子项**。但是，作为添加到宿主元素的组件用法的一部分提供的 HTML 视图（例如`<ajax-button>**Save Me!**</ajax-button>`定义了组件的**内容子项**。

默认情况下，Angular 不允许像我们之前看到的那样嵌入*内容子项*。`Save Me!`文本从未发出。我们需要明确告诉 Angular 在*组件视图模板*中的*内容子项*的发射位置。为了理解这个概念，让我们修正一下`AjaxButtonComponent`视图。打开`ajax-button.component.ts`并将视图模板定义更新为以下内容：

```ts
<button [attr.disabled]="busy" class="btn btn-primary"> 
    <span [hidden]="!busy"> 
        <ng-content select="[data-animator]"></ng-content> 
   </span> 
 <ng-content select="[data-content]"></ng-content> 
</button>
```

前面视图中的两个`ng-content`元素定义了*内容注入位置*，在这里可以注入/屏蔽内容子项。`selector`属性定义了*CSS 选择器*，当注入主主机时，该选择器应用于定位内容子级。

一旦我们在`workout.component.html`中修正`AjaxButtonComponent`的用法，它就开始变得更有意义。将其更改为以下内容：

```ts
<ajax-button [execute]="save" [parameter]="f">
    <div class="ion-md-cloud-upload spin" data-animator></div>
 <span data-content>Save</span>
</ajax-button> 
```

带`data-animator`的`span`被注入带`select=[data-animator]`属性的`ng-content`中，另一个`span`（带`data-content`属性）被注入第二个`ng-content`声明中。

再次刷新应用并尝试保存训练。虽然最终结果相同，但结果视图是多个视图片段的组合：一部分用于组件定义（*视图子项*），另一部分用于组件使用（*内容子项*）。

下图突出显示了呈现的`AjaxButtonComponent`的这种差异：

![](img/f1721b2e-ffe9-4e35-a57c-fca2c3bf62cb.png)

The `ng-content` can be declared without the `selector` attribute. In such a scenario, the complete content defined inside the component tag is injected.

*内容注入*到现有组件视图中是一个非常强大的概念。它允许组件开发人员提供扩展点，组件使用者可以方便地使用这些扩展点，并以受控的方式自定义组件的行为。

我们为`AjaxButtonComponent`定义的内容注入允许消费者更改繁忙指示器动画和按钮内容，保持按钮的行为完好无损。

Angular 的优势还不止于此。能够将*内容子项*和*视图子项*注入*组件代码/实现*中。这允许组件与其内容/视图子级交互，并控制其行为。

# 使用@ViewChild 和@ViewChildren 注入视图子对象

让我们看看`WorkoutAudioComponent`实现的相关部分。视图定义如下所示：

```ts
<audio #ticks="MyAudio" loop srcimg/audio/tick10s.mp3"></audio>
<audio #nextUp="MyAudio" srcimg/audio/nextup.mp3"></audio>
<audio #nextUpExercise="MyAudio" [src]=img/audio/' + nextupSound"></audio>
// Some other audio elements 
```

注射过程如下：

```ts
@ViewChild('ticks') private _ticks: MyAudioDirective; 
@ViewChild('nextUp') private _nextUp: MyAudioDirective; 
@ViewChild('nextUpExercise') private _nextUpExercise: MyAudioDirective; 
```

与`audio`标记相关联的指令（`MyAudioDirective`已使用`@ViewChild`修饰符注入`WorkoutAudio`实现。传递给`@ViewChild`的参数是用于在视图定义中定位元素的*模板变量*名称（例如`tick`。然后，`WorkoutAudio`组件使用这些音频指令控制*7 分钟训练*的音频播放。

当前面的实现注入`MyAudioDirective`时，甚至可以注入子组件。例如，假设我们构建一个`MyAudioComponent`，而不是使用`MyAudioDirective`，类似于以下内容：

```ts
@Component({ 
  selector: 'my-audio', 
  template: '<audio ...></audio>', 
}) 
export class MyAudioComponent { 
  ... 
} 
```

然后我们可以使用它来代替`audio`标签：

```ts
<my-audio #ticks loop  
  src="/static/audio/tick10s.mp3"></my-audio> 
```

注射仍然有效。

如果在组件视图上定义了多个相同类型的指令/组件，会发生什么情况？使用`@ViewChildren`装饰器。它允许您查询一种类型的注入。`@ViewChildren`的使用语法如下：

```ts
@ViewChildren(directiveType) children: QueryList<directiveType>; 
```

这将注入类型为`directiveType`的所有视图子级。对于前面提到的`WorkoutAudio`组件示例，我们可以使用以下语句获取所有`MyAudioDirective`：

```ts
@ViewChildren(MyAudioDirectives) private all: QueryList<MyAudioDirectives>; 
```

`ViewChildren`修饰符也可以使用逗号分隔的选择器列表（*模板变量名*），而不是类型。例如，要在`WorkoutAudio`组件中选择多个`MyAudioDirective `实例，我们可以使用以下方法：

```ts
 @ViewChildren('ticks, nextUp, nextUpExercise, halfway, aboutToComplete') private all: QueryList<MyAudioDirective>; 
```

`QueryList`类是 Angular 提供的特殊类。我们在本章前面的*注入后代指令*一节中介绍了`QueryList`。让我们进一步探索`QueryList`。

# 使用 QueryList 跟踪注入的依赖项

对于需要注入多个组件/指令的组件（使用`@ViewChildren`或`@ContentChildren`，注入的依赖项是`QueryList`对象。

`QueryList`类是注入组件/指令的*只读**集合*。Angular 根据用户界面的当前状态保持此集合的同步。

考虑一下，例如，To.T0.指令视图。它有五个`MyAudioDirective`实例。因此，对于以下集合，我们将有五个元素：

```ts
@ViewChildren(MyAudioDirective) private all: QueryList<MyAudioDirective>; 
```

虽然前面的示例没有突出显示同步部件，但 Angular 可以跟踪视图中添加或删除的组件/指令。当我们使用`ngFor`等内容生成指令时，就会发生这种情况。

以这个假设的模板为例：

```ts
<div *ngFor="let audioData of allAudios"> 
  <audio [src]="audioData.url"></audio> 
</div> 
```

此处注入的`MyAudioDirective`指令数等于`allAudios`数组的大小。在程序执行过程中，如果元素被添加到`allAudios`数组或从中移除，则框架也会保持指令集合的同步。

虽然`QueryList`类不是数组，但可以使用`for (var item in queryListObject)`语法对其进行迭代（因为它实现了**ES6 iterable 接口**。它还具有一些其他有用的属性，例如`length`、`first`和`last`，这些属性可以派上用场。查看框架文档（[http://bit.ly/ng2-querylist-class](http://bit.ly/ng2-querylist-class) 了解更多详情。

从前面的讨论中，我们可以得出结论，`QueryList`为组件开发人员节省了大量样板代码，如果必须手动进行跟踪，则需要这些样板代码。

View children access timing
View children injections are not available when the component/directive initializes. Angular makes sure that the view children injections are available to the component no later than the `ngAfterViewInit` life cycle event. Make sure you access the injected components/directives only when (or after) the `ngAfterViewInit` event has fired.

现在让我们看一下内容儿童注入，除了一些细微的差异外，它几乎是相似的。

# 使用@ContentChild 和@ContentChildren 注入内容子级

Angular 允许我们也注入*内容子项*，使用一组并行属性：`@ContentChild`注入特定内容子项，`@ContentChildren`注入特定类型的内容子项。

如果我们回顾一下`AjaxButtonComponent`的用法，可以通过以下方式将其内容子级注入`AjaxButtonComponent`实现：

```ts
@ContentChild('spinner') spinner:ElementRef; 
@ContentChild('text') text:ElementRef; 
```

并将模板变量添加到`workout.component.html`中相应的跨度上：

```ts
<div class="ion-md-cloud-upload spin" data-animator #spinner></div>
<span data-content #text>Save</span>
```

虽然前面的注射是`ElementRef`，但它也可能是一种成分。我们是否为微调器定义了一个组件，例如：

```ts
<ajax-button> 
    <busy-spinner></busy-spinner> 
    ... 
</ajax-button> 
```

我们也可以使用以下方法注入它：

```ts
@ContentChild(BusySpinner) spinner: BusySpinner; 
```

指令也是如此。在`AjaxButtonComponent`上声明的任何指令都可以注入`AjaxButtonComponent`实现。对于前面的例子，由于转置的元素是标准的 HTML 元素，我们注入了`ElementRef`，一个为任何 HTML 元素创建的包装器。

Like *view children*, Angular makes sure that the content children references are bound to the variables injected before the `ngAfterContentInit` life cycle event.

当我们讨论注入依赖项的主题时，让我们来谈谈关于将服务注入*组件*的一些变化。

# 使用 viewProvider 的依赖项注入

我们已经熟悉 Angular 中的 DI 注册机制，通过将依赖项添加到任何模块声明中，在全局级别注册依赖项。

或者我们可以使用`@Component`装饰器上的`providers`属性在组件级别执行此操作：

```ts
providers:[WorkoutHistoryTracker, LocalStorage] 
```

Just to avoid confusion, we are now talking about injecting dependencies other than directive/component objects. Directives/components are registered in the `declarations` array of a module before they can be injected using decorator hints such as `@Query`, `@ViewChild`, `@ViewChildren`, and a few others.

在组件级别注册的依赖项可用于其*视图子项*和*内容子项*及其后代。

Before we proceed, we hope that the distinction between *view* and *content **children* is crystal clear to everyone. If in doubt, refer to the *Content children and view children* section again.

我们以[第二章](02.html)中的*私人教练*为例。`WorkoutBuilderService`服务已在训练生成器模块（`WorkoutBuilderModule`中的应用级别注册：

```ts
providers: [ExerciseBuilderService, ...  
 WorkoutBuilderService]);
```

这使我们能够在应用中注入`WorkoutBuilderService`，以建立训练，并在运行训练时进行训练。相反，我们可以在`WorkoutBuilderComponent`级别注册该服务，因为它是所有训练/运动创建组件的父级，类似于以下内容：

```ts
@Component({ 
    template: `...` 
 providers:[ WorkoutBuilderService ] 
}) 
export class WorkoutBuilderComponent { 
```

此更改将禁止在`WorkoutRunner`或任何与训练执行相关的组件中注入`WorkoutBuilderService`。

What if the `WorkoutBuilderService` service is registered at the app level as well as at the component level (as shown in the preceding example)? How does the injection happen? From our experience, we know that Angular will inject a different instance of the `WorkoutBuilderService` service into `WorkoutBuilderComponent` (and its descendants), while other parts of the application (*Workout runner*) will get the global dependency. Remember **hierarchical injectors**!

Angular并不止于此。它使用`viewProviders`属性提供了一些进一步的依赖范围。`@Component`装饰器上提供的`viewProviders`属性允许注册只能在视图子级中注入的依赖项。

让我们再来考虑一下这个例子，以及一个简单的指令实现，称为 OntT1，详细说明我们的讨论：

```ts
@Directive({ 
  selector: '[myDirective]', 
}) 
export class MyDirective { 
  constructor(service:MyService) { } 
  ... 
} 
```

`MyDirective`类依赖于一个服务`MyService`。

要将此指令应用于`AjaxButtonComponent`模板中的*按钮元素*，我们还需要注册`MyService`依赖项（假设`MyService`尚未全局注册）：

```ts
@Component({ 
  selector: 'ajax-button', 
  template:` <button [attr.disabled]="busy" ... 
 myDirective> 
                ... 
             <button>` 
 providers:[MyService], 
... 
```

由于`MyService`是在`AjaxButtonComponent`注册的，`MyDirective`也可以添加到其内容子项中。因此，在*微调器 HTML*上的`myDirective`应用也将工作（在`workout.component.html`中的代码）：

```ts
<div class="ion-md-cloud-upload spin" data-animator myDirective></div>
```

但将`providers`属性更改为`viewProviders`：

```ts
viewProviders:[MyService]
```

将使`AjaxButtonComponent`的内容子项（前面代码中的`div`的`MyService`注入失败，控制台中出现 DI 错误。

Dependencies registered with `viewProviders` are invisible to its content children.

这种对*视图*和*内容子项*的依赖性范围界定乍一看似乎并不有用，但确实有其好处。假设我们正在构建一个可重用的组件，我们希望将其打包并交付给开发人员使用。如果组件也具有预打包的服务依赖性，我们需要格外小心。如果这样一个组件允许*内容注入*（内容子项），那么如果在该组件上使用基于*提供者的*注册，则依赖服务将被广泛公开。任何内容子级都可以获得服务依赖并使用它，从而导致不良后果。通过使用`viewProvider`注册依赖关系，只有组件实现及其子视图可以访问依赖关系，从而提供必要的封装层。

再一次，我们对 DI 框架提供的灵活性和定制水平感到惊讶。虽然这对初学者来说可能很吓人，但一旦我们开始使用 Angular 构建越来越多的组件/指令，我们总会发现这些概念使我们的实现更简单的领域。

让我们把注意力转移到指令的第三类：*结构指令*。

# 理解结构指令

虽然我们经常使用结构指令，如`NgIf`和`NgFor`，但很少需要创建结构指令。仔细想想。如果我们需要一个新视图，我们将创建一个*组件*。如果我们需要扩展现有元件/组件，我们将使用*指令*。而结构指令最常见的用途是克隆视图的一部分（也称为*模板视图*，然后根据某些条件：

*   注入/销毁这些模板（`NgIf`和`NgSwitch`）
*   或复制这些模板（`NgFor`

使用结构指令实现的任何行为都会无意中落入这两类中的任何一类。

鉴于这一事实，与其构建我们自己的结构化指令，不如让我们看看`NgIf`实现的源代码。

以下是我们感兴趣的`NgIf`指令摘录。我们故意忽略了摘录中的`ngIfElse`部分：

```ts
@Directive({selector: '[ngIf]'})
export class NgIf {
 constructor(private _viewContainer: ViewContainerRef, templateRef: TemplateRef<NgIfContext>) {
    this._thenTemplateRef = templateRef;
 }

 @Input()
  set ngIf(condition: any) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
 }
 private _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef =
              this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    }
    ...
}
```

这里没有魔法，只是一个简单的结构指令，用于检查布尔条件（`this._context.$implicit`）以创建/销毁视图！

上面的第一个 if 条件检查，如果条件`this._context.$implicit`是`true.`，那么下一个条件通过检查变量`_thenViewRef`来确保视图已经没有渲染。只有当`this._context.$implicit`从`false`转换为`true`时，我们才想翻转视图。如果两个 If 条件均为真，则清除现有视图（`this._viewContainer.clear()`，并清除对 else 视图的引用。最内层的 if 条件确保 if 的模板引用可用。最后，代码调用`_viewContainer.createEmbeddedView`来渲染（或重新渲染）视图。

不难理解该指令是如何工作的。需要详细说明的是两种新的注射剂，`ViewContainerRef (_viewContainer)`和`TemplateRef (_templateRef)`。

# 模板引用

`TemplateRef`类（`_templateRef`存储对 structural 指令所引用的模板的引用。还记得[第 1 章](01.html)*中关于结构指令的讨论吗？*构建了我们的第一个 App-7 分钟训练*？所有结构指令都采用它们处理的 HTML 模板。当我们使用`NgIf`等指令时：*

```ts
<h3 *ngIf="currentExercise.exercise.name=='rest'"> 
  ... 
</h3> 
```

Angular 将此声明转换为以下内容：

```ts
<ng-template [ngIf]="currentExercise.exercise.name=='rest'"> 
  <h3> ... </h3> 
</ng-template> 
```

这是结构化指令使用的模板，`_templateRef`指向该模板。

另一个注射为`ViewContainerRef`。

# ViewContainerRef

`ViewContainerRef`类指向呈现模板的容器。这个类有许多方便的方法来管理视图。`NgIf`实现使用的两个函数`createEmbeddedView`和`clear`用于添加和删除模板 HTML。

`createEmbeddedView`函数获取模板引用（再次注入指令）并呈现视图。

`clear`函数将销毁已注入的元素/组件，并清除视图容器。由于模板（`TemplateRef`中引用的每个组件及其子组件都被销毁，因此所有关联的绑定也不再存在。

结构指令有一个非常具体的应用领域。尽管如此，我们仍然可以使用`TemplateRef`和`ViewContainerRef`类完成许多漂亮的技巧。

我们可以实现一个结构指令，根据用户角色显示/隐藏视图模板。

考虑一个假设的结构指令的例子，

```ts
<button *forRoles="admin">Admin Save</button> 
```

如果用户不属于*管理员*角色，`forRoles`指令将不会呈现该按钮。核心逻辑如下所示：

```ts
if(this.loggedInUser.roles.indexOf(this.forRole) >=0){ 
      this.viewContainer.createEmbeddedView(this.templateRef); 
} 
else { 
      this.viewContainer.clear(); 
}  
```

指令实现将需要某种返回登录用户详细信息的服务。我们将把该指令的实现留给读者。

`forRoles`指令的作用也可以通过使用`NgIf`来实现：

```ts
<button *ngIf="loggedInUser.roles.indexOf('admin')>=0">Admin Save</button> 
```

但是`forRoles`指令只是为了增加模板的可读性，目的明确。

结构指令的有趣应用可能涉及创建一个指令，该指令只复制传递给它的模板。这将是相当容易建立一个；我们只需要给`createEmbeddedView`打两次电话：

```ts
ngOnInit() {       
 this.viewContainer.createEmbeddedView(this._templateRef);        
 this.viewContainer.createEmbeddedView(this._templateRef); 
}  
```

又一个有趣的运动！

`ViewContainerRef`类还有一些其他功能，允许我们注入*组件*，获取嵌入视图的数量，重新排序视图，等等。查看`ViewContainerRef`（[的框架文档 http://bit.ly/view-container-ref](http://bit.ly/view-container-ref) 了解更多详情。

这就完成了我们关于结构指令的讨论，是时候开始一些新的东西了！

到目前为止，我们构建的组件从通用的*引导样式表*和`app.css`中定义的一些自定义样式派生出它们的样式（CSS）。Angular 在这方面有更多的优势。真正可重用的组件在行为和用户界面方面都应该是完全自包含的。

# 组件样式和视图封装

web 应用开发的一个长期问题是在 DOM 元素行为和样式方面缺乏封装。我们不能通过任何机制将应用 HTML 的一部分与另一部分隔离开来。

事实上，我们拥有太多的权力。有了 jQuery 这样的库和强大的*CSS 选择器*，我们可以掌握任何 DOM 元素并改变其行为。我们的代码和任何外部库代码在其可以访问的内容方面没有区别。每一段代码都可以操作渲染 DOM 的任何部分。因此，封装层被破坏。写得不好的库可能会导致一些难以调试的棘手问题。

CSS 样式也是如此。如果库实现希望覆盖全局样式，则任何 UI 库实现都可以覆盖全局样式。

这些是任何库开发人员在构建可重用库时所面临的真正挑战。一些新兴的 web 标准试图通过提出诸如**web 组件**之类的概念来解决这个问题。

简单来说，**Web 组件**是可重用的用户界面小部件，封装了它们的*状态*、*样式*、*用户界面*和*行为*。功能通过定义良好的 API 公开，用户界面部分也被封装。

*web 组件*概念由四个标准实现：

*   HTML 模板
*   阴影 DOM
*   自定义元素
*   HTML 导入

在本次讨论中，我们感兴趣的技术标准是**阴影 DOM。**

# 阴影 DOM 概述

**Shadow DOM**就像一个托管在组件中的并行 DOM 树（*一个 HTML 元素，**不要与Angular组件*混淆），隐藏在主 DOM 树之外。除了组件本身之外，应用的任何部分都无权访问此影子 DOM。

它是允许视图、样式和行为封装的 shadowdom 标准的实现。理解影子 DOM 的最好方法是查看 HTML5`video`和`audio`标记。

你有没有想过这个`audio`声明：

```ts
<audio src="/static/audio/nextup.mp3" controls></audio> 
```

生成以下内容？

![](img/1db22226-a91d-457a-82bc-44c19d34ac5f.png)

它是生成底层阴影 DOM 以渲染音频播放器的浏览器。令人惊讶的是，我们甚至可以查看生成的 DOM！以下是我们的做法：

*   以前面的 HTML 为例，创建一个虚拟 HTML 页面，并在 Chrome 中打开它。
*   然后打开开发者工具窗口（*F12*。单击左上角的设置图标。
*   在“常规设置”中，单击复选框（如以下屏幕截图中突出显示的），以启用对阴影 DOM 的检查：

![](img/a95f3b1d-c9b0-476f-8a25-65a2d9e37851.png)

刷新页面，如果我们现在检查生成的`audio`HTML，影子 DOM 将显示：

![](img/d2af88cb-b2c8-4b3a-9987-cedfb585e570.png)

在`shadow-root`下，页面和脚本的其他部分无法访问一个全新的世界。

In the Shadow DOM realm, **shadow-root** (`#shadow-root` in the preceding code) is the root node for the generated DOM, hosted inside a **shadow host** (in this case the `audio` tag). When the browser renders this element/component, what gets rendered is the content from the *shadow root* and not the *shadow host*.

从这个讨论中，我们可以得出结论，影子 DOM 是由浏览器创建的一个并行 DOM，它封装了 HTML 元素的*标记*、*样式*和*行为*（DOM 操纵）。

This was a gentle introduction to Shadow DOM. To learn more about how Shadow DOM works, we recommend this series by Rob Dodson: [http://bit.ly/shadow-dom-intro](http://bit.ly/shadow-dom-intro)

但这一切和我有什么关系？事实证明，Angular组件也支持某种视图封装！这也允许我们隔离Angular组件的样式。

# 阴影 DOM 和Angular组件

要了解 Angular 如何使用阴影 DOM 的概念，我们首先必须了解如何设置Angular组件的样式。

在设计作为本书一部分构建的应用时，我们采取了保守的方法。无论是*训练生成器*还是*训练跑步者**7 分钟训练*应用，我们构建的所有组件都源自*引导 CSS*和`app.css`中定义的自定义样式。没有组件定义了自己的样式。

虽然这符合 web 应用开发的标准实践，但有时我们确实需要偏离。当我们构建自包含、打包和可重用的组件时，尤其如此。

Angular 允许我们使用`@Component`装饰器上的`style`（用于内联样式）和`styleUrl`（外部样式表）属性来定义特定于组件的样式。让我们来玩玩`style`属性，看看 Angular 做了什么。

我们将使用`AjaxButtonComponent`实现作为下一个练习的操场。但在此之前，让我们先看一下`AjaxButtonComponent`HTML 的现状。`AjaxButtonComponent`的 HTML 树如下所示：

![](img/4bf43910-2297-4538-836e-3652883be3d0.png)

让我们使用`styles`属性覆盖一些样式：

```ts
@Component({ 
  ... 
  styles:[` 
    button { 
      background: green; 
    }`] 
}) 
```

前面的*CSS 选择器*将所有 HTML 按钮的`background`属性设置为`green`。保存前面的样式并刷新 work builder 页面。按钮样式已更新。这里没有惊喜吗？不是真的，有一些！查看生成的 HTML：

![](img/c7ed693e-b585-41c5-ac7a-06653cb7e447.png)

在许多 HTML 元素中添加了一些新属性。最近定义的样式在哪里？在最顶部，`head`标签内：

![](img/536978ea-de4e-4426-9ae0-8cc238f36954.png)

`head`部分中定义的样式在`_ngcontent-c1`属性中有一个额外的作用域（属性名称在您的情况下可能不同）。该范围允许我们独立设置`AjaxButtonComponent`样式，并且不能覆盖任何全局样式。

Angular does the same even if we use the `styleUrls` property. Suppose we had embedded the same CSS in an external CSS file and used this: `styleUrls:['static/css/ajax-button.css']` Angular would have still in-lined the styles into the `head` section, by fetching the CSS, parsing it, and then injecting it.

根据定义，应该影响应用中所有按钮外观的样式没有效果。Angular 已经确定了这些样式的范围。

This scoping makes sure that the component styles do not mess with the already defined style, but the reverse is not true. Global styles will still affect the component unless overridden in the component itself.

这种范围样式是 Angular 尝试模拟 ShadowDOM 范例的结果。组件上定义的样式永远不会泄漏到全局样式中。不费吹灰之力就完成了这一切！

If you are building components that define their own styles and want a degree of isolation, use the component's `style`/`styleUrl` property instead of using the old-school approach of having a common CSS file for all styles.

我们可以通过使用名为**封装**的`@Component`装饰器属性来进一步控制这种行为。该属性的 API 文档提到：

**封装：**`ViewEncapsulation`指定如何封装模板和样式。如果视图有样式，则默认为`ViewEncapsulation.Emulated`，否则为`ViewEncapsulation.None`。

我们可以看到，只要我们在组件上设置样式，封装效果就是`Emulated`。否则为`None`。

If we explicitly set `encapsulation` to `ViewEncapsulation.None`, the scoping attributes are removed and the styles are embedded in the head section as normal styles.

还有第三个选项，`ViewEncapsulation.Native`，其中 Angular 实际上为 components 视图创建了阴影 DOM。将`AjaxButtonComponent`实现上的`encapsulation`属性设置为`ViewEncapsulation.Native`，现在查看呈现的 DOM：

![](img/2a817126-9d31-49b5-982f-d80bac011607.png)

`AjaxButtonComponent`现在有一个阴影 DOM！这也意味着按钮的完整样式丢失（样式源自引导 CSS），按钮现在需要定义自己的样式。

Angular 竭尽全力确保我们开发的组件能够独立工作并可重用。每个组件都有自己的模板和行为。除此之外，我们还可以封装组件样式，从而创建健壮的独立组件。

这就把我们带到了这一章的结尾，是时候用我们所学到的东西来结束这一章了。

# 总结

在本章结束时，我们现在对指令如何工作以及如何有效地使用它们有了更好的理解。

我们从构建一个`RemoteValidatorDirective`开始这一章，并了解了 Angular 对*异步验证*的支持。

接下来是`BusyIndicatorDirective`，这也是一个很好的学习场所。我们探索了**渲染器**服务，它允许以平台无关的方式操作组件视图。我们还了解了**主机绑定**，它允许我们绑定到主机元素的*事件*、*属性*和*属性*。

Angular 允许跨视图沿袭声明的指令注入沿袭。我们专门用了几个章节来理解这种行为。

我们创建的第三个指令（组件）是`AjaxButtonComponent`。它帮助我们理解组件的*内容子项*和*视图子项*之间的关键区别。

我们还讨论了结构指令，其中我们探讨了`NgIf`平台指令。

最后，我们研究了 Angular 在视图封装方面的功能。我们探讨了 shadowdom 的基础知识，并了解了该框架如何使用 shadowdom 范式来提供视图加样式的封装。

从教育的Angular来看，所有这些都很有趣。它没有描述房间里的大象，当事情变得复杂时，我们如何管理数据？我们必须处理的问题是：

*   双向数据流
*   缺乏可预测性（更改可能导致级联更改）
*   分散状态（没有唯一的真相来源，我们的组件可以位于部分更新的状态）

让我们在进入[第 5 章](05.html)时牢记这些担忧，*1.21 千兆瓦-Flux模式解释*。**