

# 主题化概念和布局



本章的主要目的是介绍打底主题、布局和相关概念。Priming 中使用的**主题化**概念类似于 jQuery ThemeRoller CSS 框架（[http://jqueryui.com/themeroller](http://jqueryui.com/themeroller) ）。Priming 组件的设计允许开发人员将其无缝集成到整个 web 应用程序的外观中。在撰写本文时，共有 17 个免费主题和 5 个高级主题和布局。免费主题包括 ThemeRoller 主题、Twitter 引导主题以及一些由 PrimeFaces 和 PrimeNG 支持的自定义主题。这些主题在 Apache 许可证下与 PrimeNG 一起分发。

在[第 1 章](01.html)*中，我们展示了三种可能的设置和主题安装。您还可以在 Priming showcase（[中使用免费主题 https://www.primefaces.org/primeng](https://www.primefaces.org/primeng) ）通过动态切换——在右上角有一个主题切换器。高级主题可以作为独立主题购买。您可以在 PrimeNG 主题库（[中预览高级主题和布局 http://primefaces.org/themes [T7]。](http://primefaces.org/themes)*

Elite or pro users can use some premium themes (currently Omega) without extra costs. More information about license models can be found on the license page ([https://www.primefaces.org/licenses](https://www.primefaces.org/licenses)).

在本章中，我们将介绍以下主题：

*   了解结构和蒙皮 CSS
*   用 SASS 组织项目结构
*   创建新主题的简单方法
*   Priming 中的响应网格系统
*   Bootstrap 的响应性布局符合 Priming



# 了解结构和蒙皮 CSS



每个组件都使用 CSS 设置样式，并包含两层样式信息：结构或特定于组件的样式和蒙皮或独立于组件的样式。在本节中，您将了解这两种 CSS 之间的区别，学习一些有用的选择器，并在生成的 HTML 中看到分页器组件的示例样式。让我们开始吧。进入 Paginator 展示（[https://www.primefaces.org/primeng/#/paginator](https://www.primefaces.org/primeng/#/paginator) ）并探索 Paginator 组件的 HTML 代码。下一个屏幕截图显示了 Google Chrome 开发工具中的 HTML 和样式。

Shortcuts for opening DevTools: *F12* (Windows), *command* + *option* + *I* (Mac).

![](img/61574c6b-b56b-4c92-af5a-6bb6c7071528.png)

前面屏幕截图中高亮显示的行表示具有以下样式类的 Paginator 组件的容器元素：

*   `ui-paginator`
*   `ui-unselectable-text`
*   `ui-widget`
*   `ui-widget-header`

前两个样式类`ui-paginator`和`ui-unselectable-text`是通过预处理生成的。这些是结构样式类。第一种方法提供语义表示，以指示元素的角色。此类样式类的其他示例有`ui-datatable`用于表格和`ui-button`用于按钮。

第二种方法适用于希望避免意外复制粘贴无用内容（如图标或图像）的情况。通常，结构样式类定义组件的骨架，并包括 CSS 属性，如边距、填充、显示类型、溢出行为、尺寸和定位。

Almost every component documentation in the PrimeNG showcase contains a Styling section with the component's structural style classes.

如前所述，PrimeNG 利用了 jQuery ThemeRoller CSS 框架。前面提到的`ui-widget`和`ui-widget-header`类是由 ThemeRoller 定义的，它们影响底层 HTML 元素和相关组件的外观。这些是蒙皮样式类，它们定义 CSS 属性，例如文本颜色、边框颜色和背景图像。

| **选择器** | **适用** |
| `.ui-widget` | 这是应用于所有涂底漆组件的类。例如，它适用于字体系列和字体大小。 |
| `.ui-widget-header` | 这是应用于组件标题部分的类。 |
| `.ui-widget-content` | 这是应用于组件的内容部分的类。 |
| `.ui-state-default` | 这是应用于可单击的按钮式组件或其元素的默认类。 |
| `.ui-state-hover` | 这是应用于`mouseover`事件的类，用于可单击的按钮式组件或其元素。 |
| `.ui-state-active` | 这是应用于`mousedown`事件的类，用于可单击的按钮式组件或其元素。 |
| `.ui-state-disabled` | 这是当组件或其元素被禁用时应用于它们的类。 |
| `.ui-state-highlight` | 这是高亮显示或选择零部件或其图元时应用于这些零部件或图元的类。 |
| `.ui-corner-all` | 该类将角半径应用于零部件的所有四个角。 |
| `.ui-corner-top` | 该类将角半径应用于零部件的两个顶角。 |
| `.ui-corner-bottom` | 该类将角半径应用于零部件的两个底角。 |
| `.fa` | 这是应用于表示图标的元素的类。 |

这些样式在所有打底组件中都是一致的，因此可点击按钮和手风琴选项卡应用了相同的`ui-state-default`类，以表明它们是可点击的。当用户将鼠标移动到其中一个元素上时，该类将更改为`ui-state-hover`，然后在选择这些元素时更改为`ui-state-active`。

这种方法很容易确保具有相似交互状态的所有元素在所有组件中看起来都是相同的。所提供的 Priming 选择器的主要优点是在主题设置方面具有很大的灵活性，因为您不需要了解每个蒙皮选择器就可以一致地更改 web 应用程序中所有可用组件的样式。

In rare cases, some style classes are not generated by PrimeNG explicitly and not defined by the ThemeRoller. The Schedule component ([https://www.primefaces.org/primeng/#/schedule](https://www.primefaces.org/primeng/#/schedule)) is one of such cases. It has structural classes `fc-head`, `fc-toolbar`, `fc-view-container`, and so on, which are controlled by the third-party plugin `FullCalendar` ([https://fullcalendar.io](https://fullcalendar.io)).

自由主题使用相对的`em`单元来定义具有`.ui-widget`类的小部件的字体大小。默认为`1em`。例如，Omega 主题定义了以下内容：

```ts
.ui-widget {
  font-family: "Roboto", "Trebuchet MS", Arial, Helvetica, sans-serif;
  font-size: 1em;
}

```

由于`em`单元，字体大小易于定制。建议在`body`元素上应用基本字体大小，以调整整个 web 应用程序中组件的大小：

```ts
body {
  font-size: 0.9em;
}

```



# 用 Sass 组织项目结构



每个大型前端应用程序都需要一个健壮、可扩展的 CSS 体系结构。CSS 预处理器是必不可少的——它有助于用可重用的片段编写更干净、模块化的代码，并维护大型复杂的样式表。CSS 预处理器基本上是一种脚本语言，它扩展 CSS 并将其编译成常规 CSS。现在有三个主要的 CSS 预处理器：Sass、LESS 和手写笔。根据谷歌趋势，Sass 是目前使用最多的预处理器。Sass 模仿 HTML 结构，并允许您嵌套遵循相同视觉 HTML 层次结构的 CSS 选择器。使用 CSS，您需要编写以下内容：

```ts
.container {
  padding: 5px;
}

.container p {
  margin: 5px;
}

```

使用 Sass，您可以简单地编写以下内容：

```ts
.container {
  padding: 5px;
  p {
    margin: 5px;
  }
}

```

Sass is backward compatible with CSS, so you can easily convert your existing CSS files just by renaming the `.css` file extension to `.scss`.

嵌套 CSS 选择器时，您可以使用方便的[T0]符号。`&`符号连接 CSS 规则。例如，考虑下面的 SASS 片段：

```ts
.some-class {
  &.another-class {
    color: red;
  }
}

```

这将被编译为以下内容：

```ts
.some-class.another-class {
  color: red;
}

```

当每个组件只使用前缀为唯一名称空间的类名时，`&`符号对于沙盒 UI 组件也很有用。例如，以下虚构的头模块使用[T1]名称空间沙盒：

```ts
.mod-header {
  &-link {
    color: blue;
  }

  &-menu {
    border: 1px solid gray;
  }
}

```

输出结果分为两类：`.mod-header-link`和`.mod-header-menu`。如您所见，Sass 有助于避免 CSS 冲突。建议为每个 UI 组件编写单独的 Sass 文件，然后通过`@import`指令将它们组合在一起。使用此指令，可以将一个 Sass 文件导入另一个 Sass 文件。预处理器将获取要导入的文件，并将其与要导入的文件合并。这与本机 CSS`@import`有点不同。CSS`@import`总是创建一个 HTTP 请求来获取导入的文件。Sass`@import`将这些文件组合在一起，以便将单个 CSS 文件发送到浏览器。

电源 Sass 的另一个概念是**部分文件**。可以创建包含小片段的部分 Sass 文件，以便包含到其他 Sass 文件中。部分文件的两个典型示例是**变量**和**混合。**变量有助于存储您希望在整个样式表中重复使用的信息。变量以美元符号开始。例如：

```ts
$brand-color-background: white;
$brand-color-content: black;

```

用法：

```ts
body {
  background-color: $brand-color-background;
  color: $brand-color-content;
}

```

mixin 允许您创建一组 CSS 声明，以便在整个样式表中重用。它们的行为类似于参数化函数。mixin 以[T0]指令开头，后跟名称。让我们创建一个 mixin 来集中任何 HTML 内容：

```ts
@mixin center($axis: "both") {
  position: absolute;
  @if $axis == "y" {
    top: 50%;
    transform: translateY(-50%);
  }
  @if $axis == "x" {
    left: 50%;
    transform: translateX(-50%);
  }
  @if $axis == "both" {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}

```

mixin 名称为`center`，如果不显式传递参数值，则参数`$axis`有一个默认值`"both"`。用法很简单——mixin 必须包含在`@include`指令中：

```ts
.centered-box {
  @include center();
}

```

这导致以下情况：

```ts
.centered-box {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

```

部分文件使用前导下划线命名，例如，[T0]、[T1]。下划线让 Sass 知道该文件不应编译为 CSS 文件。`@import`指令中的下划线和文件扩展名可以省略：

```ts
@import 'variables';
@import 'mixins';

```

Sass 具有更强大的功能，如继承、运算符、内置函数和处理媒体查询。有关更多详细信息，请参阅 Sass 官方网站（[http://sass-lang.com](http://sass-lang.com) ）。您可以在[上在线使用 Sasshttp://www.sassmeister.com](http://www.sassmeister.com) ：

![](img/d22e162b-7454-4587-b393-52443f7daf92.png)

也可以在[使用 http://sass.js.org](http://sass.js.org) ：

![](img/60eef939-fd89-430b-9a5b-a59d6ec0fc22.png)

现在是为组织 Sass 文件提供指导的时候了。什么是具有大量 Sass 文件的良好 CSS 体系结构和项目结构？在规划 CSS 体系结构时，应该将目录和文件模块化为类别。有几项提议和建议。最后，这取决于团队中的惯例。其中一个流行的建议是 7-1 模式（[https://sass-guidelin.es/#the-7-1-模式](https://sass-guidelin.es/#the-7-1-pattern)。此体系结构提供七个文件夹和一个主文件，用于导入所有文件并将其编译为单个文件。详情如下:

*   `base/`：此文件夹包含全局样式，如 CSS 重置、排版、颜色等。例如：
    *   `_reset.scss`
    *   `_typography.scss`
*   `helpers/`：此文件夹包含 Sass 工具和帮助程序，如变量、混合、函数等。单独编译时，此文件夹不应输出一行 CSS：
    *   `_variables.scss`
    *   `_mixins.scss`
*   `components/`：此文件夹保存自包含组件的样式。这些通常是小部件——其他组件可以由小的构建块组成。例如：
    *   `_button.scss`
    *   `_carousel.scss`
*   `layout/`：此文件夹保存较大组件的宏布局样式，如 CSS 网格、页眉、页脚、侧边栏等：
    *   `_header.scss`
    *   `_footer.scss`
*   `pages/`：这是一个可选文件夹，包含页面特定的样式：
    *   `_home.scss`
    *   `_about.scss`
*   `themes/`：这是一个可选文件夹，包含不同主题的样式。对于具有多个主题的大型站点来说，这很有意义：
    *   `_omega.scss`
    *   `_ultima.scss`
*   `vendors/`：此文件夹包含来自外部库和框架的文件，如 Bootstrap、jQueryUI、Select2 等：
    *   `bootstrap.scss`
    *   `jquery-ui.scss`

某些文件夹是特定于项目的，在许多项目中可能不存在。文件夹名称是任意的。例如，`components/`文件夹也可能被称为`modules/`，这取决于您的喜好。在角度项目中，用于构件样式设置的每个 Sass 文件与相应构件位于同一文件夹中。他们没有专用文件夹。

在这本书中，一个演示项目诞生了——一个虚构的图形编辑器，演示了样式概念。web 应用程序构建在 Angular 4 和 Bootstrap 3 的基础上（[http://getbootstrap.com [T2]。它的左右两侧有各种面板以及工具栏。布局响应迅速——面板堆叠在小屏幕上。所有样式文件都收集在`main.scss`文件中：](http://getbootstrap.com)

```ts
// 1\. Vendor files
@import "~font-awesome/css/font-awesome.min.css";
@import "vendor/bootstrap-custom";

// 2\. Helpers (variables, mixins, functions, ...)
@import "helpers/variables";
@import "helpers/mixins";

// 3\. Base stuff (common settings for all components and pages)
@import "common/viewport-workaround";
@import "common/global";
@import "common/components";

// 4\. Styles for components
@import "../../app/app.component";
@import "../../app/main/main.component";
@import "../../app/layout/layout.component";
@import "../../app/panel/panel.component";
@import "../../app/panel/toolbar/toolbar.component";

```

The complete graphic editor with Sass files is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/graphic-editor-sass.](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/graphic-editor-sass)

一旦`main.scss`文件导入到您引导 Angular 应用程序的文件中，Webpack 会自动在`index.html`中创建指向`main.css`的链接（感谢`HtmlWebpackPlugin`：

```ts
// Webpack creates a link to the main.css and put it into the 
// index.html
import './img/css/main.scss';

import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
import {AppModule} from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
                        .catch(err => console.error(err));

```

[T0]Bootstrap flexbox 布局与 Priming[T1]部分将说明 Bootstrap 4 更灵活、更现代的响应性布局。图形编辑器是新演示应用程序的基础。



# 创建新主题的简单方法



我们有时需要创建自己的主题，而不是使用预定义的主题。Web 应用程序通常应该具有特定于公司的外观和感觉，这是公司范围内的风格指南不断预设的。使用 PrimeNG 创建新主题很容易，因为它由 ThemeRoller CSS 框架（[提供支持 http://jqueryui.com/themeroller](http://jqueryui.com/themeroller) ）。ThemeRoller 提供了一个功能强大且易于使用的在线可视化工具。在本节中，我们将系统地展示创建新主题所需的所有步骤。有两种方法可以创建新主题，一种是由 ThemeRoller 创建，另一种是使用 Sass 从头开始创建。



# ThemeRoller 方法



要获得 ThemeRoller 在线视觉工具的第一手体验，请转到 ThemeRoller 主页，浏览可用的主题库，并使用 CSS 属性查看页面上嵌入的小部件的更改。所有 CSS 更改都将动态应用。

![](img/3ae3aff6-a6ba-4580-a76e-e44448a327b6.png)

我们必须选择一个现有主题（Gallery 选项卡）并编辑它（Roll Your Own 选项卡）。点击下载主题按钮即可完成工作。

We should deselect the Toggle All checkbox under the Components option on the Download Builder page so that our new theme only includes the skinning styles.

接下来，我们需要将下载的主题文件从 ThemeRoller 迁移到 Priming 主题基础结构。迁移步骤很简单：

1.  我们下载的主题包将有一个 CSS 文件`jquery-ui.theme.css`（以及缩小的变体）和`images`文件夹。提取包并将 CSS 文件重命名为`theme.css`。

2.  在 web 应用程序中，使用新主题的名称创建一个文件夹，例如，`src/img/themes/crazy`。
3.  将`theme.css`和`images`文件夹复制到`src/img/themes/crazy`中。

完成这些步骤后，您可以在`index.html`文件中创建指向`theme.css`的链接：

```ts
<link rel="stylesheet" type="text/css"  
      href="src/img/themes/crazy/theme.css"/>

```

这是在不需要 CSS 知识的情况下创建自定义主题的最简单方法。



# Sass 方法



第二种方法更灵活、更准确。最好由 Sass 手动创建一个新主题，因为该主题具有更好的可维护性。主要的 CSS 设置，如字体、颜色、边框半径等，都可以通过 Sass 变量进行配置。可以通过为这些变量设置自定义值来创建新主题。这正是 Priming 所遵循的方法。大部分自由主题都是以这种方式创建的。

The free themes are hosted on GitHub at [https://github.com/primefaces/primeng/tree/master/resources/themes](https://github.com/primefaces/primeng/tree/master/src/img/components/themes).

每个主题都有一个单独的文件夹，其中包含一个 Sass 文件，其中设置了变量。变量本身用于`_theme.scss`——所有免费主题的共享文件。如果将 PrimeNG 作为依赖项安装，则可以在`node_modules/primeng/resources/themes/`下找到此文件。有时，您还需要为特定 CSS 选择器设置自定义字体或特殊设置。您可以用自己的样式规则覆盖默认样式规则——只需在导入`_theme.scss`后编写即可。自定义主题文件的一般结构如下所示：

```ts
<predefined Sass variables>

@import "primeng/resources/themes/theme";

<your custom style rules>

```

让我们用三个 Sass 文件为新的`crazy`主题创建以下文件夹结构：

```ts
- src
    - assets
        - themes
            - crazy
                - fonts
                    ...
                - _variables.scss
                - theme.scss

```

Sass 变量可以从任何其他主题复制，如 Omega，并放置在`_variables.scss`中。其中一些获得自定义值，如下所示：

```ts
$fontFamily: "Quicksand", "Trebuchet MS", Arial, Helvetica, sans-serif;
...

// Header
$headerBorderWidth: 2px;
$headerBorderColor: #f0a9df;
...

// Content
$contentBorderWidth: 2px;
$contentBorderColor: #ffafaf;
...

// Forms
$invalidInputBorderColor: #ff0000;
...

```

如您所见，我们希望使用自定义字体`Quicksand`。您可以从以下免费资源下载`.otf`格式的字体（OpenType 字体）：[https://www.fontsquirrel.com/fonts/quicksand](https://www.fontsquirrel.com/fonts/quicksand) 。对于跨浏览器支持，我们需要四种格式的字体：`.ttf`、`.eot`、`.woff`和`.svg`。有许多转换器工具，其中一个可在[中找到 http://www.font2web.com](http://www.font2web.com) ，允许将任何`.otf`文件转换为上述四种格式。转换后，自定义字体应移动到`fonts`文件夹，并通过`@font-face`规则安装。

此外，我们希望小部件的标题有粉色渐变色，无效字段周围有红色边框。所有这些自定义规则都在主题文件`theme.scss`中完成。该文件的摘录说明了这一想法：

```ts
@import 'variables';
@import "primeng/resources/themes/theme";

@font-face {
  font-family: 'Quicksand';
  src: url('fonts/Quicksand-Regular.eot');
  url('fonts/Quicksand-Regular.woff') format('woff'),
  url('fonts/Quicksand-Regular.ttf') format('truetype'),
  url('fonts/Quicksand-Regular.svg') format('svg');
  font-weight: normal;
  font-style: normal;
}

.ui-widget-header {
  background: linear-gradient(to bottom, #fffcfc 0%, #f0a9df 100%);
}

.ui-inputtext.ng-dirty.ng-invalid,
p-dropdown.ng-dirty.ng-invalid > .ui-dropdown,
... {
  border-color: $invalidInputBorderColor;
}

```

The complete project with the `crazy` theme is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/custom-theme.](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/custom-theme)

建议的结构允许创建任意数量的主题。但是，如何将`theme.scss`编译成`theme.css`？有两种方法可以将 Sass 编译为 CSS：

1.  从命令行安装 Sass。安装过程见 Sass 主页（[http://sass-lang.com/install [T2]。注意，您需要预先安装 Ruby。安装 Sass 后，您可以从终端运行`sass theme.scss theme.css`。](http://sass-lang.com/install)
2.  使用`node-sass`（[https://github.com/sass/node-sass Node.js 下的](https://github.com/sass/node-sass)。

在 GitHub 上的项目中，我们使用了`node-sass`和`autoprefixer`（[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer) 和`cssnano`（[http://cssnano.co](http://cssnano.co) ）。所有必需的依赖项都在本地安装：

```ts
npm install node-sass autoprefixer cssnano postcss postcss-cli --save-dev

```

`package.json`中的四个方便的 npm 脚本有助于创建主题文件：

```ts
"premakecss": "node-sass --include-path node_modules/ src/img/themes/crazy/theme.scss -o src/img/themes/crazy/",
"makecss": "postcss src/img/themes/crazy/theme.css --use 
autoprefixer -d src/img/themes/crazy/",
"prebuild:css": "npm run makecss",
"build:css": "postcss src/img/themes/crazy/theme.css --use cssnano
             > src/img/themes/crazy/theme.min.css"

```

The `@import "primeng/resources/themes/theme"` path is found thanks to the `--include-path node_modules/` option, which sets the path to look for the imported files. This helps to avoid all the mess with relative paths.

`npm run build:css`命令将产生`theme.min.css`，应包含在页面上：

```ts
<link rel="stylesheet" type="text/css" href="src/img/themes/crazy/theme.min.css"/>

```

新主题的外观和感觉令人惊叹：

![](img/62845b68-aba2-4c25-ba07-8ebd89f0da3b.png)



# Priming 中的响应网格系统



PrimeNG 拥有**网格 CSS**——一个响应迅速、布局流畅的系统，针对移动设备、平板电脑和台式机进行了优化。Priming 组件在内部使用网格 CSS，但这个轻量级实用程序也可以作为独立工具使用。CSS 网格和其他网格系统一样基于 12 列布局。所有列的总宽度为 100%。在本节中，我们将详细解释 Priming 网格系统的所有功能。



# 基本原则



布局容器应具有`ui-g`样式类。布局容器的子元素在前缀为`ui-g-*`时变为列，其中`*`是 1 到 12 之间的任意数字。数字表示 12 个可用单元的占用空间。当列数超过 12 时，列将换行到下一行：

```ts
<div class="ui-g">
  <div class="ui-g-2">2</div>
  <div class="ui-g-4">4</div>
  <div class="ui-g-6">6</div>
  <div class="ui-g-8">8</div>
  <div class="ui-g-4">4</div>
</div>

```

以下布局有两行：

![](img/643b5dfc-196b-4da6-b0fd-1644f939d3cd.png)

两个`ui-g`集装箱也可以采用相同的两排布局：

```ts
<div class="ui-g">
  <div class="ui-g-2">2</div>
  <div class="ui-g-4">4</div>
  <div class="ui-g-6">6</div>
</div>
<div class="ui-g">
  <div class="ui-g-8">8</div>
  <div class="ui-g-4">4</div>
</div>

```

通常，`ui-g`样式类的*n*容器创建*n*行。



# 嵌套列



列可以嵌套在更复杂的布局中。要实现这一点，只需使用`ui-g-*`样式类嵌套元素：

```ts
<div class="ui-g">
  <div class="ui-g-8 ui-g-nopad">
    <div class="ui-g-6">6</div>
    <div class="ui-g-6">6</div>
    <div class="ui-g-12">12</div>
  </div>
  <div class="ui-g-4">4</div>
</div>

```

使用此结构，具有不同内容的列的高度将不相等。有一种更可靠的解决方案可以强制具有不同内容的列具有相同的高度。只需使用`ui-g`样式类或更简单的样式类将内部`div`元素包装在另一个`div`中，将`ui-g`指定给具有嵌套列的列：

```ts
<div class="ui-g">
  <div class="ui-g ui-g-8 ui-g-nopad">
    <div class="ui-g-6">6<br/>6<br/>6<br/>6<br/>6<br/>6<br/></div>
    <div class="ui-g-6">6</div>
    <div class="ui-g-12">12</div>
  </div>
  <div class="ui-g-4">4</div>
</div>

```

结果如下所示：

![](img/e96d526f-f1fd-4ad4-93dd-ef80d565a14e.png)

Columns have a default padding of `0.5em`. To remove it, you need to apply the `ui-g-nopad` style class. This was demonstrated in the earlier examples.



# 反应灵敏，布局流畅



响应式布局是通过向列应用附加类来实现的。不同断点支持四种屏幕大小。

| **前缀** | **装置** | **尺寸** |
| `ui-sm-*` | 像手机这样的小设备 | `max-width: 640px` |
| `ui-md-*` | 平板电脑等中型设备 | `min-width: 641px` |
| `ui-lg-*` | 大型设备，如台式机 | `min-width: 1025px` |
| `ui-xl-*` | 大屏幕显示器 | `min-width: 1441px` |

当一个图元具有表中列出的多个样式类时，这些样式类将自下而上应用。让我们举一个例子：

```ts
<div class="ui-g">
  <div class="ui-g-12 ui-md-6 ui-lg-2">ui-g-12 ui-md-6 ui-lg-2</div>
  <div class="ui-g-12 ui-md-6 ui-lg-2">ui-g-12 ui-md-6 ui-lg-2</div>
  <div class="ui-g-12 ui-md-4 ui-lg-8">ui-g-12 ui-md-4 ui-lg-8</div>
</div>

```

这里发生了什么？

*   在大屏幕上，三列按 2:12、2:12 和 8:12 的比例显示。
*   在中等屏幕上，显示两行。第一行的列数相等，第二行的列数为 4:12。
*   在小屏幕（移动设备）上，列被堆叠起来——每列显示在自己的行中。

屏幕截图显示了中型设备上列的排列：

![](img/daa75ad7-7fe2-4cf3-a36b-8a745a9b8ec5.png)

涂底漆部件具有内置的响应模式。他们了解一门特殊的`ui-fluid`风格的课程。网格 CSS 和任何其他网格系统都可以与这个样式类一起使用，它为组件提供了 100%的宽度。此行为有助于高效使用屏幕空间。示例演示了流体布局中的各种组件：

```ts
<div class="ui-fluid ui-corner-all">
  <div class="ui-g">
    <div class="ui-g ui-g-12 ui-md-6 ui-g-nopad">
      <div class="ui-g-12 ui-md-3 ui-label">
        Passenger
      </div>
      <div class="ui-g-12 ui-md-9">
        <input pInputText type="text"/>
      </div>
    </div>
    <div class="ui-g ui-g-12 ui-md-6 ui-g-nopad">
      <div class="ui-g-12 ui-md-3 ui-label">
        Flight day
      </div>
      <div class="ui-g-12 ui-md-9">
        <p-calendar [(ngModel)]="date" [showIcon]="true">
        </p-calendar>
      </div>
    </div>
  </div>
  <div class="ui-g">
    <div class="ui-g ui-g-12 ui-md-6 ui-g-nopad">
      <div class="ui-g-12 ui-md-3 ui-label">
        Notice
      </div>
      <div class="ui-g-12 ui-md-9">
        <textarea pInputTextarea type="text"></textarea>
      </div>
    </div>
    <div class="ui-g ui-g-12 ui-md-6 ui-g-nopad">
      <div class="ui-g-12 ui-md-3 ui-label">
        Destination
      </div>
      <div class="ui-g-12 ui-md-9">
        <p-listbox [options]="cities" [(ngModel)]="selectedCity">
        </p-listbox>
      </div>
    </div>
  </div>
</div>

```

从中屏幕到大屏幕的布局如下所示：

![](img/86b5cdab-9375-4eb7-b385-44e4c3bbd4dd.png)

小屏幕上的布局具有堆叠的列：

![](img/3bab0f56-a8cf-4568-bc14-bea917f27b00.png)

如您所见，所有右对齐的标签都变为左对齐。您可以通过媒体查询实现此行为：

```ts
.ui-fluid .ui-g .ui-label {
  text-align: right;
  white-space: nowrap;
}

@media screen and (max-width: 640px) {
  .ui-fluid .ui-g .ui-label {
    text-align: left;
  }
}

```

The complete demo application with instructions is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/primeng-grid-css.](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/primeng-grid-css)



# 引导 flexbox 布局符合 Priming



在本节中，我们将使用 Bootstrap 4（[重新实现在*使用 Sass*组织项目结构部分中引入的图形编辑器 https://v4-alpha.getbootstrap.com](https://v4-alpha.getbootstrap.com) 和涂底漆部件。从 v4.0.0-alpha.6 版本开始，引导在默认情况下只有基于 flexbox 的布局，没有回退。

**Flexbox**是一种新的布局模型，在所有现代浏览器（[中都得到了广泛支持 http://caniuse.com/#search=flexbox](http://caniuse.com/#search=flexbox) ）。网上有很多教程。例如，您可以在[上阅读 CSS flexbox 布局的全面指南 https://css-tricks.com/snippets/css/a-guide-to-flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox) 。Flexbox 解决了许多布局问题。flexbox 的主要优点之一是能够填充额外的空间。flexbox 布局中的所有列都具有相同的高度，而与它们的内容无关。让我们展示两种设备分辨率的图形编辑器的最终屏幕。

对于桌面：

![](img/9b6cf052-35eb-4e31-b089-c8192e78f549.png)

流动电话：

![](img/08227be2-bbd3-455d-b231-2fce6ee922f1.png)

除了启动，我们还需要安装最新的引导程序 4。在撰写本文时，这是 4.0.0-alpha.6：

```ts
npm install bootstrap@4.0.0-alpha.6 --save

```

安装完成后，需要将带有 flexbox 布局规则的 CSS 文件导入到`main.scss`文件中：

```ts
@import "~bootstrap/dist/css/bootstrap-grid.css";

```

在以前的引导版本中，必须明确启用 flexbox 布局：

```ts
$enable-flex: true;
@import "~bootstrap/scss/bootstrap-grid.scss";

```

如果您打算将样式用于其他柔性对齐选项，则必须导入`bootstrap-grid.scss`和`_flex.scss`：

```ts
@import "~bootstrap/scss/bootstrap-grid";
@import "~bootstrap/scss/utilities/flex";

```

`_flex.scss`是一组实用程序，用于垂直和水平对齐列，控制内容的视觉顺序，等等。该文件包含各种 CSS 规则，如`justify-content-start`、`align-items-end`、`align-self-auto`、`flex-first`、`flex-last`等。这里解释了一些规则。请参阅官方引导文档以了解更多详细信息（[https://v4-alpha.getbootstrap.com/layout/grid [T7]。](https://v4-alpha.getbootstrap.com/layout/grid)

整个应用程序的框架位于两个文件中：`app.component.html`和`layout.component.html`。第一个文件包含 PrimeNG 的选项卡式菜单，其中包含两个菜单项：

```ts
<div class="container-fluid">
  <div class="row">
    <div class="col">
      <p-tabMenu [model]="items"></p-tabMenu>
    </div>
  </div>
</div>

<router-outlet></router-outlet>

```

每项定义`routerLink`：

```ts
items: MenuItem[];
...
this.items = [
  {label: 'SVG Graphic-Engine', icon: 'fa-paint-brush',
    routerLink: '/svg'},
  {label: 'Canvas Graphic-Engine', icon: 'fa-paint-brush',
    routerLink: '/canvas'}
];

```

点击选项卡式菜单中的选项卡将`layout.component.html`加载到`router-outlet`：

```ts
<div class="container-fluid">
  <div class="row align-items-center ge-toolbar">
    <div class="col">
      <ge-toolbar></ge-toolbar>
    </div>
  </div>
  <div class="row no-gutters">
    <div class="col-md-8 flex-md-unordered col-drawing-area">
      <div class="drawing-area">
        <ng-content select=".ge-drawing-area"></ng-content>
      </div>
    </div>
    <div class="col-md-2 flex-md-last">
      <div class="flex-column no-gutters">
        <div class="col ge-palette">
          <ge-palette></ge-palette>
        </div>
        <div class="col ge-shapes">
          <ge-shapes></ge-shapes>
        </div>
      </div>
    </div>
    <div class="col-md-2 flex-md-first">
      <ge-properties></ge-properties>
    </div>
  </div>
</div>

```

`ng-content`区域被 SVG 或画布表面取代，用户可以在其中绘制形状。`ge-toolbar`组件包含 PrimeNG 的`<p-toolbar>`。其他`ge-*`组件包含面板，例如`<p-panel header="Palette">`。

最有趣的部分是样式类。前面代码段中使用的样式类的简短描述如下：

| **风格类** | **说明** |
| `row` | 它用作行内部列的容器。每列可以占用 1 到 12 个空格。 |
| `align-items-*` | 这定义了行中弹性列的垂直位置。类 T0 类将中间的列定位。 |
| `no-gutters` | 这将删除行的边距和列的填充。 |
| `col` | 这设置了`auto-layout`模式——引导 4 的一个新特性，用于等宽列。列将自动分配行中的空间。 |
| `col-<prefix>-<number>` | 这表示在可能的每行 12 列中，您要使用的列数。前缀定义断点。例如，`col-md-8`类的意思是，在中等大小和较大屏幕上，列为 8/12，在小于中等大小的屏幕上，列为 12/12（默认值）。 |
| `flex-column` | 这将更改项目（列）的`flex-direction`。项目在水平或垂直方向上布置。`flex-column`类改变方向，从左到右，从上到下。 |
| `flex-<prefix>-first` | 这会将列重新排序为布局中的第一列。前缀定义了应用重新排序的断点。 |
| `flex-<prefix>-last` | 这会将列重新排序为布局中的最后一列。前面描述的前缀。 |
| `flex-<prefix>-unordered` | 这将显示第一列和最后一列之间的列。前面描述的前缀。 |

注意，在小型设备上，我们减小了字体大小。这可以通过引导提供的断点混合来实现：

```ts
@import "~bootstrap/scss/mixins/breakpoints";

@include media-breakpoint-down(md) {
  body {
    font-size: 0.9em;
  }
}

```

存在各种断点混合，它们需要以下参数之一：

*   `xs`：超小屏幕<576px
*   `sm`：小屏幕>=576px
*   `md`：中屏>=768px
*   `lg`：大屏幕>=992px
*   `xl`：超大屏>=1200Px

例如，`ge-palette`样式类的元素在 768px 以上的屏幕上获取`margin-top: 0`，在 768px 以下的屏幕上获取`margin-top: 0.5em`：

```ts
.ge-palette {
  margin-top: 0.5em;
}

@include media-breakpoint-up(md) {
  .ge-palette {
    margin-top: 0;
  }
}

```

The complete graphic editor with Bootstrap 4 and PrimeNG is available on GitHub at
[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/graphic-editor-bootstrap4.](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter2/graphic-editor-bootstrap4)



# 总结



阅读本章后，您可以区分结构样式类和蒙皮样式类。简而言之，结构样式类定义零部件的骨架，蒙皮类用于创建专题。我们已经了解了如何设置任何启动主题并创建一个新主题。新主题可以由 ThemeRoller 创建，也可以通过为现有主题的 Sass 变量和 CSS 属性设置自定义值并随后编译到 CSS 文件来创建。我们鼓励为模块化 CSS 架构使用 CSS 预处理器。Sass 预处理器有助于编写更好的样式。还提供了组织 Sass 文件的指南。

阅读本章后，您还可以使用一个响应网格系统，Priming own 或 Bootstrap 的系统。PrimeNG 提供了一个轻量级、反应灵敏、流畅的布局系统。此外，在顶部容器元素上使用`.ui-fluid`样式类时，为具有内置响应模式的组件打底。基于 flexbox 的布局是一个新标准，也是每个 HTML5Web 应用程序的优势。flexbox 的主要优点之一是能够填充额外的空间——所有列的高度都相同。Bootstrap 4 增加了对 flexbox 模型的支持，并允许您开发惊人的布局。

从下一章开始，我们将深入研究每个组件。我们进入激动人心的启动世界的旅程始于输入和选择组件。