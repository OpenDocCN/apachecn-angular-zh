

# 角度更大–SPA 和布线

上一章是关于在 Angular 中构建我们的第一个有用的应用程序，然后本章是关于为它添加大量的 Angular 优点。在学习过程中，我们已经开始探索一个技术平台，现在我们可以使用 Angular 构建一些基本的应用程序。但这只是开始！在我们能够在一个相当大的应用程序中有效地使用 Angular 之前，还有很多东西需要学习。本章使我们离实现这一目标又近了一步。

*7 分钟锻炼*应用程序仍然有一些粗糙的边缘，我们可以在改善应用程序整体体验的同时加以修复。本章主要介绍如何添加这些增强功能和特性。和往常一样，这个应用程序构建过程为我们提供了足够的机会来增强我们对框架的理解，并学习有关框架的新事物。

本章涵盖的主题包括：

*   **探索 Angular 的单页应用**（**SPAs**）：我们探索 Angular 的 SPA 功能，包括路线导航、链接生成和路由事件。
*   **理解依赖注入**：平台的核心特性之一。在本章中，我们将学习 Angular 如何有效地使用依赖注入在整个应用程序中注入组件和服务。
*   **角度纯（无状态）和不纯（有状态）管道**：我们在构建一些新管道的同时，更详细地探讨了角度管道的主要数据转换结构。

*   **跨组件通信**：由于 Angular 是关于组件及其交互的，我们来看看如何在父子和兄弟组件设置中进行跨组件通信。我们了解 Angular 的*模板变量*和*事件*如何促进这种交流。
*   **创建和使用事件**：我们了解组件如何公开自己的事件，以及如何从 HTML 模板和其他组件绑定到这些事件。

作为补充说明，我希望您定期使用*7 分钟的锻炼*，并锻炼身体。如果没有，休息七分钟，现在就开始锻炼。我坚持！

希望这次锻炼很有趣！现在让我们回到严肃的话题上来。让我们从探索 Angular 的**单页应用程序**（**SPA**功能开始。

We are starting from where we left off in [Chapter 2](3.html), *Building Our First App - 7-Minute Workout*. The `checkpoint2.4` Git branch can serve as the base for this chapter. The code is also available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)) for everyone to download. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of `checkpoint2.4` (a ZIP file) from the GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.



# 探索单页应用程序功能

*7 分钟的训练*在我们加载应用程序时开始，但最后一次训练会永久地粘在屏幕上。这不是一个非常优雅的解决方案。我们为什么不在应用程序中添加开始和结束页面？这使应用程序看起来更专业，并使我们能够理解 Angular 的单页命名法。



# 角度 SPA 基础设施

有了 Angular 和 Vue.js 等现代 web 框架，我们现在已经习惯了不执行整页刷新的应用程序。但如果你对这个场景还不熟悉，那么值得一提的是什么是*水疗中心*。

**单页应用程序**（**SPA**）是基于浏览器的应用程序，没有任何整页刷新。在这些应用程序中，一旦加载了初始 HTML，任何未来的页面导航都将使用 AJAX 和 HTML 片段进行检索，并注入到已加载的视图中。谷歌邮件是 SPA 的一个很好的例子。SPA 为用户带来了极好的用户体验，因为用户可以获得类似于桌面应用程序的感觉，无需经常回发和页面刷新，这通常与传统 web 应用程序相关。

与任何现代 JavaScript 框架一样，Angular 也为 SPA 实现提供了必要的构造。让我们了解它们并添加我们的应用程序页面。



# 角度布线

Angular 使用其**路由基础设施**支持 SPA 开发。此基础结构跟踪浏览器 URL，启用超链接生成，公开路由事件，并为对 URL 更改做出反应的视图提供一组指令/组件。

有四个主要的框架部件协同工作以支持角度路由基础架构：

*   **路由器（路由器）**：实际提供组件导航的主要基础设施部件
*   **路由配置（Route）**：组件路由器依赖路由配置设置路由
*   **RouterOutlet 组件**：`RouterOutlet`组件是占位符容器（*主机*），其中加载路由特定视图
*   **RouterLink 指令**：这会生成超链接，可以嵌入锚定标签中进行导航

下图突出显示了这些组件在路由设置中扮演的角色：

![](img/00021.jpeg)

在我们为*7 分钟锻炼*设定路线时，我强烈鼓励大家继续查看此图表。

*路由器*是这个完整设置的核心部分；因此，快速概述路由器将很有帮助。



# 角形路由器

如果您使用过任何支持 SPA 的 JavaScript 框架，那么这就是工作原理。该框架监视浏览器 URL，并根据加载的 URL 提供视图。此作业有专用的框架组件。在角度世界中，此跟踪由*框架服务*、**路由器**完成。

In Angular, any class, object, or function that provides some generic functionality is termed a **service**. *Angular does not provide any special construct to declare a service as it does for components, directives, and pipes*. Anything that can be consumed by components/directives/pipes can be termed a service. The router is one such service. And there are many more services that are part of the framework. *If you are from the Angular 1 realm, this is a pleasant surprise-no service, factory, provider, value, or constant!*

角度路由器用于：

*   启用路由更改时组件之间的导航
*   在组件视图之间传递路由数据
*   使当前管线的状态可用于激活/加载的零部件
*   提供允许从组件代码进行导航的 API
*   跟踪导航历史记录，允许我们使用浏览器按钮在零部件视图之间来回移动
*   提供生命周期事件和防护条件，使我们能够基于一些外部因素影响导航

The router also supports some advanced routing concepts, such as parent-child routes. This gives us the ability to define routes at multiple levels inside the component tree. The parent component can define routes and child components can further add more sub-routes to the parent route definition. This is something that we cover in detail in , *Building Personal Trainer*.

路由器不能单独工作。如上图所示，它依赖于其他框架片段来实现所需的结果。让我们添加一些应用程序页面，并处理拼图的每一部分。



# 路由设置

角度路由器不是核心角度框架的一部分。它有一个单独的角度模块和自己的 npm 包。Angular CLI 已将此软件包作为项目设置的一部分安装。查看`package.json`以确认这一点：

```ts
"@angular/platform-browser-dynamic": "6.0.0", "@angular/router": "6.0.0",
```

由于路由器已经安装，我们只需将其集成到*7 分钟训练*中即可。

我们可以首先在`index.html`的`head`部分添加`base`参考（突出显示），如果不存在：

```ts
<title>Trainer</title>
<base href="/">
```

*路由器需要设置`base href`。*该`href`值指定用于 HTML 文档中所有相关 URL 的基本 URL，包括指向 CSS、脚本、图像和任何其他资源的链接。此设置有助于路由器创建导航 URL。



# 添加起始页和结束页

这里的计划是为*7 分钟锻炼*准备三页：

*   **起始页**：这将成为应用程序的登录页
*   **训练页面**：我们目前拥有的
*   **完成页面**：训练完成后，我们将导航到此页面

训练组件及其视图（`workout-runner.component.ts`和`workout-runner.component.html`已经存在。那么让我们创建`StartComponent`和`FinishComponent`。

同样，使用 Angular CLI 为 start 和 finish 组件生成样板文件。导航到`trainer/src/app`文件夹并执行组件生成命令：

```ts
ng generate component start -is
ng generate component finish -is
```

接下来，从`checkpoint3.1`Git 分支复制*开始*和*结束*组件的视图（要下载的 GitHub 位置是[http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app) ）。

*开始*和*完成*组件的实现均为空。有趣的部分在视图中。“开始”组件视图有一个链接，可以导航到“训练跑步者”组件（`<a routerLink="/workout" ...`），因此也可以导航到“完成”。我们还没有确定路线。

The start and finish components have been added to *app module*, as they are rudimentary views, unlike workout runner, which has its own `WorkoutRunnerModule` module.

这三个部分都准备好了。是时候定义路由配置了！



# 路由配置

为了设置*7 分钟训练*的路线，我们将创建*路线定义模块文件*。在`trainer/src/app`文件夹中创建一个名为`app-routing.module.ts`的文件，定义应用程序的顶级路由。添加以下路由设置或从`checkpoint3.1`Git 分支复制：

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { WorkoutRunnerComponent } from './workout-runner/workout-runner.component';
import { StartComponent } from './start/start.component';
import { FinishComponent } from './finish/finish.component';

const routes: Routes = [
    { path: 'start', component: StartComponent },
    { path: 'workout', component: WorkoutRunnerComponent },
    { path: 'finish', component: FinishComponent },
    { path: '**', redirectTo: '/start' }
];

@NgModule({
    imports: [RouterModule.forRoot(routes, { enableTracing: true })],
    exports: [RouterModule]
})
export class AppRoutingModule { }

```

The Angular CLI also supports boilerplate route-generation for modules. We have not used that feature. We can learn about it from the CLI documentation at [http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing).

`routes`变量是`Route`对象的数组。每个`Route`定义一条路由的配置，包含：

*   `path`：要匹配的目标路径
*   `component`：点击路径时要加载的组件

这样的路由定义可以解释为：“当用户导航到一个 URL（在`path`中定义）时，加载`component`属性中定义的相应组件。”以第一个路由为例；导航到`http://localhost:9000/start`将加载`StartComponent`的组件视图。

你可能已经注意到最后一个`Route`定义看起来有点不同。`path`看起来很奇怪，也没有`component`属性。带有`**`的路径表示我们的应用程序的全面路径或**通配符路径**。任何与前三条路线中的一条不匹配的导航都与“全面覆盖”路线匹配，导致应用程序导航到起始页（在`redirectTo`属性中定义）。

We can try this once the routing setup is complete. Type any random route, such as `http://localhost:9000/abcd`, and the app automatically redirects to `http://localhost:9000/start`.

我们最终创建了一个新模块，并通过调用`RouterModule.forRoot`将其导入`AppRoutingModule`。通过重新导出 Angular 的`RouterModule`，我们可以导入`AppRoutingModule`而不是`RouterModule`，并可以访问所有路由构造以及`AppModule`中可用的应用程序路由。

The `enableTracing: true` property on the `forRoot` function parameter allows us to monitor the *router events* (such as `NavigationStart`, `NavigationEnd`, and `NavigationCancel`) that happen when navigation takes place and the correct route is resolved. The logs are visible in the browser's debugger console. *Use it for debugging purposes only, remove it from production builds*.
Could the preceding routing setup could have been done inside `AppModule`? Yes, it's definitely possible, but we would recommend against it. As the number of routes grow and the routing setup becomes more complex, having a separate routing module helps us organize the code better.

这里需要强调的一点是：*路由排序在路由定义*中很重要。由于路由匹配是以自上而下的方式进行的，因此它会在第一次匹配时停止，以在任何通用的全包路由之前定义您的特定路由，例如我们定义中的`**`*通配符路由*，它在最后声明。

默认路由器设置使用**pushstate**机制进行 URL 导航。在这种设置中，URL 看起来像：

*   `localhost:4200/start`
*   `localhost:4200/workout`
*   `localhost:4200/finish`

这可能看起来没什么大不了的，但请记住，我们是在做客户端导航，而不是我们已经习惯了的整个页面重定向。正如**开发者指南**所述：

Modern HTML 5 browsers support `history.pushState`, a technique that changes a browser's location and history without triggering a server page request. The router can compose a "natural" URL that is indistinguishable from one that would otherwise require a page load.



# Pushstate API 和服务器端 url 重写

路由器在以下两种情况之一中使用 pushstate API：

*   当我们点击嵌入视图中的链接时（`<a>`标记）
*   当我们使用路由器 API 时

在这两种情况下，路由器都会截获任何导航事件，加载相应的组件视图，最后更新浏览器 URL。请求从未发送到服务器。

但是如果我们刷新浏览器窗口呢？

角度路由器无法截获浏览器的刷新事件，因此会发生完全的页面刷新。在这种情况下，服务器需要响应仅存在于客户端的资源请求（URL）。典型的服务器响应是发送可能导致[T1]错误的任意请求的应用程序条目文件（如[T0]）。这就是我们所说的服务器**url 重写**。这意味着请求任何不存在的 URL，例如`/start`、`/workout`或`/finish`加载索引页。

Each server platform has a different mechanism to support url-rewrite. We suggest you look at the documentation for the server stack you use to enable url-rewrite for your Angular apps.

一旦应用程序路由完成，我们可以看到服务器端重写正在运行。完成后，尝试刷新应用程序并查看浏览器的网络日志；*服务器每次发送相同生成的*`index.html`*内容，与请求的 URL*无关。

路由模块定义现已完成。在继续之前，打开`app.module.ts`并导入`AppRoutingModule`：

```ts
import { FinishComponent } from './finish/finish.component';
import { AppRoutingModule } from './app-routing.module';
 @NgModule({ 
  imports: [..., StartModule, FinishModule, AppRoutingModule], 
```

既然我们已经定义了所有必需的组件和所有路由，那么在路由更改时，我们在哪里注入这些组件呢？我们只需要在主机视图中为其定义一个占位符。



# 使用路由器出口渲染组件视图

看看当前的`AppComponent`模板（`app.component.html`，它有一个嵌入的`WorkoutRunnerComponent`：

```ts
<abe-workout-runner></abe-workout-runner>
```

这需要改变，因为我们需要根据 URL（`/start`、`/workout`或`/finish`呈现不同的组件。删除前面的声明并将其替换为*路由器指令*：

```ts
<router-outlet></router-outlet>
```

`RouterOutlet`是一个角度组件指令，当路线发生变化时，它充当装载路线特定组件的占位符。它与路由器服务集成，以根据当前浏览器 URL 和路由定义加载适当的组件。

下图有助于我们轻松直观地看到`router-outlet`设置发生了什么：

![](img/00022.jpeg)

我们几乎完成了；是时候触发导航了。



# 路线导航

与标准浏览器导航一样，角度导航也会发生：

*   当用户直接在浏览器地址栏中输入 URL 时
*   单击定位标记上的链接时
*   关于使用脚本/代码导航

如果未启动，则启动应用程序并加载`http://localhost:4200`或`http://localhost:4200/start`。应该加载起始页。

单击开始按钮，训练应在`http://localhost:4200/workout`URL 下开始。

角度路由器还支持旧式的基于*散列（#）的路由*。启用基于哈希的路由时，路由显示如下：

*   `localhost:9000/#/start`
*   `localhost:9000/#/workout`
*   `localhost:9000/#/finish`

要将其更改为基于散列的路由，顶级路由的路由配置应在`RouterModule.forRoot`函数中增加一个额外的`useHash:true`属性（第二个参数）。

有趣的是，`StartComponent`视图定义中的锚定链接没有`href`属性。而是有一个`RouterLink`指令（指令名称为`RouterLink`，选择器为`routerLink`：

```ts
<a routerLink="/workout">
```

在前一种情况下，由于路由是固定的，因此指令采用常量表达式（`"/workout"`。我们在这里不使用标准方括号符号（`[]`，而是为指令指定一个固定值。这就是所谓的**一次性绑定**。对于动态路由，我们可以使用模板表达式和链接参数数组。稍后我们将讨论动态路由和链接参数数组。

Notice the **/** prefix in the preceding route path. `/` is used to specify an absolute path. The Angular router also supports relative paths, which are useful when working with child routes. We will explore the concept of child routes in the next few chapters.

刷新应用程序并检查呈现的 HTML 中的`StartComponent`；使用正确的`href`值呈现前面的锚定标记：

```ts
<a ... href="/workout">
```

Avoid hardcoding route links
While you could have directly used `<a href="/workout">`, prefer `routerLink` to avoid hardcoding routes.



# 链接参数数组

当前*7 分钟训练*的路线设置非常简单，不需要在链接生成过程中传递参数。但是，对于需要动态参数的非平凡路由，这种能力是存在的。请参见此示例：

```ts
@RouteConfig([ 
 { path: '/users/:id', component: UserDetail }, 
  { path: '/users', component: UserList}, 
])
```

这是如何生成第一条路线的：

```ts
<a [routerLink]="['/users', 2]  // generates /users/2
```

分配给`RouterLink`指令的数组就是我们所说的**链路参数数组**。阵列遵循特定的模式：

```ts
['routePath', param1, param2, {prop1:val1, prop2:val2} ....] 
```

第一个元素始终是路由路径，下一组参数用于替换路由模板中定义的占位符标记。

The Angular router is quite a beast and supports almost everything that we expect from a modern router library. It supports child routes, async routes, lifecycle hooks, secondary routes, and some other advanced scenarios. We'll delay discussion on these topics until later chapters. This chapter just gets us started with Angular routing, but there is more to come!

路由器链接参数也可以是一个对象。这些对象用于向进路提供**可选参数**。请参见此示例：

```ts
<a [routerLink]="['/users', {id:2}]  // generates /users;id=2
```

请注意，生成的链接包含一个分号，用于将可选参数与路由和其他参数分开。

实现的最后一个缺失部分是在训练完成后发送到“完成”页面。



# 使用路由器服务进行组件导航

从训练页面到完成页面的导航不是手动触发的，而是在训练完成后触发的。`WorkoutRunnerComponent`需要触发此转换。

为此，`WorkoutRunnerComponent`需要抓住路由器并调用其上的`navigate`方法。

`WorkoutRunnerComponent`如何获取路由器实例？使用 Angular 的*依赖注入框架*。我们回避这个话题已有一段时间了。我们已经取得了很多成就，甚至不知道一直以来都有一个依赖注入框架在起作用。让我们再等一会儿，首先集中精力解决导航问题。

`WorkoutRunnerComponent`要获取路由器服务实例，只需在构造函数上声明服务即可。更新`WorkoutRunnerComponent`构造函数并添加导入：

```ts
import {Router} from '@angular/router'; 
...
constructor(private router: Router) {
```

Angular 现在在实例化`WorkoutRunnerComponent`时神奇地将当前路由器注入`router`私有变量。这个魔法是由*依赖注入框架*完成的。

现在只需将`console.log("Workout complete!");`语句替换为对`navigation`路由器的调用：

```ts
this.router.navigate( ['/finish'] );
```

`navigate`方法采用与`RouterLink`指令相同的*链路参数数组*。我们可以通过耐心等待训练完成来验证实施情况！

If you are having a problem running the code, look at the `checkpoint3.1` Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of `checkpoint3.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1). Refer to the `README.md` file in the trainer folder when setting up the snapshot for the first time.

我们在*7 分钟训练*中定义的路线是标准的简单路线。但是，如果存在接受参数的动态路由，我们如何使参数在组件中可用？Angular 为此提供了一项服务，`ActivatedRoute`服务。



# 使用 ActivatedRoute 服务访问路由参数

有时应用程序需要访问活动路由状态。在当前实现过程中，与当前路由相关的 URL 和其他参数可能会很方便。

`ActivatedRoute`服务是所有当前路线相关查询的一站式服务。它有许多属性，包括`url`和`paramMap`，可用于查询路由的当前状态。

让我们看一个参数化路由的示例，以及如何访问从组件传递的参数，给定此路由：

```ts
{ path: '/users/:id', component: UserDetailComponent },
```

当用户导航到`/user/5`时，底层组件可以通过首先将`ActivatedRoute`注入其构造函数来访问`:id`参数值：

```ts
export class UserDetailComponent { 
  constructor( private route: ActivatedRoute ... 
```

然后，在代码中需要参数的任何地方，调用`ActivatedRoute.paramMap`属性上的`get`方法：

```ts
ngOnInit() {
    let id = +this.route.paramMap.get('id'); // (+) converts string 'id' to a number
    var currentUser=this.getUser(id) 
}  
```

The `paramMap` property on `ActivatedObject` is actually an **observable.** We will learn more about observables later in the chapter, but for now, it is enough to understand that observables are objects that let the outside world know about their state changes by raising events that others can listen into.

我们将在后面的章节中使用此路由器功能，我们将构建一个可以创建训练和编辑现有训练的新应用程序。在接下来的章节中，我们还将介绍一些高级路由概念，包括*子路由*、*延迟加载路由*和*保护条件*。

我们已经介绍了角度路由的基础知识，现在是时候专注于一个早该讨论的主题了：*依赖注入*。



# 角度依赖注入

Angular 大量使用依赖项注入来管理应用程序和框架依赖项。令人惊讶的是，在我们开始讨论路由器之前，我们可以忽略这个话题。一直以来，角度依赖注入框架一直在支持我们的实现。一个好的依赖注入框架的标志是，消费者可以使用它，而不必过多地考虑内部问题，也不必拘泥于礼节。

如果您不确定依赖注入是什么，或者只是对它有一个模糊的概念，那么对 DI 的介绍肯定不会伤害任何人。



# 依赖注入 101

对于任何应用程序，其组件（不要与角度组件混淆）都不是孤立工作的。它们之间存在依赖关系。组件可以使用其他组件来实现其期望的功能。**依赖项注入**是一种管理此类依赖项的模式。

DI 模式在许多编程语言中很流行，因为它允许我们以松散耦合的方式管理依赖关系。有了这样一个框架，依赖对象由 DI 容器管理。这使得依赖项可以交换，并且整个代码更加解耦和可测试。

DI 背后的思想是对象不创建/管理自己的依赖项。相反，依赖项是从外部提供的。这些依赖项可以通过构造函数（称为**构造函数注入**（Angular 也这样做）或通过直接设置对象属性（称为**属性注入**）来实现。

下面是 DI 的一个基本示例。考虑一个名为 EndoT0}的类，它需要用于日志记录操作的

```ts
class Tracker() { 
  logger:Logger; 
  constructor() { 
    this.logger = new Logger();    
  } 
}
```

`Logger`类的依赖关系在`Tracker`内部是硬连线的，因为`Tracker`本身实例化了`Logger`实例。如果我们将这种依赖性外部化呢？因此，课程变成：

```ts
class Tracker { 
  logger:Logger; 
  constructor(logger:Logger) { 
    this.logger = logger;    
  } 
}
```

这种看似无害的变化产生了重大影响。通过添加外部提供依赖关系的功能，我们现在可以：

*   **解耦这些组件并启用可扩展性**。DI 模式允许我们改变`Tracker`类的日志记录行为，而不必触及类本身。以下是一个例子：

```ts
        var trackerWithDBLog=new Tracker(new DBLogger()); 
        var trackerWithMemoryLog=new Tracker(new MemoryLogger()); 
```

我们刚才看到的两个`Tracker`对象对于同一`Tracker`类实现具有不同的日志记录功能。`trackerWithDBLog`记录到 DB，`trackerWithMemoryLog`记录到内存（假设`DBLogger`和`MemoryLogger`都来自`Logger`类）。由于`Tracker`不依赖于`Logger`（`DBLogger`或`MemoryLogger`上的特定实现，这意味着`Logger`和`Tracker`是松散耦合的。将来，我们可以派生一个新的`Logger`类实现，并在不改变`Tracker`实现的情况下将其用于日志记录。

*   **模拟依赖项**：模拟依赖项的能力使我们的组件更易于测试。`Tracker`实现可以通过为`Logger`提供模拟实现（如`MockLogger`）或通过使用能够轻松模拟`Logger`接口的模拟框架来单独测试（单元测试）。

我们现在可以理解 DI 有多强大了。

仔细想想：一旦 DI 就位，解决依赖关系的责任现在就落在调用/使用者代码上。在前面的示例中，先前实例化`Tracker`的类现在需要创建`Logger`派生，并在使用它之前将其注入`Tracker`。

显然，这种交换组件内部依赖关系的灵活性是有代价的。调用代码实现可能变得过于复杂，因为它现在也必须管理子依赖项。一开始这看起来很简单，但考虑到依赖组件本身可能具有依赖性，我们要处理的是一个复杂的依赖树结构。

这就是 DI 容器/框架增加价值的地方。它们减少了调用代码管理依赖项的麻烦。然后，这些容器构造/管理依赖项，并将其提供给客户机/消费者代码。

Angular DI 框架管理 Angular 组件、指令、管道和服务的依赖关系。



# 角度依赖注入的研究

Angular 使用自己的 DI 框架来管理应用程序之间的依赖关系。可见依赖项注入的第一个例子是将组件路由器注入`WorkoutRunnerComponent`：

```ts
constructor(private router: Router) { 
```

当调用方【T1/T0】在内部找到调用方时，创建【T1/T0】类。

虽然 Angular 在隐藏 DI 基础设施方面做得很好，但我们必须了解 Angular DI 是如何工作的。否则，一切似乎都很神奇。

DI 是关于创建和管理依赖关系的，实现这一点的框架组件被称为[T0]注入器[T1]。要使喷油器管理依赖关系，它需要了解以下内容：

*   **什么：**依赖关系是什么？依赖项可以是类、对象、工厂函数或值。在注入依赖项之前，每个依赖项都需要在 DI 框架中注册。
*   **where/when:**DI 框架需要知道何时何地注入依赖项。
*   **如何**：DI 框架还需要知道在请求时创建依赖关系的方法。

任何注入的依赖项都需要回答这些问题，不管它是框架构造还是我们创建的工件。

以`WorkoutRunnerComponent`中的`Router`实例注入为例。为了回答“是什么”和“如何”部分，我们通过将`RouterModule`导入`AppRoutingModule`来注册`Router`服务：

```ts
imports: [..., AppRoutingModule];
```

`AppRoutingModule`是一个模块，可将多条路由和所有角路由器相关服务一起导出（技术上可重新导出`RouterModule`。

位置和时间取决于需要依赖项的组件。`WorkoutRunnerComponent`的构造函数依赖于`Router`。当`WorkoutRunnerComponent`作为路线导航的一部分创建时，这会通知注入器注入当前`Router`实例。

Internally, the injector determines the dependencies of a class based on the metadata reflected from it when converting TypeScript to ES5 code (done by the TypeScript compiler). The metadata is generated only if we add a decorator, such as `@Component` or `@Pipe`, on the class.

如果我们将[T0]注入另一个类会发生什么？是否使用了相同的`Router`实例？简而言之，答案是肯定的。Angular injector 创建并缓存依赖项以供将来重用，因此这些服务本质上是单例的。

While dependencies in an injector are singleton, at any given time, there can be multiple injectors active throughout an Angular app. You'll learn about the injector hierarchy shortly. With the router, there is another layer of complexity. Since Angular supports the child route concept, each of these child routes has its own router instance. Wait until we cover child routers in the next chapter so that you can understand the intricacies!

让我们创建一个角度服务来跟踪训练历史。此过程将帮助您了解如何使用角度 DI 连接依赖项。



# 跟踪训练历史记录

如果我们能够跟踪我们的训练历史，这将是对我们应用程序的一个很好的补充。我们上次锻炼是什么时候？我们完成了吗？我们花了多少时间？

为了回答这些问题，我们需要跟踪训练开始和结束的时间。然后需要将这些跟踪数据保存到某个地方。

一个可能的解决方案是用所需的功能扩展我们的`WorkoutRunnerComponent`。但这给`WorkoutRunnerComponent`增加了不必要的复杂性，而这不是它的主要工作。

我们需要一个专门的历史跟踪服务来完成这项工作，一个跟踪历史数据并在整个应用程序中共享的服务。让我们开始构建训练历史跟踪服务。



# 构建训练历史跟踪服务

训练历史跟踪服务将跟踪训练进度。该服务还将公开一个接口，允许`WorkoutRunnerComponent`启动和停止训练跟踪。

再次受到*角度风格指南*的启发，我们将创建一个新模块**核心模块**，并向该模块添加服务。应用程序的核心服务可跨应用程序的主机使用。它也是添加应用程序启动时所需的一次性组件的好地方。导航条和忙指示灯就是此类组件的好例子。

在命令行上，导航到`trainer/src/app`文件夹并生成一个新模块：

```ts
ng generate module core --module app
```

这将创建一个新的`CoreModule`模块并将其导入`AppModule`。接下来，再次使用 Angular CLI 在`trainer/src/app/core`文件夹中创建一个新服务：

```ts
ng generate service workout-history-tracker
```

生成的代码非常简单。生成器创建一个新类`WorkoutHistoryTrackerService`（`workout-history-tracker.service.ts`），并在该类上应用`@Injectable`修饰符：

```ts
@Injectable({
  providedIn: 'root'
})
export class WorkoutHistoryTrackerService {
    ...
}
```

`Injectable`上的`providedIn:'root'`属性指示 Angular 使用*根注入器*创建**提供程序**。该提供商的唯一任务是创建`WorkoutHistoryTrackerService`服务，并在 Angular 的 DI 注入器需要时返回该服务。我们创建/使用的任何服务都需要在注入器上注册。正如*提供商*的角度文档所述，

*提供者告诉注入器如何创建服务。如果没有提供者，注入器将不知道自己负责注入服务，也无法创建服务*。

A service in Angular is just a class that has been registered with Angular's DI framework. Nothing special about them!

有时，希望将服务作为模块的一部分包括进来，而不是将其注册到根注入器。在这种情况下，可以在模块级别注册服务。有两种方法可以实现这一点：

*   **选项 1**：引用具有`providedIn`属性的模块：

```ts
@Injectable({
  providedIn: CoreModule
})
export class WorkoutHistoryTrackerService {
```

*   **选项 2**：使用`providers`阵列在模块上注册服务：

```ts
@NgModule({
  providers: [WorkoutHistoryTrackerService],
})
export class CoreModule { }
```

在模块级别注册服务对于延迟加载模块的场景是有利的。

使用`Injectable`（*选项 1*注册服务还有另一个优势。它使 Angular CLI build 能够通过代码绑定执行高级优化，省去任何已声明但从未使用过的服务（称为**树抖动**的过程）。

Irrespective of the two options we use, the service is still registered (via a provider) with the root injector.

除非另有说明，否则我们将使用`Injectable`方法在整本书中注册依赖关系。打开`workout-history-tracker.service.ts`并添加以下实现：

```ts
import { ExercisePlan } from '../workout-runner/model';
import { CoreModule } from './core.module';
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: CoreModule
})
export class WorkoutHistoryTrackerService { 
  private maxHistoryItems = 20;   //Tracking last 20 exercises 
  private currentWorkoutLog: WorkoutLogEntry = null; 
  private workoutHistory: Array<WorkoutLogEntry> = []; 
  private  workoutTracked: boolean;
```

```ts
  constructor() { } 

  get tracking(): boolean { 
    return this. workoutTracked; 
  } 
}

export class WorkoutLogEntry { 
  constructor( 
    public startedOn: Date, 
    public completed: boolean = false, 
    public exercisesDone: number = 0, 
    public lastExercise?: string, 
    public endedOn?: Date) { } 
}
```

定义了两个类：`WorkoutHistoryTrackerService`和`WorkoutLogEntry`。顾名思义，`WorkoutLogEntry`定义了一次训练执行的日志数据。`maxHistoryItems`允许我们配置存储在`workoutHistory`数组中的最大项目数，该数组包含历史数据。`get tracking()`方法在 TypeScript 中为`workoutTracked`定义了一个 getter 属性。在训练执行期间，将`workoutTracked`设置为`true`。

让我们在`WorkoutHistoryTrackerService`中添加开始跟踪、停止跟踪和练习完整功能：

```ts
startTracking() { 
  this.workoutTracked = true; 
  this.currentWorkoutLog = new WorkoutLogEntry(new Date()); 
  if (this.workoutHistory.length >= this.maxHistoryItems) { 
    this.workoutHistory.shift(); 
  } 
    this.workoutHistory.push(this.currentWorkoutLog); 
} 

exerciseComplete(exercise: ExercisePlan) { 
  this.currentWorkoutLog.lastExercise = exercise.exercise.title; 
  ++this.currentWorkoutLog.exercisesDone; 
} 

endTracking(completed: boolean) { 
  this.currentWorkoutLog.completed = completed; 
  this.currentWorkoutLog.endedOn = new Date(); 
  this.currentWorkoutLog = null; 
  this.workoutTracked = false; 
}
```

`startTracking`函数创建一个`WorkoutLogEntry`并将其添加到`workoutHistory`数组中。通过将`currentWorkoutLog`设置为新创建的日志条目，我们可以在稍后的训练执行期间对其进行操作。`endTracking`功能和`exerciseComplete`功能只是改变了`currentWorkoutLog`。`exerciseComplete`功能应在完成作为训练一部分的每个练习时调用。为了节省您的一些按键操作，请完成迄今为止的完整实现代码：[http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts](http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts) 。

服务实现现在还包括获取训练历史数据的功能：

```ts
getHistory(): Array<WorkoutLogEntry> { 
  return this.workoutHistory; 
}
```

完成了`WorkoutHistoryTrackerService`的实施；现在是时候将其融入训练执行中了。



# 与 WorkoutRunnerComponent 集成

`WorkoutRunnerComponent`要求`WorkoutHistoryTrackerService`跟踪训练历史记录；因此，需要满足一个依赖关系。我们已经使用`Injectable`装饰器向 Angular 的 DI 框架注册了`WorkoutHistoryTrackerService`，现在是使用该服务的时候了。



# 使用构造函数注入注入依赖项

消费依赖很容易！*我们经常使用构造函数注入来使用依赖项*。

在顶部添加`import`语句并更新`WorkoutRunnerComponent`构造函数，如下所示：

```ts
import { WorkoutHistoryTrackerService } from '../core/workout-history-tracker.service';
... 
constructor(private router: Router,
    private tracker: WorkoutHistoryTrackerService   
) {
```

与创建`WorkoutRunnerComponent`时的`router,`角度注入`WorkoutHistoryTrackerService`一样。容易的

一旦服务被注入并可供`WorkoutRunnerComponent`使用，则需要在训练开始、训练完成和训练结束时调用服务实例（`tracker`。

将此添加为`start`函数中的第一条语句：

```ts
this.tracker.startTracking();
```

在`startExerciseTimeTracking`函数中，在`clearInterval`调用后添加高亮显示的代码：

```ts
clearInterval(this.exerciseTrackingInterval); 
if (this.currentExercise !== this.restExercise) { this.tracker.exerciseComplete(this.workoutPlan.exercises[this.currentExerciseIndex]); }
```

以及训练中突出显示的代码，以完成相同功能中的`else`条件：

```ts
this.tracker.endTracking(true); 
this.router.navigate(['/finish']); 
```

除了一个案例外，历史跟踪几乎完成。如果用户手动导航离开训练页面怎么办？我们如何停止跟踪？

当这种情况发生时，我们总是可以依靠组件的生命周期挂钩/事件来帮助我们。当`NgOnDestroy`事件触发时，可以停止训练跟踪。执行任何清理工作的适当位置是在将零部件从零部件树中删除之前。让我们做吧。

将此功能及对应的生命周期事件接口添加到`workout-runner.component.ts`：

```ts
export class WorkoutRunnerComponent implements OnInit, OnDestroy {
...
ngOnDestroy() { 
  this.tracker.endTracking(false); 
} 
```

训练历史记录跟踪实施已完成。我们渴望开始训练历史页面/组件实现，但在完成 Angular DI 功能的讨论之前。

Feel free to skip the next section for now if you want to maintain the app-building velocity. Come back to this section with a fresh and relaxed mind. There are some very important core concepts we'll share in the next section.



# 深度依赖注入

首先，我们以`WorkoutHistoryTrackerService`为例，尝试了解我们可以注册依赖项的不同位置。



# 注册依赖项

注册依赖项的标准方法是在根/全局级别注册它。这可以通过将依赖类型传递到`NgModule`装饰器中的`provides`属性（数组）中，或者通过使用`Injectable`服务装饰器上的`providedIn`属性来实现。

还记得我们的`WorkoutHistoryTrackerService`注册吗？检查以下各项：

```ts
@Injectable({
  providedIn: CoreModule
})
export class WorkoutHistoryTrackerService {
```

在模块声明上也可以执行相同的操作，如下所示：

```ts
@NgModule({...providers: [WorkoutHistoryTrackerService],})
```

从技术上讲，当使用上述任何一种机制时，服务都会在**应用程序的根注入器**中注册，而不管它在哪个角度模块中声明。此后，跨模块的任何角度伪影都可以使用该服务（`WorkoutHistoryTrackerService`。根本不需要模块导入。

This behavior is different from component/directive/pipe registration. Such artifacts have to be exported from a module for another module to use them.

*可以注册依赖项的另一个位置是组件*。`@Component`装饰器有一个`providers`数组参数来注册依赖项。对于这两个级别的依赖项注册，我们需要回答的一个明显问题是，使用哪一个？

很明显，如果依赖项仅由组件及其子组件使用，则应该在`@Component`装饰器级别注册。不是真的！在回答这个问题之前，我们还需要了解更多。需要引入一个全新的分层喷油器世界。让我们等待，通过继续讨论提供者来学习注册依赖关系的其他方法。

*提供程序在角度注入器请求时创建依赖关系*。*这些提供者有办法创建这些依赖关系*。虽然类似乎是可以注册的明显依赖项，但我们也可以注册：

*   特定对象/值
*   工厂函数

使用`Injectable`装饰器注册`WorkoutHistoryTrackerService`是最常见的注册模式。但有时我们需要在依赖项注册方面有一些灵活性。要注册对象或工厂函数，我们需要使用`NgModule`上提供的扩展版提供程序注册。

为了了解这些变化，我们需要更详细地研究提供者和依赖项注册。



# 角度提供者

提供者创建由 DI 框架提供服务的依赖项。

请看`NgModule`上的`WorkoutHistoryTrackerService`依赖项注册：

```ts
providers: [WorkoutHistoryTrackerService],
```

此语法是以下版本的简短形式表示法：

```ts
providers:({ provide: WorkoutHistoryTrackerService, useClass: WorkoutHistoryTrackerService })
```

第一个属性（`provide`是一个令牌，用作注册依赖项的密钥。该键还允许我们在依赖项注入期间定位依赖项。

第二个属性（`useClass`是一个*提供者定义对象*，它定义了创建依赖项值的方法。

通过`useClass`，我们正在注册**类提供者**。*类提供程序通过实例化*请求的对象类型来创建依赖项。还有其他一些提供程序类型。



# 价值提供者

*类提供程序*创建类对象并实现依赖关系，但有时我们希望向 DI 提供程序注册特定的对象/原语。**价值提供者**解决此用例。

【使用此技术】注册时，我们会像 T0 一样：

```ts
{provide: WorkoutHistoryTrackerService, useValue: new WorkoutHistoryTrackerService()};
```

*对于值提供者，我们有责任向 DI 提供服务/对象/原语的实例。*

使用*值提供程序*，由于我们是手动创建依赖项，因此如果沿袭中存在依赖项，我们还负责构建任何子依赖项。再以`WorkoutHistoryTrackerService`为例。如果`WorkoutHistoryTrackerService`有一些依赖项，也需要通过手动注入来实现：

```ts
{provide: WorkoutHistoryTrackerService, useValue: new WorkoutHistoryTrackerService(new LocalStorage())});
```

在前面的示例中，我们不仅要创建一个`WorkoutHistoryTrackerService`实例，还要创建一个`LocalStorage`服务实例。对于具有复杂依赖关系图的服务，使用值提供程序设置该服务变得很有挑战性。

Wherever possible, prefer *class provider* over *value provider*.

价值提供者在特定场景中仍然派上用场。例如，我们可以使用值提供程序注册通用应用程序配置：

```ts
{provide: AppConfig, {useValue: {name:'Test App', gridSetting: {...} ...}}
```

或在单元测试时注册模拟依赖项：

```ts
{provide:WorkoutHistoryTrackerService, {useValue: new MockWorkoutHistoryTracker()}
```



# 工厂供应商

有时依赖关系的构建不是一件小事。建设取决于外部因素。这些因素决定了创建和返回哪些对象或类实例。**工厂供应商**做这项繁重的工作。

举个例子，我们希望为开发版本和生产版本提供不同的配置。我们可以很好地使用工厂实现来选择正确的配置：

```ts
{provide: AppConfig, useFactory: () => { 
  if(PRODUCTION) { 
    return {name:'Production App', gridSetting: {...} ...} 
  } 
  else { 
    return {name:'Test App', gridSetting: {...} ...} 
  }
}
```

工厂函数也可以有自己的依赖项。在这种情况下，语法会发生一些变化：

```ts
{provide: WorkoutHistoryTrackerService, useFactory: (environment:Environment) => { 
  if(Environment.isTest) { 
    return new MockWorkoutHistoryTracker(); 
  } 
  else { 
    return new WorkoutHistoryTrackerService(); 
  }, 
    deps:[Environment]
}
```

依赖项作为参数传递给工厂函数，并在提供者定义对象属性`deps`（`Environment`是上例中注入的依赖项）上注册。

如果依赖项的构造很复杂，并且在依赖项连接过程中无法确定所有内容，请使用`UseFactory`提供。

虽然我们有许多选项来声明依赖项，但使用依赖项要简单得多。我们在*使用构造函数注入*部分中看到了构造函数注入的一种方法。



# 使用注入器的显式注入

我们甚至可以使用 Angular 的**注射器服务**进行显式注射。这与用于支持 DI 的喷油器角度相同。下面是如何使用`Injector`注入`WorkoutHistoryTrackerService`服务：

```ts
constructor(private router: Router, private injector:Injector) {
  this.tracker=injector.get(WorkoutHistoryTrackerService);
```

我们注入`Injector`服务，然后显式请求`WorkoutHistoryTrackerService`实例。

什么时候会有人想这样做？嗯，几乎从来没有。避免这种模式，因为它会将 DI 容器暴露给您的实现，并且会增加一些噪音。

我们现在知道如何注册依赖项以及如何使用它，但是 DI 框架如何定位这些依赖项呢？



# 依赖标记

请记住前面显示的依赖项注册的扩展版本：

```ts
{ provide: WorkoutHistoryTrackerService, useClass: WorkoutHistoryTrackerService }
```

`provide`属性值是**令牌**。此令牌用于标识要注入的依赖项。在前面的示例中，我们使用类名或类型来标识依赖关系，因此该标记称为**类标记**。

根据前面的注册，每当 Angular 看到类似于以下的语句时，它都会根据类类型注入正确的依赖项，这里是`WorkoutHistoryTrackerService`：

```ts
constructor(tracker: WorkoutHistoryTrackerService)
```

Angular 也支持一些其他标记。



# 使用 InjectionToken

有时，我们定义的依赖关系是基元、对象或函数。在这种情况下，不能使用类标记，因为没有类。Angular 使用`InjectionToken`（或者**字符串标记**解决了这个问题，我们将在后面看到）。如果没有`AppConfig`类，可以使用字符串标记重写我们之前共享的应用程序配置注册示例。

要使用`InjectionToken`注册依赖项，首先需要创建`InjectionToken`类实例：

```ts
export const APP_CONFIG = new InjectionToken('Application Configuration');
```

然后，使用令牌注册依赖项：

```ts
{ provide: APP_CONFIG, useValue: {name:'Test App', gridSetting: {...} ...});
```

最后，使用`@Inject`装饰器将依赖项注入任何位置：

```ts
constructor(@Inject(APP_CONFIG) config) { }
```

Interestingly, when `@Inject()` is not present, the injector uses the type/class name of the parameter (*class token*) to locate the dependency.



# 使用字符串标记

Angular 还支持**字符串标记**，允许我们使用字符串文本来识别和注入依赖项。前面带有字符串标记的示例变为：

```ts
{ provide: 'appconfig', useValue: {name:'Test App', gridSetting: {...} ...});
...
constructor(@Inject('appconfig') config) { }
```

字符串标记的一个缺点是，您可能会在声明和注入中拼写错误。

呸！这是 Angular 的依赖注入的一个很长的部分，还有很多东西要讨论。现在，让我们回到正轨，添加训练历史页面。



# 添加训练历史记录页面

我们在训练执行期间收集的训练历史数据现在可以在视图中呈现。让我们添加一个`History`组件。该组件将在`/history`位置可用，并可通过单击应用程序标题部分中的链接进行加载。

更新`app.routes.ts`中的路由定义，包括新路由和相关导入：

```ts
import { WorkoutHistoryComponent } from './workout-history/workout-history.component'; 
... 
export const routes: Routes = [ 
  ..., 
 { path: 'history', component: WorkoutHistoryComponent } ,
  { path: '**', redirectTo: '/start' } 
]) 
```

历史记录链接需要添加到应用程序标题部分。让我们将 header 部分重构为它自己的组件。更新`app.component.html`模板，并用以下代码替换`nav`元素：

```ts
<div id="header">
    <abe-header></abe-header>
</div> 
```

`nav`元素移动到一个 header 组件中，我们仍然需要创建它。通过在`trainer/src/app/core`文件夹中运行命令，使用`ng generate`生成新的`HeaderComponent`组件：

```ts
ng generate component header -is
```

此语句创建一个新的头组件，并在核心模块上声明它。接下来，从`checkpoint3.2`Git 分支（GitHub 位置：[更新头组件（`header.component.ts`及其视图（`header.component.html`的定义）http://bit.ly/ng6be-3-2-header](http://bit.ly/ng6be-3-2-header) ）。

虽然我们已经在`app.component.html`中添加了 header 元素，但是 header 组件将不会呈现，除非我们导入核心模块并从核心模块导出组件。Angular CLI 为我们做了第一部分，第二部分将`core.module.ts`更新为：

```ts
imports: [ CommonModule, RouterModule],
declarations: [HeaderComponent],    
exports: [HeaderComponent]
```

如果您查看`HeaderComponent`视图，历史链接现在就在那里。我们必须导入`RouterModule`，因为以下链接是使用`RouterLink`指令生成的，它是`RouterModule`的一部分：

```ts
<a class="nav-link" routerLink="/history" title="Workout History">History</a>
```

让我们通过首先生成组件的样板来添加训练历史组件。从命令行导航到`trainer/src/app`并运行：

```ts
ng generate component workout-history -is
```

`WorkoutHistoryComponent`实现在`checkpoint3.2`Git 分支中提供；文件夹为`workout-history`（GitHub 位置：[http://bit.ly/ng6be-3-2-workout-history](http://bit.ly/ng6be-3-2-workout-history) ）。

至少可以说，`WorkoutHistoryComponent`视图代码很简单：一些角度构造，包括`ngFor`和`ngIf`。组件实现也非常简单。注入`WorkoutHistoryTrackerService`服务依赖项，并在`WorkoutHistoryComponent`初始化时加载历史数据：

```ts
ngOnInit() { 
  this.history = this.tracker.getHistory(); 
}
```

这一次，我们使用`Location`服务而不是`Router`来导航`history`组件：

```ts
goBack() { 
  this.location.back(); 
}
```

位置服务用于与浏览器 URL 交互。根据 URL 策略，URL 路径（如`/start`或`/workout`或 URL 散列段（如`#/start`或`#/workout`）用于跟踪位置更改。路由器服务在内部使用位置服务触发导航。

Router versus Location
While the `Location` service allows us to perform navigation, using `Router` is a preferred way of performing route navigation. We used the location service here because the need was to navigate to the last route without bothering about how to construct the route.

我们已经准备好测试我们的训练历史记录实现。加载起始页并单击历史记录链接。历史记录页面加载了一个空网格。回去，开始一次锻炼，然后让一次锻炼完成。再次查看历史页面；应列出一项训练计划：

![](img/00023.jpeg)

看起来不错！如果我们多次进行训练并建立历史记录列表，我们就会意识到这个列表中有一个痛处。历史数据不按逆时间顺序排序，最新的数据在顶部。另外，如果我们有一些过滤功能，那就太好了。



# 使用管道对历史数据进行排序和筛选

在中*构建了我们的第一个应用程序——7 分钟锻炼*中，我们探索了管道。我们甚至构建了自己的管道，将秒值格式化为 hh:mm:ss。管道的主要用途是转换数据，令人惊讶的是，它们也适用于阵列！对于阵列，管道可以对数据进行排序和筛选。我们创建两个管道，一个用于排序和筛选。

AngularJS has prebuilt filters (filters are pipes in Angular), `orderBy` and `filter`, for this very purpose. Angular does not come with these pipes and there is a good reason. These pipes are prone to poor performance. Learn the rationale behind this decision in the framework documentation on pipes at [http://bit.ly/ng-no-filter-orderby-pipe](http://bit.ly/ng-no-filter-orderby-pipe).

让我们从`orderBy`管道开始。



# orderBy 管道

我们实现的`orderBy`管道将根据对象的任何属性对对象数组进行排序。基于`fieldName`属性按升序对项目进行排序的使用模式为：

```ts
*ngFor="let item of items| orderBy:fieldName"
```

对于按降序排序的项目，使用模式为：

```ts
*ngFor="let item of items| orderBy:-fieldName"
```

记下`fieldName`之前的额外连字符（`-`。

我们计划在一个新的共享模块中添加`OrderByPipe`。您是否在想，为什么不将其添加到核心模块中？按照惯例，核心模块包含全局服务和一次性使用组件。这正是每个应用程序的一个核心模块。另一方面，共享模块具有跨模块共享的组件/指令/管道。这种共享模块也可以在父模块和子模块的多个级别上定义。在这种情况下，我们将在`AppModule`中定义共享模块。

在`trainer/src/app`目录下运行此命令，创建一个新的`SharedModule`模块：

```ts
ng generate module shared --module app
```

在命令行中，导航到`trainer/src/app/shared`文件夹并生成 order by pipe 样板文件：

```ts
ng generate pipe order-by
```

打开`order-by.pipe.ts`并从 checkpoint3.2 代码更新定义（GitHub 位置：[http://bit.ly/ng6be-3-2-order-by-pipe [T2]。虽然我们不打算深入探讨管道的实现细节，但需要强调一些相关部分。请看此管道轮廓：](http://bit.ly/ng6be-3-2-order-by-pipe)

```ts
@Pipe({ name: 'orderBy' }) 
export class OrderByPipe {
  transform(value: Array<any>, field:string): any { 
   ... 
  } 
}
```

前面的`field`变量接收需要排序的字段。如果字段有一个`-`前缀，我们将在按降序排序数组之前截断前缀。

The pipe also uses the spread operator, `[...]`, which may be new to you. Learn more about the spread operator on MDN at [http://bit.ly/js-spread](http://bit.ly/js-spread).

要使用`OrderByPipe`，请更新训练历史记录的模板视图：

```ts
<tr *ngFor="let historyItem of history|orderBy:'-startedOn'; let i = index"> 
```

同样，我们需要从共享模块导出管道，以允许`WorkoutHistoryComponent`使用它。在`SharedModule`上添加一个 exports 属性并将其设置为`OrderByPipe`：

```ts
declarations:[...],
exports:[OrderByPipe]
```

历史数据现在将在`startedOn`字段中按降序排序。

Make note of the single quotes around the pipe parameter (`'-startedOn'`). We are passing a literal string to the `orderBy` pipe. Pipe parameters support data binding and can be bound to component properties too.

这对管道来说已经足够了。让我们实现过滤。



# 使用搜索管道链接管道

我们首先从`trainer/src/app/shared`文件夹中运行以下命令来创建搜索管道样板文件：

```ts
ng generate pipe search
```

现在可以从 checkpoint3.2 复制实现（GitHub 位置：[http://bit.ly/ng6be-3-2-search-pipe [T2]。`SearchPipe`进行基本的基于等式的过滤。没什么特别的。](http://bit.ly/ng6be-3-2-search-pipe)

看看管道代码；管道有两个参数，第一个是要搜索的字段，第二个是要搜索的值。我们使用 JavaScript 数组的`filter`函数过滤记录，进行严格的平等性检查。想知道`Pipe`装饰器上的`pure`属性吗？这将是下一节讨论的主题。

让我们更新“训练历史记录”视图并合并搜索管道。打开`workout-history.component.html`并用单选按钮取消对 div 的注释。这些单选按钮根据训练是否完成过滤训练。这是 HTML 筛选器选择的外观：

```ts
<label><input type="radio" name="searchFilter" value=""  
    (change)="completed = null" checked="">All </label> 
<label><input type="radio" name="searchFilter" value="true"  
    (change)="completed = $event.target.value=='true'"> Completed </label> 
<label><input type="radio" name="searchFilter" value="false"  
    (change)="completed = $event.target.value=='true'"> Incomplete </label> 
```

我们定义了三个过滤器：`all`、`completed`和`incomplete`训练。无线电选择使用`change`事件表达式设置组件的`completed`属性。`$event.target`是单击的单选按钮。

[T0]管道现在可以添加到[T1]指令表达式中。我们将把`search`和`orderBy`管道连接起来。将`ngFor`表达式更新为：

```ts
<tr *ngFor="let historyItem of history |search:'completed':completed |orderBy:'-startedOn';  
    let i = index">
```

Angular 的管道链接功能的一个很好的例子！

正如我们对`OrderByPipe`所做的那样，`SearchPipe`也需要在使用之前从共享模块中导出。

`search`管道首先过滤历史数据，然后`orderBy`管道对其重新排序。请密切注意`search`管道参数：第一个参数是表示要搜索的字段的字符串文字（`historyItem.completed`，而第二个参数是从组件的`completed`属性派生的。能够将管道参数绑定到组件属性使我们具有极大的灵活性。

继续并验证历史记录页面的搜索功能。根据收音机的选择，历史记录会被过滤，当然，它们会根据训练开始日期按逆时间顺序排序。

虽然数组中的管道使用看起来很简单，但如果我们不了解何时对管道进行评估，可能会引起一些意外。



# 管道与数组

为了理解应用于阵列的管道的问题，让我们重现这个问题。

打开`search.pipe.ts`并移除`@Pipe`装饰者的`pure`属性。此外，请接受以下陈述：

```ts
if (searchTerm == null) return [...value];
```

并将其改为：

```ts
if (searchTerm == null) return [value];
```

在单选列表的末尾（在`workout-history.component.html`中）添加一个按钮，该按钮将新的日志条目添加到`history`数组中：

```ts
<button (click)="addLog()">Add Log</button>
```

向`WorkoutHistoryComponent`添加一个函数：

```ts
addLog() { 
  this.history.push(Object.assign({}, this.history[this.history.length-1])); 
}
```

前面的函数复制第一个历史记录项并将其添加回`history`数组。如果我们加载页面并单击按钮，一个新的日志条目将添加到历史记录数组中，但除非我们更改过滤器（通过单击其他收音机），否则它不会显示在视图中。有趣的

Before calling `addLog` make sure at least one history log is already there; otherwise the `addLog` function will fail.

到目前为止，我们建造的管道本质上是**无状态**（也称**纯**。它们只是将输入数据转换为输出数据。仅当管道输入更改（管道符号左侧的表达式）或任何管道参数更新时，才会重新计算无状态的**管道**。

对于数组，这在数组赋值/引用更改时发生，而不是在添加或删除元素时发生。切换过滤条件会起作用，因为它会导致搜索管道在搜索参数（`completed`状态）更改时再次求值。这种行为值得注意。

有什么办法？首先，我们可以使历史数组不可变，这意味着它一旦创建就不能更改。要添加新元素，我们需要使用新值创建一个新数组，如：

```ts
this.history = [...this.history,  Object.assign({}, this.history[0])];
```

这是完美的，但我们正在改变我们的实现，使其与管道一起工作，这是不正确的。相反，我们可以更换管道。管道应标记为有状态。

无状态管道和有状态管道之间的区别在于，每当框架执行更改检测运行时，都会通过 Angular 对有状态管道进行评估，这涉及检查整个应用程序的更改。因此，对于有状态管道，检查不限于管道输入/参数更改。

要使`search`管道无状态，只需恢复我们所做的第一个更改，并在`Pipe`装饰器上添加`pure: false`：

```ts
@Pipe({ 
  name: 'search', 
 pure:false 
}) 
```

还是不行！[T0]管道还有一个怪癖需要修复。“全部收音机”选项无法正常工作。添加一个新的训练日志，它仍然不会显示，除非我们切换过滤器。

这里的修复方法是恢复第二个更改。在`search`管道中隔离该管线：

```ts
if (searchTerm == null) return value;
```

并将其更改为以下内容：

```ts
if (searchTerm == null) return [...value];
```

我们更改了`if`条件，每次都返回一个新数组（使用扩展操作符），即使`searchTerm`是`null`。如果返回相同的数组引用，Angular 不会检查数组中的大小更改，因此不会更新 UI。

这就完成了历史页面的实现。您现在可能想知道，管道上的最后几次修复与更改检测的工作原理有什么关系。或者您可能想知道什么是更改检测。让我们消除所有这些疑虑，向大家介绍*Angular 的变化检测系统*。

Angular's change detection will be covered extensively in , *Some Practical Scenarios*. The aim of the next section is to introduce the concept of change detection and how Angular performs this process.



# 角度变化检测概述

简而言之，更改检测就是跟踪在应用程序执行期间对组件模型所做的更改。这有助于 Angular 的数据绑定基础结构确定需要更新视图的哪些部分。每个数据绑定框架都需要解决这个问题，而这些框架用于跟踪更改的方法各不相同。它甚至不同于 AngularJS 和 AngularJS。

为了理解角度变化检测是如何工作的，我们需要记住一些事情。

*   Angular 应用程序只是从根到叶的组件层次结构。
*   绑定到视图的组件属性没有什么特别之处；因此，Angular 需要一种有效的机制来了解这些特性何时发生变化。它无法继续轮询这些属性中的更改。

*   为了检测属性值的变化，Angular 在前一个值和当前值之间进行*严格比较*（`===`。对于引用类型，这意味着只比较引用。没有进行深入的比较。

For precisely this reason, we had to mark our search pipe as stateful. Adding elements to an existing array does not change the array reference and hence Angular fails to detect any change in the array. Once the pipe is marked as stateful, the pipe is evaluated, irrespective of whether the array has changed or not.

由于 Angular 无法知道何时自动更新任何绑定属性，因此它会在触发更改检测运行时检查每个绑定属性。从组件树的根开始，Angular 在组件层次结构中检查每个绑定属性的更改。如果检测到更改，则该组件将标记为刷新。值得重申的是，绑定属性中的更改不会立即更新视图。相反，更改检测运行分两个阶段进行。

*   在*第一阶段*中，它进行组件树遍历，并标记由于模型更新而需要刷新的组件
*   在*第二阶段*中，实际视图与底层模型同步

Model changes and view updates are never interleaved during a change-detection run.

我们现在只需要回答另外两个问题：

*   何时触发更改检测运行？
*   它运行了多少次？

触发以下任一事件时，将触发角度变化检测运行：

*   **用户输入/浏览器事件**：我们点击一个按钮，输入一些文本，滚动内容。每个操作都可以更新视图（和基础模型）。
*   **远程 XHR 请求**：这是视图更新的另一个常见原因。例如，从远程服务器获取数据以在网格上显示，以及获取用户数据以呈现视图。
*   **setTimeout 和 setInterval**：事实证明，我们可以使用`setTimeout`和`setInterval`以特定的间隔异步执行一些代码。这样的代码也可以更新模型。例如，`setInterval`计时器可以定期检查股票报价，并在 UI 上更新股票价格。

要回答多少次，**是一个**。从根组件到树叶，每个组件模型只检查一次，检查方式为自上而下。

The last statement is true when Angular is configured to run in production mode. In development mode, the component tree is traversed twice for changes. Angular expects the model to be stable after the first tree walk. If that is not the case, Angular throws an error in development mode, and ignores the changes in production mode. We can enable the production mode by invoking the `enableProdMode` function before the `bootstrap` function call.

现在是时候选择另一个与 Angular 的依赖性注入相关的主题了。**分层喷射器**的概念将是我们下一个讨论的主题。这是一个非常强大的功能，当我们使用 Angular 构建更大更好的应用程序时，它可以派上用场。



# 分层喷油器

Angular 的依赖项注入设置中的**注入器**是一个容器，负责存储依赖项并在请求时分发它们。前面共享的提供者注册示例实际上是向全局注入器注册依赖项。



# 注册组件级依赖项

到目前为止，我们所做的所有依赖项注册都是在一个模块上完成的。Angular 更进一步，允许在组件级别注册依赖项。`@Component`装饰器上有一个类似的`providers`属性，允许我们在组件级别注册依赖关系。

我们本可以很好地注册`WorkoutHistoryTrackerService`对`WorkoutRunnerComponent`的依赖关系。大致如下：

```ts
@Component({ 
  selector: 'abe-workout-runner', 
  providers: [WorkoutHistoryTrackerService] 
  ...
})
```

但我们是否应该这样做是我们在这里讨论的问题。

在关于分层喷油器的讨论中，重要的是要理解 Angular 为每个组件创建了一个喷油器（过于简化）。在组件级别完成的依赖项注册在组件及其子体上可用。

我们还了解到依赖关系本质上是单例的。一旦创建，喷油器每次都将返回相同的依赖关系。此功能从训练历史记录实现中可以明显看出。

`WorkoutHistoryTrackerService`在`CoreModule`中注册，然后注入两种成分：`WorkoutRunnerComponent`和`WorkoutHistoryComponent`。两个组件获得相同的`WorkoutHistoryTrackerService`实例。下一个图表突出显示了此注册和注入：

![](img/00024.jpeg)

要确认，只需在`WorkoutHistoryTrackerService`构造函数中添加一条`console.log`语句：

```ts
console.log("WorkoutHistoryTrackerService instance created.")
```

刷新应用程序并通过单击标题链接打开历史记录页面。无论我们运行训练或打开历史记录页面多少次，都会生成一次消息日志。

这也是一种新的交互/数据流模式！

深思熟虑；正在使用服务在两个组件之间共享状态。`WorkoutRunnerComponent`正在生成数据，而`WorkoutHistoryComponent`正在使用数据。没有任何相互依赖。我们正在利用依赖关系本质上是单态的这一事实。此数据共享/交互/数据流模式可用于在任意数量的组件之间共享状态。事实上，这是我们武库中非常强大的武器。下次需要在不相关的组件之间共享状态时，请考虑服务。

但这一切与分层喷射器有什么关系？好吧，我们不要拐弯抹角了；让我们直截了当地说吧。

虽然向注入器注册的依赖项是单例的，但[T0]本身不是！在任何给定的时间点，应用中都有多个喷油器处于活动状态。事实上，喷油器是在与零部件树相同的层次结构中创建的。Angular 为组件树中的每个组件创建一个`Injector`实例（过于简化；请参见下一个信息框）。

Angular does not literally create an injector for each component. As explained in the Angular developer guide: every component doesn't need its own injector and it would be horribly inefficient to create masses of injectors for no good purpose. But it is true that every component has an injector (even if it shares that injector with another component) and there may be many different injector instances operating at different levels of the component tree. It is useful to pretend that every component has its own injector.

运行训练时，部件和喷油器树的形状如下所示：

![](img/00025.jpeg)

“插入”文本框表示组件名称。**根注入器**是作为应用程序引导过程的一部分创建的注入器。

此喷油器层次结构的意义是什么？为了理解其含义，我们需要了解当组件请求依赖项时会发生什么。



# 角度依赖行走

无论何时请求依赖项，Angular 都会首先尝试满足组件自身注入器的依赖项。如果找不到请求的依赖项，它会向父组件注入器查询依赖项，如果探测再次失败，则向父组件注入器查询，依此类推，直到找到依赖项或到达根注入器。要点：任何依赖项搜索都是基于层次结构的。

早些时候，当我们注册`WorkoutHistoryTrackerService`时，它是在根注入器中注册的。来自`WorkoutRunnerComponent`和`WorkoutHistoryComponent`的`WorkoutHistoryTrackerService`依赖请求由根注入器满足，而不是由它们自己的组件注入器满足。

这种分层喷油器结构带来了很大的灵活性。我们可以在不同的组件级别配置不同的提供程序，并覆盖子组件中的父提供程序配置。这仅适用于在组件上注册的依赖项。如果将依赖项添加到模块，它将在根注入器上注册。

此外，如果在组件级别注册了依赖项，则其生命周期将绑定到组件的生命周期。每次加载组件时都会创建依赖项，在销毁组件时会销毁依赖项。与只创建一次的模块级依赖项不同：第一次请求时。

让我们尝试在使用全局`WorkoutHistoryTrackerService`服务的组件中覆盖该服务，以了解在此类覆盖上发生的情况。这将是有趣的，我们将学到很多！

打开`workout-runner.component.ts`并向`@Component`装饰符添加`providers`属性：

```ts
providers: [WorkoutHistoryTrackerService]
```

在`workout-history.component.ts`中也这样做。现在，如果我们刷新应用程序，开始训练，然后加载历史记录页面，网格是空的。无论我们何时尝试进行训练，历史记录网格始终为空。

原因很明显。在每个`WorkoutRunnerComponent`和`WorkoutHistoryComponent`上设置`WorkoutHistoryTrackerService`提供程序后，依赖关系由各自的组件注入器自己完成。两个组件注入器在请求时都创建自己的`WorkoutHistoryTrackerService`实例，因此历史记录跟踪被中断。查看下图，了解在这两种情况下如何满足请求：

![](img/00026.jpeg)

一个简单的问题：如果我们在根组件`TrainerAppComponent`中注册依赖项，而不是在模块上注册依赖项，会发生什么？大概是这样的：

```ts
@Component({ 
  selector: 'abe-root', 
 providers:[WorkoutHistoryTrackerService] 
} 
export class AppComponent { 
```

有趣的是，在这种设置下，事情也能完美地工作。这很明显；`TrainerAppComponent`是`RouterOutlet`的父组件，内部加载`WorkoutRunnerComponent`和`WorkoutHistoryComponent`。因此，在这样的设置中，`TrainerAppComponent`注入器满足依赖性。

Dependency lookup up on the component hierarchy can be manipulated if an intermediate component has declared itself as a host component. We will learn more about it in later chapters.

分层注入器允许我们在组件级别注册依赖项，避免了全局注册所有依赖项的需要。

此功能的主要用例是在构建角度库组件时。这些组件可以注册它们自己的依赖项，而无需库的使用者注册库特定的依赖项。

Remember: if you are having trouble loading the right service/dependency, make sure you check the component hierarchy for overrides done at any level.

现在我们了解了依赖项解析在组件中的工作原理。但是，如果一个服务具有依赖性，会发生什么呢？还有更多未知领域有待探索。让我们进一步扩展我们的应用程序。

Remove any `provider` registration done on components before continuing further.



# 带有@Injectable 的依赖项注入

`WorkoutHistoryTrackerService`有一个根本性的缺陷：历史没有持续。刷新应用程序，历史记录将丢失。我们需要添加持久性逻辑来存储历史数据。为了避免任何复杂的设置，我们将使用浏览器本地存储来存储历史数据。

通过从`trainer/src/app/core`文件夹调用此 CLI 命令，添加新的`LocalStorageService`服务：

```ts
ng generate service local-storage
```

将以下两个函数复制到生成的类中，或者从`checkpoint3.2`GitHub 分支复制它们：

```ts
getItem<T>(key: string): T {
    if (localStorage[key]) {
      return <T>JSON.parse(localStorage[key]);
    }
    return null;
}

setItem(key: string, item: any) {
    localStorage[key] = JSON.stringify(item);
}
```

浏览器`localStorage`对象上的简单包装。

与任何其他依赖项一样，通过必要的导入将其注入到`WorkoutHistoryTrackerService`构造函数（即`workout-history-tracker.ts`文件）：

```ts
import {LocalStorage} from './local-storage'; 
... 
constructor(private storage: LocalStorageService) {
```

建议应用服务上的默认`Injectable`修饰符，即使我们注册了对模块的依赖（`NgModule`提供程序注册语法）。特别是当服务本身具有依赖性时，就像前面的例子`WorkoutHistoryTrackerService`一样。在使用基于模块的服务注册时，不要使用`Injectable`的`providedIn`decorator 属性。

通过加入`@Injectable`修饰符，我们强制 TypeScript transpiler 为`WorkoutHistoryTrackerService`类生成元数据。这包括有关构造函数参数的详细信息。Angular DI 使用生成的元数据来确定服务具有的依赖关系的类型，并且在将来，它在创建服务时满足这些依赖关系。

那么使用[T1]的[T0]呢？`@Injectable`我们还没有用过。我们不需要。任何装饰器都可以工作，并且已经有一个`@Component`装饰器应用于所有组件。

`LocalStorage`服务与`WorkoutHistoryTrackerService`之间的实际集成是一个平凡的过程。

更新`WorkoutHistoryTrackerService`的构造函数如下：

```ts
constructor(private storage: LocalStorage) { 
   this.workoutHistory = (storage.getItem<Array<WorkoutLogEntry>>(this.storageKey) || [])
      .map((item: WorkoutLogEntry) => {
        item.startedOn = new Date(item.startedOn.toString());
        item.endedOn = item.endedOn == null ? null : new Date(item.endedOn.toString());
        return item;
      }); 
} 
```

并为`storageKey`添加声明：

```ts
private storageKey = 'workouts';
```

构造函数从本地存储加载训练日志。`map`函数调用是必需的，因为`localStorage`中存储的所有内容都是字符串。因此，在反序列化时，我们需要将字符串转换回日期值。

在`startTracking`、`exerciseComplete`和`endTracking`函数中最后添加此语句：

```ts
this.storage.setItem(this.storageKey, this.workoutHistory);
```

每次历史数据更改时，我们都会将训练历史保存到本地存储器中。

就这样！我们在`localStorage`上建立了训练历史跟踪。核实一下！

在我们继续讨论我们的大项目“音频支持”之前，有几个小问题需要解决，以获得更好的用户体验。第一个与历史链接有关。



# 使用路由器服务跟踪路由更改

`Header`组件中的“历史记录”链接对于所有路线都是可见的，但训练正在进行时除外。我们不想因为不小心点击历史链接而失去正在进行的训练。此外，在进行锻炼时，没有人对了解锻炼历史感兴趣。

解决方法很简单。我们只需要确定当前路线是否为训练路线并隐藏链接。`Router`服务将帮助我们完成这项工作。

打开`header.component.ts`并查看突出显示的实现：

```ts
import { Router, NavigationEnd } from '@angular/router';
import 'rxjs/add/operator/filter'; ... 
export class HeaderComponent { 
  private showHistoryLink= true; 
  constructor(private router: Router) { 
    this.router.events.pipe( 
 filter(e => e instanceof NavigationEnd))
 .subscribe((e: NavigationEnd) => {
 this.showHistoryLink = !e.url.startsWith('/workout');
 }); 
  } 
```

`showHistoryLink`属性绑定到视图并决定是否向用户显示历史链接。在构造函数中，我们注入`Router`服务，并使用`subscribe`函数订阅可观察的`events`。

我们将在本章后面了解更多关于可观测的信息，但现在，了解可观测是引发事件并可以订阅的对象就足够了。由于路由器在组件的整个生命周期中引发了大量事件，`filter`操作符允许我们过滤我们感兴趣的事件，`subscribe`函数注册一个回调函数，该函数在每次路由更改时调用。

要了解其他路由器事件，包括`NavigationStart`、`NavigationEnd`、`NavigationCancel`和`NavigationError`，请查看路由器文档（[http://bit.ly/ng-router-events](http://bit.ly/ng-router-events) 了解事件何时发生。

回调实现只是根据当前路由 URL 切换`showHistoryLink`状态。要在视图中使用`showHistoryLink`，只需将带有锚定标记的标题模板行更新为：

```ts
<li *ngIf="showHistoryLink"><a routerLink="/history" ...>...</a></li>
```

就这样！“训练”页面上不会显示“历史记录”链接。

If you are having a problem with running the code, look at the `checkpoint3.2` Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of `checkpoint3.2` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-2](http://bit.ly/ng6be-checkpoint-3-2). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.

另一个修复/增强功能与训练页面上的视频面板有关。



# 修复视频播放体验

当前的视频面板实现最多可以被称为业余。默认播放器的大小很小。播放视频时，训练不会暂停。视频播放在练习转换时中断。此外，整体视频负荷体验在每次训练开始时都会增加明显的滞后。这清楚地表明，这种视频播放方法需要一些修正。

这是我们将要做的来修复视频面板：

*   显示练习视频的图像缩略图，而不是加载视频播放器本身
*   当用户单击缩略图时，加载一个带有较大视频播放器的弹出/对话框，可以播放所选视频
*   视频播放打开时暂停训练

让我们继续工作吧！



# 使用视频缩略图

用以下代码片段替换`video-player.component.html`中的`ngFor`HTML 模板：

```ts
<div *ngFor="let video of videos" class="row">
      <div class="col-sm-12 p-2">
        <img class="video-image" [src]="'//i.ytimg.com/vi/'+video+'/hqdefault.jpg'" />
      </div>
</div> 
```

我们已经放弃了 iframe，而是加载了视频的缩略图（检查[T0]标记）。此处显示的所有其他内容均用于设置图像样式。

We have referenced the Stack Overflow post ([http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)) to determine the thumbnail image URL for our videos.

开始新的锻炼；图像应该会显示，但播放功能已中断。我们需要添加一个视频播放对话框。



# 使用 ngx modialog 库

为了在对话框中显示视频，我们将加入一个第三方库**ngx modialog**，可在 GitHub 的[上获得 http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog) 。让我们安装并配置库。

从命令行（在`trainer`文件夹内）运行以下命令以安装库：

```ts
npm i ngx-modialog@5.0.0 --save
```

Work on an Angular v6-compatible `ngx-modialog` library is in progress ([https://github.com/shlomiassaf/ngx-modialog/issues/426](https://github.com/shlomiassaf/ngx-modialog/issues/426)). To use the version 5 library, which is dependent on older version of RxJS, install the `rxjs-compat` package from command line, `npm i rxjs-compat --save`, before proceeding.

接下来在核心模块中导入并配置库。打开`core.module.ts`并添加突出显示的配置：

```ts
import { RouterModule } from '@angular/router';
import { ModalModule } from 'ngx-modialog';
import { BootstrapModalModule } from 'ngx-modialog/plugins/bootstrap';
...
imports: [
   ...
 ModalModule.forRoot(),
 BootstrapModalModule
  ],
```

图书馆现在可以使用了。

尽管*ngx modialog*为标准对话框提供了许多预定义的模板，如警报、提示和确认，但这些对话框在外观方面几乎没有提供定制。为了更好地控制对话框 UI，我们需要创建一个自定义对话框，感谢库所支持。



# 创建自定义对话框

`ngx-modialog`中的自定义对话框只不过是包含了一些特殊库结构的角度组件。

让我们首先构建一个视频对话框组件，在弹出对话框中显示 YouTube 视频。导航到`trainer/src/app/workout-runner/video-player`并运行以下命令，生成组件的样板文件：

```ts
ng generate component video-dialog -is
```

从`checkpoint3.3`Git 分支中的`workout-runner/video-player/video-dialog`文件夹复制视频对话框实现（GitHub 位置：[http://bit.ly/ng6be-3-3-video-dialog](http://bit.ly/ng6be-3-3-video-dialog) ）进入您的本地设置。您需要更新组件实现和视图。

接下来，更新`workout-runner.module.ts`并向模块装饰器添加一个新的`entryComponents`属性：

```ts
...
declarations: [..., VideoDialogComponent], 
entryComponents:[VideoDialogComponent] 
```

新创建的`VideoDialogComponent`需要添加到`entryComponents`，因为它在组件树中没有明确使用。

`VideoDialogComponent`是一个标准的角度组件，具有一些模态对话框和我们稍后描述的具体实现。已创建在`VideoDialogComponent`内声明的`VideoDialogContext`类，以将点击的 YouTube 视频的`videoId`传递给对话框实例。库使用此上下文类在调用代码和模式对话框之间传递数据。`VideoDialogContext`类继承了一个配置类，对话框库使用该配置类从`BSModalContext`更改模态对话框的行为和 UI。

为了更好地了解`VideoDialogContext`是如何被利用的，当点击视频图像时，让我们从训练跑步者那里调用前面的对话框。

更新`video-player.component.html`中的`ngFor`div 并添加`click`事件处理程序：

```ts
<div *ngFor="let video of videos" (click)="playVideo(video)"     ...> 
```

前面的处理程序调用`playVideo`方法，传入单击的视频。`playVideo`功能依次打开相应的视频对话框。将`playVideo`实现添加到`video-player.component.ts`中，如下所示：

```ts
import { Modal } from 'ngx-modialog/plugins/bootstrap';
import { VideoDialogComponent, VideoDialogContext } from './video-dialog/video-dialog.component';
import { overlayConfigFactory } from 'ngx-modialog';
... 
export class VideoPlayerComponent { 
      @Input() videos: Array<string>;
```

```ts

constructor(private modal: Modal) { } playVideo(videoId: string) { this.modal.open(VideoDialogComponent, 
                            overlayConfigFactory(new VideoDialogContext(videoId))); }
}
```

`VideoDialogContext`类中`VideoDialogContext`的【打开】函数调用`VideoDialogContext`类中的【打开】函数。在继续之前，删除`ngOnChange`函数和接口声明。

回到`VideoDialogComponent`实现，组件实现了模态库所需的`ModalComponent<VideoDialogContext>`接口。看看对话框的上下文（`VideoDialogContext`是如何传递给构造函数的，以及我们是如何从上下文中提取和分配`videoId`属性的。然后将[T4]属性绑定到模板视图（参见 HTML 模板）并呈现 YouTube 播放器。

我们可以走了。加载应用程序并开始训练。然后单击任何训练视频图像。视频对话框应该加载，现在我们可以观看视频了！

在我们调用对话框实现完成之前，有一个小问题需要解决。当对话框打开时，训练应该暂停：目前没有。我们将在下一节末尾使用 Angular 的事件基础设施帮助您修复它。

If you are having a problem with running the code, look at the `checkpoint3.3` Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of `checkpoint3.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-3](http://bit.ly/ng6be-checkpoint-3-3). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.

在结束应用程序并使用 Angular 构建新功能之前，我们计划在*7 分钟训练*中添加最后一个功能：音频支持。它也教给我们一些新的跨组件通信模式。



# 使用角度事件的跨组件通信

在学习 Angular 的绑定基础架构时，我们在上一章中讨论了事件。现在是时候更深入地研究事件了。让我们为*7 分钟训练*添加音频支持。



# 用音频跟踪训练进度

对于*7 分钟锻炼*应用程序，添加声音支持至关重要。不停地盯着屏幕看是不能运动的。音频提示可以帮助用户有效地执行训练，因为他们只需按照音频说明操作即可。

下面是我们将如何使用音频线索支持练习跟踪：

*   一个滴答作响的时钟在练习过程中记录了进度
*   半路指示器发出声音，表示练习已进行了一半
*   当练习即将结束时，将播放练习完成音频剪辑
*   在休息阶段播放音频剪辑，并通知用户下一个练习

每个场景都会有一个音频剪辑。

现代浏览器对音频有很好的支持。HTML5`<audio>`标记提供了一种将音频剪辑嵌入 HTML 内容的机制。我们也将使用`<audio>`标签播放我们的剪辑。

由于计划使用 HTML`<audio>`元素，我们需要创建一个包装器指令，允许我们从角度控制音频元素。请记住，指令是没有视图的 HTML 扩展。

The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the audio files used for playback; copy them first. If you are not using Git, a snapshot of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4). Download and unzip the contents and copy the audio files.



# 构建角度指令以包装 HTML 音频

如果您经常使用 JavaScript 和 jQuery，您可能已经意识到我们有意避免直接访问任何组件实现的 DOM。没有必要这样做。角度数据绑定基础设施，包括属性、属性和事件绑定，帮助我们在不接触 DOM 的情况下操作 HTML。

对于音频元素，访问模式也应该是有角度的。在 Angular 中，直接 DOM 操作唯一可以接受和实践的地方是内部指令。让我们创建一个指令来包装对音频元素的访问。

导航到`trainer/src/app/shared`并运行此命令生成模板指令：

```ts
ng generate directive my-audio
```

Since it is the first time we are creating a directive, we encourage you to look at the generated code.

由于该指令已添加到共享模块，因此也需要将其导出。在`exports`数组（`shared.module.ts`中也添加`MyAudioDirective`引用。然后使用以下代码更新指令定义：

```ts
    import {Directive, ElementRef} from '@angular/core'; 

    @Directive({ 
      selector: 'audio', 
      exportAs: 'MyAudio' 
    }) 
    export class MyAudioDirective { 
      private audioPlayer: HTMLAudioElement; 
      constructor(element: ElementRef) { 
        this.audioPlayer = element.nativeElement; 
      } 
    } 
```

`MyAudioDirective`类用`@Directive`装饰。`@Directive`装饰器与`@Component`装饰器相似，只是我们不能附带视图。因此，不允许使用`template`或`templateUrl`！

前面的[T0]属性允许框架识别在何处应用该指令。我们已将生成的`[abeMyAudioDirective]`属性选择器替换为`audio`。使用`audio`作为选择器，我们将为 HTML 中使用的每个`<audio>`标记加载指令。新选择器用作图元选择器。

In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for the generated code), which helps us identify where the directive has been applied. We deviate from this norm and use an element selector for the `MyAudioDirective` directive. We want this directive to be loaded for every audio element, and it becomes cumbersome to go to each audio declaration and add a directive-specific attribute. Hence an element selector.

当我们在视图模板中使用此指令时，`exportAs`的使用变得很清楚。

构造函数中注入的`ElementRef`对象是为其加载指令的角度元素（本例中为`audio`。Angular 在编译和执行 HTML 模板时为每个组件和指令创建`ElementRef`实例。当在构造函数中请求时，DI 框架会定位相应的`ElementRef`，并注入它。我们使用`ElementRef`获取代码中的底层音频元素（实例`HTMLAudioElement`。`audioPlayer`属性保存此引用。

该指令现在需要公开一个 API 来操作音频播放器。将这些功能添加到`MyAudioDirective`指令中：

```ts
    stop() { 
      this.audioPlayer.pause(); 
    }

    start() { 
      this.audioPlayer.play();
    }
    get currentTime(): number { 
      return this.audioPlayer.currentTime; 
    }

    get duration(): number { 
      return this.audioPlayer.duration; 
    }

    get playbackComplete() { 
      return this.duration == this.currentTime; 
    }
```

`MyAudioDirective`API 有两个函数（`start`和`stop`）和三个 getter（`currentTime`、`duration`和一个名为`playbackComplete`的布尔属性）。这些函数和属性的实现只是包装音频元素函数。

Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).

为了了解如何使用音频指令，让我们创建一个新的组件来管理音频播放。



# 创建用于音频支持的 WorkUtaudioComponent

如果我们回头看一下所需的音频提示，有四个不同的音频提示，因此我们将创建一个包含五个嵌入的`<audio>`标记的组件（两个音频标记一起用于下一个音频）。

从命令行转到`trainer/src/app/workout-runner`文件夹，并使用 Angular CLI 添加新的`WorkoutAudioComponent`组件。

打开`workout-audio.component.html`并用此 HTML 片段替换现有视图模板：

```ts
<audio #ticks="MyAudio" loop src="/img/audio/tick10s.mp3"></audio>
<audio #nextUp="MyAudio" src="/img/audio/nextup.mp3"></audio>
<audio #nextUpExercise="MyAudio" [src]="'/img/audio/' + nextupSound"></audio>
<audio #halfway="MyAudio" src="/img/audio/15seconds.wav"></audio>
<audio #aboutToComplete="MyAudio" src="/img/audio/321.wav"></audio> 
```

共有五个`<audio>`标签，以下各一个：

*   **滴答声音频**：第一个音频标签产生滴答声，并在训练开始后立即启动。
*   **下一个音频和练习音频**：下两个音频标签一起工作。第一个标签产生“下一个”声音。实际的练习音频由第三个标记处理（在前面的代码段中）。
*   **中途音频**：第四个音频标签在练习中途播放。

*   **即将完成音频**：最后一个音频标签播放一段，表示完成一个练习。

您是否注意到在每个`audio`标记中使用了`#`符号？有一些前缀为[T2]的变量赋值。在角度世界中，这些变量称为**模板参考变量**或有时称为**模板变量**。

正如《平台指南》所定义的：

模板引用变量通常是对模板中 DOM 元素或指令的引用。

Don't confuse them with the template input variables that we have used with the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template input variable's** (`video` in this case) scope is within the HTML fragment it is declared, whereas the template reference variable can be accessed across the entire template.

请看`MyAudioDirective`定义的最后一节。`exportAs`元数据设置为`MyAudio`。我们在为每个音频标签分配`template reference variable`时重复相同的`MyAudio`字符串：

```ts
#ticks="MyAudio"
```

`exportAs`的作用是定义可在视图中用于将此指令分配给变量的名称。请记住，单个元素/组件可以应用多个指令。`exportAs`允许我们根据 equals 右侧的内容选择应分配给模板参考变量的指令。

通常，模板变量一旦声明，就可以访问它们所附加到的视图元素/组件以及视图的其他部分，这一点我们将在稍后讨论。但在我们的例子中，我们将使用模板变量引用父组件代码中的多个`MyAudioDirective`。让我们了解如何使用它们。

使用以下大纲更新生成的`workout-audio.compnent.ts`：

```ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { MyAudioDirective } from '../../shared/my-audio.directive';

@Component({
 ...
})
export class WorkoutAudioComponent implements OnInit {
 @ViewChild('ticks') private ticks: MyAudioDirective;
 @ViewChild('nextUp') private nextUp: MyAudioDirective;
 @ViewChild('nextUpExercise') private nextUpExercise: MyAudioDirective;
 @ViewChild('halfway') private halfway: MyAudioDirective;
 @ViewChild('aboutToComplete') private aboutToComplete: MyAudioDirective;
 private nextupSound: string;

  constructor() { } 
  ...
}
```

这个提纲中有趣的一点是针对五个属性的`@ViewChild`装饰器。`@ViewChild`修饰符允许我们将子组件/指令/元素引用注入其父级。传递给 decorator 的参数是模板变量名，这有助于 DI 匹配要注入的元素/指令。Angular 实例化 main`WorkoutAudioComponent`时，会根据`@ViewChild`装饰符和传递的模板引用变量名注入相应的音频指令。在我们详细了解`@ViewChild`之前，让我们先完成基本类的实现。

Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection injects the related `ElementRef` instance instead of the `MyAudioDirective` instance. We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and then looking at the injected dependencies in `WorkoutAudioComponent`.

剩下的任务就是在正确的时间播放正确的音频组件。将这些功能添加到`WorkoutAudioComponent`：

```ts
stop() {
    this.ticks.stop();
    this.nextUp.stop();
    this.halfway.stop();
    this.aboutToComplete.stop();
    this.nextUpExercise.stop();
  }
  resume() {
    this.ticks.start();
    if (this.nextUp.currentTime > 0 && !this.nextUp.playbackComplete) 
        { this.nextUp.start(); }
    else if (this.nextUpExercise.currentTime > 0 && !this.nextUpExercise.playbackComplete)
         { this.nextUpExercise.start(); }
    else if (this.halfway.currentTime > 0 && !this.halfway.playbackComplete) 
        { this.halfway.start(); }
    else if (this.aboutToComplete.currentTime > 0 && !this.aboutToComplete.playbackComplete) 
        { this.aboutToComplete.start(); }
  }

  onExerciseProgress(progress: ExerciseProgressEvent) {
    if (progress.runningFor === Math.floor(progress.exercise.duration / 2)
      && progress.exercise.exercise.name != 'rest') {
      this.halfway.start();
    }
    else if (progress.timeRemaining === 3) {
      this.aboutToComplete.start();
    }
  }

  onExerciseChanged(state: ExerciseChangedEvent) {
    if (state.current.exercise.name === 'rest') {
      this.nextupSound = state.next.exercise.nameSound;
      setTimeout(() => this.nextUp.start(), 2000);
      setTimeout(() => this.nextUpExercise.start(), 3000);
    }
  } 
```

写这些函数有困难吗？它们可在[T0]Git 分支中获得。

在前面的代码中使用了两个新的模型类。将其声明添加到`model.ts`中，如下所示（在`checkpoint3.3`中再次提供）：

```ts
export class ExerciseProgressEvent {
    constructor(
        public exercise: ExercisePlan,
        public runningFor: number,
        public timeRemaining: number,
        public workoutTimeRemaining: number) { }
}

export class ExerciseChangedEvent {
    constructor(
        public current: ExercisePlan,
        public next: ExercisePlan) { }
} 
```

这些是跟踪进度事件的模型类。`WorkoutAudioComponent`实现会消耗这些数据。记住在`workout-audio.component.ts`中导入`ExerciseProgressEvent`和`ExerciseProgressEvent`的引用。

重申一下，音频组件通过定义两个事件处理程序来消耗事件：`onExerciseProgress`和`onExerciseChanged.`事件是如何生成的，这在我们前进的过程中变得很清楚。

当训练开始、暂停或完成时，`start`和`resume`功能停止并恢复音频。“恢复”功能的额外复杂性使它能够处理在下一次、即将完成或中途音频播放时暂停训练的情况。我们只想从我们结束的地方继续。

应调用`onExerciseProgress`函数来报告训练进度。它用于根据训练状态播放中途音频和即将完成的音频。传递给它的参数是包含练习进度数据的对象。

当练习更改时，应调用[T0]函数。输入参数包含行中的当前和下一个练习，并帮助`WorkoutAudioComponent`决定何时播放下一个向上练习音频。

在本节中，我们讨论了两个新概念：模板引用变量和将子元素/指令注入父元素。在我们继续实施之前，有必要更详细地探讨这两个概念。我们将从学习更多关于模板引用变量开始。



# 理解模板引用变量

**模板引用变量**在视图模板上创建，主要从视图中使用。正如您已经了解到的，这些变量可以通过用于声明它们的`#`前缀来识别。

模板变量的最大好处之一是，它们促进了视图模板级别的跨组件通信。声明后，同级元素/组件及其子级可以引用这些变量。查看以下代码段：

```ts
    <input #emailId type="email">Email to {{emailId.value}} 
    <button (click)= "MailUser(emaild.value)">Send</button> 
```

这个代码段声明了一个模板变量`emailId`，然后在插值和按钮`click`表达式中引用它。

角度模板引擎将`input`（一个`HTMLInputElement`实例）的 DOM 对象分配给`emailId`变量。由于该变量在兄弟节点之间可用，因此我们在按钮的`click`表达式中使用它。

模板变量也适用于组件。我们可以轻松做到这一点：

```ts
    <trainer-app> 
     <workout-runner #runner></workout-runner> 
     <button (click)= "runner.start()">Start Workout</button> 
    </trainer-app> 
```

在这种情况下，`runner`引用了`WorkoutRunnerComponent`对象，该按钮用于启动训练。

The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable can also be declared as `ref-runner`.



# 模板变量赋值

您可能没有注意到，但在最后几节中描述的模板变量赋值有一些有趣的地方。综上所述，我们使用的三个示例是：

```ts
<audio #ticks="MyAudio" loop src="/static/audio/tick10s.mp3"></audio> 

<input #emailId type="email">Email to {{emailId.value}}

<workout-runner #runner></workout-runner> 
```

分配给变量的内容取决于变量的声明位置。这取决于以下方面的规则：

*   如果元素上存在指令，如前面所示的第一个示例中的`MyAudioDirective`，则该指令将设置该值。`MyAudioDirective`指令将`ticks`变量设置为`MyAudioDirective`的实例。
*   如果不存在指令，则要么分配底层 HTML DOM 元素，要么分配组件对象（如`input`和`workout-runner`示例所示）。

我们将采用此技术实现训练音频组件与训练跑步者组件的集成。这一介绍为我们提供了我们需要的领先优势。

我们承诺要介绍的另一个新概念是使用`ViewChild`和`ViewChildren`修饰符的子元素/指令注入。



# 使用@ViewChild 装饰器

[T0]装饰器指示 Angular DI 框架在组件树中搜索特定的子组件/指令/元素，并将其注入父组件。这允许父组件使用对子组件的引用与子组件/元素交互，这是一种新的通信模式！

在前面的代码中，`MyAudioDirective`类的音频元素指令被注入到`WorkoutAudioComponent`代码中。

为了建立上下文，让我们重新检查`WorkoutAudioComponent`中的一个视图片段：

```ts
    <audio #ticks="MyAudio" loop src="/static/audio/tick10s.mp3"></audio> 
```

Angular 将指令（`MyAudioDirective`注入`WorkoutAudioComponent`属性：`ticks`。搜索是基于传递给`@ViewChild`装饰器的选择器完成的。让我们再看一次音频示例：

```ts
 @ViewChild('ticks') private ticks: MyAudioDirective;
```

`ViewChild`上的选择器参数可以是字符串值，在这种情况下，Angle 会像前面一样搜索匹配的模板变量。

也可以是*型。*有效，应注入`MyAudioDirective`实例：

```ts
@ViewChild(MyAudioDirective) private ticks: MyAudioDirective; 
```

然而，它在我们的案例中并不起作用。为什么？因为在`WorkoutAudioComponent`视图中声明了多个`MyAudioDirective`指令，每个`<audio>`标记一个指令。在这种情况下，将注入第一个匹配项。不是很有用。如果视图中只有一个`<audio>`标记，那么传递类型选择器就会起作用！

Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event hook on the component is called. This implies such properties are `null` if accessed inside the constructor.

Angular 还有一个装饰器来定位和注入多个子组件/指令：`@ViewChildren`。



# @ViewChildren 装饰程序

`@ViewChildren`的工作原理与`@ViewChild`类似，只是可以将多个子类型注入父类。再次以上面的音频组件为例，使用`@ViewChildren`可以得到`WorkoutAudioComponent`中的所有`MyAudioDirective`指令实例，如下图：

```ts
@ViewChildren(MyAudioDirective) allAudios: QueryList<MyAudioDirective>; 
```

仔细看；`allAudios`不是一个标准 JavaScript 数组，而是一个自定义类`QueryList<Type>`。`QueryList`类是一个不可变的集合，其中包含对 Angular 能够根据传递给`@ViewChildren`装饰器的筛选条件定位的组件/指令的引用。这个列表最好的地方是 Angular 将使这个列表与视图的状态保持同步。当指令/组件从视图中动态添加/删除时，此列表也会更新。使用`ng-for`生成的组件/指令就是这种动态行为的主要示例。考虑前面提到的用法和这个视图模板：

```ts
<audio *ngFor="let clip of clips" src="/static/audio/ "+{{clip}}></audio> 
```

Angular 创建的`MyAudioDirective`指令的数量取决于`clips`的数量。使用`@ViewChildren`时，Angular 将正确数量的`MyAudioDirective`实例注入`allAudio`属性，并在`clips`数组中添加或删除项目时保持同步。

虽然`@ViewChildren`的使用允许我们掌握所有`MyAudioDirective`指令，但它不能用于控制播放。你看，随着音频播放时间的变化，我们需要掌握单个`MyAudioDirective`实例。因此有了独特的`@ViewChild`实现。

一旦我们掌握了附在每个音频元素上的`MyAudioDirective`指令，就只需要在正确的时间播放音频曲目。



# 集成音频组件

虽然我们已经将音频播放功能组件化为`WorkoutAudioComponent`，但它始终与`WorkoutRunnerComponent`实现紧密耦合。`WorkoutAudioComponent`从`WorkoutRunnerComponent`获取其作战情报。因此，这两个组件需要相互作用。`WorkoutRunnerComponent`需要提供`WorkoutAudioComponent`状态变化数据，包括训练开始时间、训练进度、训练停止、暂停和恢复。

实现这种集成的一种方法是使用`WorkoutRunnerComponent`中当前公开的`WorkoutAudioComponent`API（停止、恢复和其他函数）。

可以通过将`WorkoutAudioComponent`注入`WorkoutRunnerComponent`来完成一些事情，就像我们之前将`MyAudioDirective`注入`WorkoutAudioComponent`时所做的那样。

在`WorkoutRunnerComponent's`视图中声明`WorkoutAudioComponent`，例如：

```ts
<div class="row pt-4">...</div>
<abe-workout-audio></abe-workout-audio>
```

这样我们就可以参考`WorkoutRunnerComponent`实现中的`WorkoutAudioComponent`：

```ts
@ViewChild(WorkoutAudioComponent) workoutAudioPlayer: WorkoutAudioComponent; 
```

然后可以从代码中的不同位置从`WorkoutRunnerComponent`调用`WorkoutAudioComponent`函数。例如，这就是`pause`的变化方式：

```ts
    pause() { 
      clearInterval(this.exerciseTrackingInterval); 
      this.workoutPaused = true; 
 this.workoutAudioPlayer.stop(); 
    }
```

要播放下一个 up 音频，我们需要更改`startExerciseTimeTracking`功能的部分：

```ts
this.startExercise(next); 
this.workoutAudioPlayer.onExerciseChanged(new ExerciseChangedEvent(next, this.getNextExercise()));
```

这是一个完全可行的选择，其中`WorkoutAudioComponent`成为`WorkoutRunnerComponent`控制的哑组件。这个解决方案的唯一问题是它给`WorkoutRunnerComponent`实现增加了一些噪声。`WorkoutRunnerComponent`现在也需要管理音频播放。

然而，还有另一种选择。

`WorkoutRunnerComponent`可以公开在训练执行的不同时间触发的事件，例如训练开始、训练开始和训练暂停。拥有`WorkoutRunnerComponent`暴露事件的优点是，它允许我们使用相同的事件将其他组件/指令与`WorkoutRunnerComponent`集成。无论是`WorkoutAudioComponent`还是我们未来创建的组件。



# 公开 WorkoutRunnerComponent 事件

到目前为止，我们只探索了如何使用事件。角度也允许我们提出事件。角度组件和指令可以使用`EventEmitter`类和`@Output`修饰符公开自定义事件。

将这些事件声明添加到变量声明部分末尾的`WorkoutRunnerComponent`：

```ts
workoutPaused: boolean; 
@Output() exercisePaused: EventEmitter<number> = 
    new EventEmitter<number>(); @Output() exerciseResumed: EventEmitter<number> = 
    new EventEmitter<number>() @Output() exerciseProgress:EventEmitter<ExerciseProgressEvent> = 
    new EventEmitter<ExerciseProgressEvent>(); @Output() exerciseChanged: EventEmitter<ExerciseChangedEvent> = 
    new EventEmitter<ExerciseChangedEvent>(); @Output() workoutStarted: EventEmitter<WorkoutPlan> = 
    new EventEmitter<WorkoutPlan>(); @Output() workoutComplete: EventEmitter<WorkoutPlan> = 
    new EventEmitter<WorkoutPlan>();
```

事件的名称是不言自明的，在我们的`WorkoutRunnerComponent`实现中，我们需要在适当的时间提出它们。

`ExerciseChangeEvent`和`ExerciseProgressEvent`在顶部添加。并将`Output`和`EventEmitter`进口添加到`@angular/core`。

让我们试着理解`@Output`装饰者和`EventEmitter`类的角色。



# @Output decorator

我们在*构建我们的第一个应用程序–7 分钟训练*中介绍了大量的角度项目能力。具体来说，我们学习了如何使用`bracketed ()`语法使用组件、指令或 DOM 元素上的任何事件。我们自己举办活动怎么样？

在 Angular 中，我们可以创建并引发我们自己的事件，这些事件表示组件/指令中发生了值得注意的事情。使用`@Output`装饰器和`EventEmitter`类，我们可以定义和引发自定义事件。

It's also a good time to refresh what we learned about events, by revisiting the *Eventing subsection* in the *Angular event binding infrastructure* section from , *Building Our First App – 7-Minute Workout*.

记住：组件可以通过事件与外部世界通信。当我们宣布：

```ts
@Output() exercisePaused: EventEmitter<number> = new EventEmitter<number>(); 
```

它表示`WorkoutRunnerComponent`公开一个事件`exercisePaused`（训练暂停时引发）。

要订阅此活动，我们可以执行以下操作：

```ts
<abe-workout-runner (exercisePaused)="onExercisePaused($event)"></abe-workout-runner>
```

这看起来与我们在“训练跑步者”模板中订阅 DOM 事件的方式非常相似。请参见“训练跑步者”视图中的示例点画：

```ts
<div id="pause-overlay" (click)="pauseResumeToggle()" (window:keyup)="onKeyPressed($event)"> 
```

[T0]装饰器指示 Angular 使此事件可用于模板绑定。没有[T1]装饰符创建的事件不能在 HTML 中引用。

The `@Output` decorator can also take a parameter, signifying the name of the event. If not provided, the decorator uses the property name: `@Output("workoutPaused") exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event instead of `exercisePaused`.

与任何 decorator 一样，`@Output`decorator 只是为 Angular 框架提供元数据。真正的重担是由`EventEmitter`类完成的。



# 使用 EventEmitter 进行事件处理

Angular 采用**反应式编程**（也称为**Rx**式编程），支持事件异步操作。如果您是第一次听到这个术语，或者对什么是反应式编程不太了解，那么您并不孤单。

反应式编程就是针对**异步数据流**进行编程。这样的流只不过是根据事件发生的时间排序的一系列正在进行的事件。我们可以将一个流想象成一个管道（以某种方式）生成数据并将其推送到一个或多个订户。由于订阅服务器异步捕获这些事件，因此它们被称为异步数据流。

数据可以是任何内容，从浏览器/DOM 元素事件到用户输入，再到使用 AJAX 加载远程数据。使用*Rx*样式，我们统一使用这些数据。

在 Rx 世界中，存在观察者和可观察者，这一概念源自非常流行的**观察者设计模式**。**可见光**是发射数据的流。**观察员**则订阅这些活动。

Angular 的`EventEmitter`课程主要负责提供赛事支持。它同时充当*观察者*和*可观察者*。我们可以在上面触发事件，它也可以收听事件。

`EventEmitter`上有两个我们感兴趣的功能：

*   `emit`：顾名思义，使用此功能引发事件。它接受一个作为事件数据的参数。`emit`*为可观察侧*。
*   `subscribe`：使用此功能订阅`EventEmitter`引发的事件。`subscribe`为观察方。

让我们进行一些事件发布和订阅，以了解前面的函数是如何工作的。



# 从 WorkoutRunnerComponent 引发事件

请看`EventEmitter`声明。这些已使用`type`参数声明。`EventEmitter`上的`type`参数表示发出的数据类型。

让我们将事件实现添加到`workout-runner.component.ts`中，从文件顶部开始向下移动。

将此语句添加到`start`函数的末尾：

```ts
this.workoutStarted.emit(this.workoutPlan);
```

我们使用`EventEmitter`的`emit`函数以当前训练计划为参数发起`workoutStarted`事件。

在`pause`中，添加此行以引发`exercisePaused`事件：

```ts
this.exercisePaused.emit(this.currentExerciseIndex); 
```

在`resume`中，添加以下行：

```ts
this.exerciseResumed.emit(this.currentExerciseIndex); 
```

每次我们在提升`exercisePaused`和`exerciseResumed`事件时，将当前运动指数作为参数传递给`emit`。

在`startExerciseTimeTracking`函数中，在调用`startExercise`后添加高亮显示的代码：

```ts
this.startExercise(next); 
this.exerciseChanged.emit(new ExerciseChangedEvent(next, this.getNextExercise()));
```

传递的参数包含将要开始的练习（`next`和第行中的下一个练习（`this.getNextExercise()`。

在同一函数中，添加突出显示的代码：

```ts
this.tracker.endTracking(true); 
this.workoutComplete.emit(this.workoutPlan); 
this.router.navigate(['finish']); 
```

训练完成后，将引发该事件。

在同一功能中，我们发起一个事件，传达训练进度。添加以下语句：

```ts
--this.workoutTimeRemaining; 
this.exerciseProgress.emit(new ExerciseProgressEvent( this.currentExercise, this.exerciseRunningDuration, this.currentExercise.duration -this.exerciseRunningDuration, this.workoutTimeRemaining));
```

这就完成了我们的事件实现。

正如您可能已经猜到的，`WorkoutAudioComponent`现在需要消耗这些事件。这里的挑战是如何组织这些组件，以便它们能够以最小的相互依赖性相互通信。



# 组件通信模式

根据目前的实施情况，我们有：

*   一个基本的`WorkoutAudioComponent`实现
*   通过暴露训练生命周期事件增强`WorkoutRunnerComponent`

这两个组件现在只需要相互对话。

如果家长需要与其子女沟通，可以通过以下方式进行：

*   **属性绑定**：父组件可以在子组件上设置属性绑定，将数据推送到子组件。例如，此属性绑定可以在暂停训练时停止音频播放器：

```ts
        <workout-audio [stopped]="workoutPaused"></workout-audio>
```

在这种情况下，属性绑定可以正常工作。暂停训练时，音频也会停止。但并非所有场景都可以使用属性绑定来处理。播放下一个练习音频或中途音频需要更多的控制。

*   **调用子组件上的函数**：父组件也可以调用子组件上的函数，如果父组件可以得到子组件。我们已经看到了如何在`WorkoutAudioComponent`实现中使用`@ViewChild`和`@ViewChildren`修饰符来实现这一点。在*音频组件*一节中，也简要讨论了这种方法及其缺点。

还有一个不太好的选择。子组件引用父组件，而不是引用子组件的父组件。这允许子组件调用父组件的公共函数或订阅父组件事件。

我们将尝试这种方法，然后放弃实现以获得更好的方法！从我们计划实施的并非最优的解决方案中可以获得很多知识。



# 将父组件注入子组件

将`WorkoutAudioComponent`添加到上次关闭`div`之前的`WorkoutRunnerComponent`视图中：

```ts
 <abe-workout-audio></abe-workout-audio> 
```

接下来，将`WorkoutRunnerComponent`注入`WorkoutAudioComponent`中。打开`workout-audio.component.ts`并添加以下声明并更新构造函数：

```ts
private subscriptions: Array<any>; 

constructor( @Inject(forwardRef(() => WorkoutRunnerComponent)) 
    private runner: WorkoutRunnerComponent) { 
    this.subscriptions = [ 
      this.runner.exercisePaused.subscribe((exercise: ExercisePlan) => 
          this.stop()), 
      this.runner.workoutComplete.subscribe((exercise: ExercisePlan) => 
          this.stop()), 
      this.runner.exerciseResumed.subscribe((exercise: ExercisePlan) => 
          this.resume()), 
      this.runner.exerciseProgress.subscribe((progress: ExerciseProgressEvent) => 
          this.onExerciseProgress(progress)),
```

```ts

      this.runner.exerciseChanged.subscribe((state: ExerciseChangedEvent) =>  
          this.onExerciseChanged(state))]; 
    } 
```

请记住添加这些导入：

```ts
    import {Component, ViewChild, Inject, forwardRef} from '@angular/core'; 
    import {WorkoutRunnerComponent} from '../workout-runner.component'  
```

让我们试着在运行应用程序之前了解我们做了什么。在施工注入中涉及到一些欺诈行为。如果我们直接尝试将`WorkoutRunnerComponent`注入`WorkoutAudioComponent`中，它将失败，因为无法找到所有依赖项。阅读代码并仔细思考；潜伏着一个微妙的依赖循环问题。`WorkoutRunnerComponent`已经依赖于`WorkoutAudioComponent`，正如我们在`WorkoutRunnerComponent`视图中引用的`WorkoutAudioComponent`。现在通过在`WorkoutAudioComponent`中注入`WorkoutRunnerComponent`，我们创建了一个依赖循环。

循环依赖性对于任何 DI 框架都是一个挑战。当创建具有循环依赖关系的组件时，框架必须以某种方式解决该循环。在前面的示例中，我们通过使用`@Inject`修饰符并传递使用`forwardRef()`全局框架函数创建的令牌来解决循环依赖性问题。

一旦注入正确完成，在构造函数内部，我们使用`EventEmitter`的`subscribe`函数将处理程序附加到`WorkoutRunnerComponent`事件。只要事件发生时带有特定的事件参数，就会调用传递给`subscribe`的 arrow 函数。我们将所有订阅收集到一个`subscription`数组中。当我们需要取消订阅时，这个阵列非常方便，以避免内存泄漏。

关于`EventEmitter`的一点：`EventEmmiter`订阅（`subscribe`函数）有三个参数：

```ts
    subscribe(generatorOrNext?: any, error?: any, complete?: any) : any 
```

*   第一个参数是回调，在发出事件时调用回调
*   第二个参数是错误回调函数，当可观察对象（生成事件的部分）出错时调用
*   最后一个参数接受一个回调函数，该函数在可观察事件发布完成时调用

我们已经做了足够多的工作，使音频集成工作。运行应用程序并开始训练。除了滴答声之外，所有的`\`音频剪辑都在正确的时间播放。您可能需要等待一段时间才能听到其他音频片段。有什么问题？

事实证明，我们从未在训练开始时开始播放滴答声音频片段。我们可以通过在`ticks`音频元素上设置`autoplay`属性或使用组件生命周期事件触发滴答声来修复它。让我们采取第二种方法。



# 使用组件生命周期事件

`WorkoutAudioComponent`中注入的`MyAudioDirective`在视图初始化后才可用，如下图所示：

```ts
<audio #ticks="MyAudio" loop src="/img/audio/tick10s.mp3"></audio>
<audio #nextUp="MyAudio" src="/img/audio/nextup.mp3"></audio>
...
```

我们可以通过访问构造函数内部的`ticks`变量进行验证；它将是空的。Angular 还没有完成它的魔法，我们需要等待`WorkoutAudioComponent`的子元素被初始化。

组件的生命周期挂钩可以在这方面帮助我们。一旦组件的视图被初始化，`AfterViewInit`事件钩子就会被调用，因此是访问组件子指令/元素的安全位置。让我们快点做吧。

通过添加接口实现和必要的导入来更新`WorkoutAudioComponent`，如下所示：

```ts
import {..., AfterViewInit} from '@angular/core'; 
... 
export class WorkoutAudioComponent implements OnInit, AfterViewInit { 
    ngAfterViewInit() { 
          this.ticks.start(); 
    }
```

继续测试应用程序。该应用程序通过全面的音频反馈变得栩栩如生。美好的

虽然表面上看起来一切都很好，但现在应用程序中存在内存泄漏。如果在训练的中间，我们从锻炼页面导航（到开始或完成页面），并再次返回到锻炼页面，多个音频剪辑随机播放。

`WorkoutRunnerComponent`似乎没有在路线导航中被破坏，因此，所有子组件都没有被破坏，包括`WorkoutAudioComponent`。最终结果如何？每次我们导航到训练页面时，都会创建一个新的`WorkoutRunnerComponent`，但在导航离开时，它不会从内存中删除。

内存泄漏的主要原因是我们在`WorkoutAudioComponent`中添加的事件处理程序。当音频组件卸载时，我们需要取消订阅这些事件，否则`WorkoutRunnerComponent`引用将永远不会被取消引用。

另一个组件生命周期事件拯救了我们：`OnDestroy`将此实现添加到`WorkoutAudioComponent`类：

```ts
    ngOnDestroy() { 
      this.subscriptions.forEach((s) => s.unsubscribe()); 
    }
```

另外，记住向`OnDestroy`事件接口添加引用，就像我们对`AfterViewInit`所做的那样。

希望我们在事件订阅期间创建的[T0]数组现在有意义。一次性退订！

此音频集成现已完成。虽然这种方法在集成这两个组件方面不是一种非常糟糕的方法，但我们可以做得更好。引用父组件的子组件似乎不受欢迎。

Before proceeding, delete the code that we have added to `workout-audio.component.ts` from the *Injecting a parent component into a child component* section onward.



# 使用事件和模板变量的同级组件交互

如果`WorkoutRunnerComponent`和`WorkoutAudioComponent`被组织为兄弟组件会怎样？

如果`WorkoutAudioComponent`和`WorkoutRunnerComponent`成为兄弟，我们可以充分利用 Angular 的*事件*和*模板参考变量*。困惑的首先，这是组件的布局方式：

```ts
    <workout-runner></workout-runner> 
    <workout-audio></workout-audio> 
```

有什么意义吗？从这个模板开始，你能猜出最终的 HTML 模板是什么样子吗？想一想再继续。

还在挣扎？一旦我们让它们成为兄弟组件，角度模板引擎的力量就会显现出来。以下模板代码足以集成`WorkoutRunnerComponent`和`WorkoutAudioComponent`：

```ts
<abe-workout-runner (exercisePaused)="wa.stop()" 
    (exerciseResumed)="wa.resume()" 
    (exerciseProgress)= "wa.onExerciseProgress($event)" 
    (exerciseChanged)= "wa.onExerciseChanged($event)" 
    (workoutComplete)="wa.stop()" 
    (workoutStarted)="wa.resume()"> 
</abe-workout-runner> 
<abe-workout-audio #wa></abe-workout-audio> 
```

`WorkoutAudioComponent`模板变量`wa`正在通过引用`WorkoutRunnerComponent`上事件处理程序表达式中的变量进行操作。相当优雅！我们仍然需要解决这种方法中最大的难题：前面的代码去了哪里？记住，`WorkoutRunnerComponent`是作为路线装载的一部分装载的。代码中没有这样的语句：

```ts
    <workout-runner></workout-runner> 
```

我们需要重新组织组件树，并引入一个可以承载`WorkoutRunnerComponent`和`WorkoutAudioComponent`的容器组件。路由器然后加载此容器组件而不是[T2]。让我们做吧。

通过导航到`trainer/src/app/workout-runner`并执行以下操作，从命令行生成新的组件代码：

```ts
ng generate component workout-container -is
```

将包含所述事件的 HTML 代码复制到模板文件中。训练容器组件已准备就绪。

我们只需要重新布线设置。打开`app-routing.module.ts`。更改训练跑步者的路线并添加必要的导入：

```ts
import {WorkoutContainerComponent} 
 from './workout-runner/workout-container/workout-container.component'; 
..
{ path: '/workout', component: WorkoutContainerComponent },
```

我们有一个工作的音频集成，清晰，简洁，赏心悦目！

现在是结束本章的时候了，但在解决前面几节中介绍的视频播放器对话框故障之前。视频播放器对话框打开时，训练不会停止/暂停。

我们不打算在这里详述修复程序，并敦促读者在不查阅[T0]代码的情况下尝试一下。

这里有一个明显的提示。使用事件基础设施！

另一个：从`VideoPlayerComponent`引发事件，每次播放开始和结束都有一个事件。

最后一个提示：对话框服务（`Modal`上的`open`函数返回一个承诺，该承诺在对话框关闭时得到解决。

If you are having a problem with running the code, look at the `checkpoint3.4` Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4). Refer to the `README.md` file in the `trainer` folder when setting up the snapshot for the first time.



# 总结

一点一点地，我们为*7 分钟锻炼*应用程序添加了许多增强功能，这对于任何专业应用程序来说都是必不可少的。新功能和改进仍有余地，但核心应用程序运行良好。

本章首先探讨 Angular 的单页应用程序（SPA）功能。在这里，我们学习了基本的角度路由、设置路由、使用路由配置、使用`RouterLink`指令生成链接，以及使用角度`Router`和`Location`服务执行导航。

从应用程序的角度来看，我们在*7 分钟训练*中添加了开始、结束和训练页面。

然后，我们构建了一个训练历史跟踪服务，用于跟踪历史训练执行情况。在这个过程中，我们深入了解了 Angular 的**依赖注入（DI）**。我们介绍了依赖项是如何注册的，什么是依赖项令牌，以及依赖项在本质上如何是单例的。我们还了解了注入器以及分层注入器如何影响依赖性探测。

最后，我们讨论了一个重要的主题：跨组件通信，主要使用角度事件。我们详细介绍了如何使用`@Output`装饰器和`EventEmitter`创建自定义事件。

我们在本章中提到的`@ViewChild`和`@ViewChildren`装饰器帮助我们理解家长如何获得子组件以供使用。角度 DI 还允许将父组件注入子组件。

我们通过构建一个`WorkoutAudioComponent`来结束本章，并强调了兄弟组件如何使用角度事件和模板变量进行通信。

下一步是什么？我们将构建一个新的应用程序，*私人教练*。此应用程序将允许我们建立自己的自定义训练。一旦我们可以创建自己的训练，我们将把*7 分钟训练*应用程序变形为通用*训练跑步者*应用程序，可以运行我们使用*私人教练*构建的训练。

在下一章中，我们将展示 Angular 的表单功能，同时构建一个 UI，允许我们创建、更新和查看自己的自定义训练/练习。