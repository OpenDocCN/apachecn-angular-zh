# 7.

# 创建路由器一线业务应用程序

**业务线**（**LOB**）应用程序是软件开发领域的面包和黄油。正如维基百科所定义的，LOB 是一个通用术语，指的是为特定客户交易或业务需求服务的一种产品或一组相关产品。LOB 应用程序提供了一个展示各种特性和功能的绝佳机会，而无需进入大型企业应用程序通常需要解决的扭曲或特殊场景。

帕累托原则，也称为 80-20 规则，规定我们可以用 20%的总体努力完成 80%的目标。我们将在 LOB 应用程序的设计和架构中应用 80-20 规则。鉴于 LOB 应用程序涵盖的常见用例，从某种意义上说，它们非常适合 80-20 岁的学习体验。只需付出 20%的努力，您就可以学到向用户提供高质量体验所需的 80%的知识。

LOB 应用程序有一个奇怪的特性。如果你最终构建了一个半有用的应用程序，那么对它的需求就会增长，无法控制，你很快就会成为成功的受害者。平衡项目的架构需求是一项挑战；你要避免潜在的破坏性的工程不足，另一方面，也要避免为一个永远不需要它的应用程序进行昂贵的过度工程。

在本章中，我将向您介绍 router first 体系结构，这是一种 80-20 设计解决方案，旨在解决以增量和迭代方式交付现代 web 应用程序的挑战。

正如您在*第 1 章*、*Angular 及其概念简介*中所读到的，软件架构并不是静态的。为了更好地创建更灵活的体系结构，必须通过使用编码 KATA、概念验证应用程序和参考项目来尝试新想法。

在本书的这一章和其余章节中，我们将建立一个新的应用程序，该应用程序具有丰富的功能，可以通过可扩展的体系结构和工程最佳实践来满足 LOB 应用程序的需求，这将帮助您从小处着手，并能够在有需求时快速扩展您的解决方案。我们将遵循路由器优先的设计模式，依靠可重用组件创建一个名为 LemonMart 的杂货店 LOB。我们将讨论围绕主要数据实体进行设计的想法，以及在开始实施各种条件导航元素之前为应用程序完成高级实体模型的重要性，这些元素在设计阶段可能会发生重大变化。

在本章中，您将学习执行以下操作：

*   将 80-20 解决方案应用于软件开发
*   了解如何构建路由器优先应用程序
*   开始创建 LemonMart 应用程序，您将在本书的其余部分进行扩展
*   创建有效的品牌，以及定制和材质图像
*   通过延迟加载实现亚秒级的第一次绘制
*   创建行走骨架
*   使用通用测试模块减少重复
*   围绕主要数据实体进行设计
*   认识到高级用户体验设计的重要性

本书样本代码的最新版本在 GitHub 上的以下链接存储库中。存储库包含代码的最终和完成状态。您可以在本章末尾通过在`projects`文件夹下查找代码的章末快照来验证您的进度。

*对于第 7 章*：

1.  克隆回购[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart )
2.  在根文件夹上执行`npm install`以安装依赖项
3.  本章代码示例在子文件夹

    ```
    projects/ch7 
    ```

    下
4.  要运行本章的 Angular 应用程序，请执行：

    ```
    npx ng serve ch7 
    ```

5.  要运行本章的角度单元测试，请执行：

    ```
    npx ng test ch7 --watch=false 
    ```

6.  要运行本章的角度 e2e 测试，请执行：

    ```
    npx ng e2e ch7 
    ```

7.  要为本章构建生产就绪的 Angular 应用程序，请执行：

    ```
    npx ng build ch7 --prod 
    ```

请注意，存储库根目录下的`dist/ch7`文件夹将包含编译后的结果。

请注意，书中或 GitHub 上的源代码可能并不总是与 Angular CLI 生成的代码匹配。书中的代码和 GitHub 上的代码在实现上也可能有细微的差异，因为生态系统是不断发展的。随着时间的推移，示例代码自然会发生变化。

此外，在 GitHub 上，希望找到更正、修复以支持库的更新版本，或者多种技术的并行实现供您观察。您只需要实现书中推荐的理想解决方案。如果发现错误或有问题，请在 GitHub 上创建问题或提交请求，以方便所有读者。

您可以在*附录 C*、*保持 Angular 和 Tools 常青*中了解更多关于更新 Angular 的信息。您可以从[在线找到此附录 https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.) 或[处 https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen) 。

让我们从介绍应用程序设计和架构背后的理念开始。

# 80-20 解决方案

无论我们是在家里、在激情项目中还是在办公室、在工作中开发应用程序，我们都必须牢记我们的目标：交付价值。如果我们不能通过激情项目实现价值，那么我们就不会感到满足或快乐。如果我们不能在工作中实现价值，我们可能得不到报酬。

交付现代 web 应用程序是困难的。要取得成功，我们需要克服许多挑战：

*   以迭代和增量的方式交付
*   可伸缩
*   提供数十种屏幕和输入类型
*   可用
*   易于接近
*   管理团队
*   培养一个优先的待办事项
*   确保验收标准清晰、简洁、具体

如果你曾经领导过一个项目，或者试图自己实施和交付一个项目，你就会意识到，没有足够的时间和资源来满足任何给定项目的各种利益相关者、团队和技术需求。请记住，帕累托原则，也被称为 80-20 规则，意味着我们可以用 20%的总体努力完成 80%的目标。

如果我们在工作中运用 80-20 法则，我们就能最大限度地提高产出、质量和幸福感。业务线应用程序是我们行业的重要组成部分。应用 80-20 规则，我们可以推测，我们大多数人可能通过提交此类申请来赚取大部分收入。因此，我们应该将我们的工程开销控制在最低限度，并降低项目的交付风险。通过限制生产代码中的实验，我们为团队成员创建了一个可预测的环境，并且只引入我们有机会在概念验证或小型应用程序中进行审查的更改。

我们的 80-20 战略与纪律相结合，可以帮助我们在同一时间交付具有更多功能和更好质量的相同项目。通过将我们的职业生涯视为马拉松，而不是一系列的冲刺，您可以发现自己处于提供高质量解决方案的位置，一个项目接一个项目，而不会感到筋疲力尽。

## 了解业务线应用程序

根据维基百科的说法，业务线应用程序是“被视为对企业运营至关重要的一组关键计算机应用程序”。LOB 应用程序是大多数开发人员最终开发的应用程序，尽管我们可能认为我们开发的是小型应用程序或大型企业应用程序。考虑下面的插图，它演示了我们可能开发的应用程序的种类，它们相对于轴的大小和范围放置在轴上：

<figure class="mediaobject">![](../Images/B14094_07_01.png)</figure>

图 7.1：四种应用程序的相对大小和范围

从我的角度来看，我们在开始开发软件时会考虑四种应用程序：

*   小型应用程序
*   LOB 应用程序
*   大型企业应用程序
*   亿用户规模的应用程序

亿用户规模的应用程序是完全利基的实现，很少有与绝大多数应用程序一致的需求。因此，我们必须将这些应用程序归类为异常值。

小应用程序从小做起。从架构上来说，它们很可能在最初的设计阶段。当你在一个小应用程序上添加功能和团队成员时，在某个时候，你会遇到麻烦。随着团队规模和功能集的增长，或者应用程序的总体复杂性增加，应用程序的体系结构需求呈指数级增长。

一旦你跨越了你的架构所能承受的复杂程度的拐点，你就需要付出昂贵的重新设计努力才能回到正轨。请参见下图，说明这一想法：

<figure class="mediaobject">![](../Images/B14094_07_02.png)</figure>

图 7.2：小型应用程序的架构之旅

要素线下的区域表示正在进行工程设计，这会给您的项目带来风险。要素线上方的区域显示了支持所需要素所需的工程开销。相比之下，大型企业应用程序一开始需要大量的过度工程，如下图所示：

<figure class="mediaobject">![](../Images/B14094_07_03.png)</figure>

图 7.3：大型企业应用程序的架构之旅

随着时间的推移和系统整体复杂性的增加，大型企业应用程序也可能面临类似的转折点，原始架构可能会变得不足。通过仔细的计划和管理，您可以避免麻烦并保护重要的初始投资。这样的大型企业应用程序需要数百名开发人员、多层次的管理人员和架构师才能成功执行。与 10 亿用户规模的应用程序类似，这些应用程序也可以有利基架构需求。在我们开发的小型应用程序和大型企业应用程序之间，存在 LOB 应用程序。

<figure class="mediaobject">![](../Images/B14094_07_04.png)</figure>

图 7.4：软件演化的动态性质

如上图所示，小型应用程序可能会增长并变形为 LOB 应用程序，而大型企业应用程序可能会被利用不足，因为用户忽略了他们从不需要的功能，但将应用程序保留为作为 LOB 应用程序的单一用途。在这两种情况下，尽管我们尽了最大努力，最终还是为我们正在解决的问题提供了效率低下的解决方案。我们都没有一个水晶球可以看到未来，规划和工程只能在不可预测的商业环境中为我们做这么多；我们需要依靠 80-20 规则来制定一个灵活的体系结构，以满足大多数业务需求。

路由器优先体系结构旨在保持最佳的体系结构开销，以便在匆忙交付所有必需的功能时，可以避免昂贵的重新设计或后期紧缩。让我们看看如何。

## 纪律严明和平衡的方法

我们对软件开发有什么见解，但我们也必须考虑到为什么 T4，当 T6 时，为什么不知道，在我们到达第 11 步之前，我们可以知道 T12。当我们开发用于学习或激情项目的应用程序时，我们通常会在设计项目时结束。如果你的激情项目在一夜之间获得成功，那么维护或继续向你的应用程序添加功能的成本就会增加。在这种情况下，您可能面临要么承担日常维护成本，要么重写应用程序的选择。

当我们为工作开发应用程序时，我们倾向于更加保守，并且我们很可能过度设计我们的解决方案。然而，如果您只为工作编写代码，那么您可能会在产品绑定代码中进行实验。与其他团队成员在代码库中进行实验是危险的。您可能正在引入一种新模式，而您的团队却不了解您的选择的后果。您也不太可能意识到所引入技术的中长期风险或好处。

鲁莽的实验也会对团队成员产生严重的负面影响。在一个由资深且经验丰富的软件工程师组成的团队中，你很可能可以在移动的汽车上进行实验。然而，我们的团队中可能有不同背景和学习风格的团队成员。我们中的一些人拥有计算机科学学位，我们中的一些人是孤独的狼，我们中的一些人过于依赖堆栈溢出。我们中的一些人在非常擅长支持专业发展的公司工作，但我们中的一些人在甚至没有给你一天时间学习新东西的地方工作。所以，当我们在试验时，我们必须考虑我们的环境；否则，我们可能会导致同事加班或感到无助和沮丧。

通过一种严格且平衡的方法，我们可以减少交付的 bug 数量，避免代价高昂的返工，并与一组朝着同一方向前进的人一起工作。我们还需要正确的体系结构、工具和模式/实践来成功交付。总之，我们的方法必须考虑：

*   我们的应用程序的大小
*   我们开发应用程序的原因
*   开发人员的技能水平
*   迭代和增量交付
*   特征的恒定向前流动
*   所有云的东西

理想情况下，我们需要保持最佳的工程开销。我们的体系结构应该支持我们的短期需求，同时具有可扩展性，因此，如果我们的中期或长期需求发生变化，我们可以在不同的方向上转向，而无需重写大量代码。考虑下面的图表，与上一节中关于小型和大型企业应用程序的对比：

<figure class="mediaobject">![](../Images/B14094_07_05.png)</figure>

图 7.5：LOB 应用程序的理想架构之旅

路由器优先体系结构旨在帮助您在工程开销、特性交付和代码库灵活性之间找到平衡。然而，你必须自己带着纪律。

![](../Images/B14094_07_003.png)或者舒哈日是一个可以帮助你在工作中遵守纪律的概念。这是一种思维方式，指导你首先掌握基本知识，而不必担心潜在的理论，然后掌握理论，最后能够根据自己的需要调整所掌握的知识。然而，如果你跳过步骤 1 或 2，你会发现自己用错误的方式适应了错误的事情。

在讨论了*什么*、*为什么*、*什么时候*、*在哪里*和*谁*之后，让我们在下一节跳到*如何*。

# 路由器优先体系结构

路由器优先架构是实现以下目的的一种方式：

*   **强化**高层次思维
*   **在开始编码之前，确保**对特性达成一致
**   **为您的代码库/团队制定**增长计划*   **引入**少量工程费用*

 *实施路由器优先体系结构有七个步骤：

1.  制定路线图和范围（*第 7 章*）
2.  考虑惰性负载的设计（*第 7 章*
3.  实现行走骨架导航体验（*第 7 章*
4.  实现无状态、数据驱动的设计（*第 7 章*和*第 10 章*）
5.  实施解耦组件架构（*第 8 章*、*第 11 章*和*第 12 章*）
6.  区分用户控件和组件（*第 11 章*）
7.  使用 TypeScript 和 ES 功能最大限度地实现代码重用（*第 8 章*、*10*、*11*和*12*）

如前所述，本章和后续章节将更详细地介绍每个步骤。在我们从较高的层次上讨论这些步骤之前，让我们首先介绍 Angular 中的功能模块，这是一个重要的基本技术概念。

## 功能模块

在*第 1 章**Angular 及其概念简介*中，我们从较高的层次介绍了 Angular 的体系结构，并介绍了延迟加载和路由的概念。功能模块是实现延迟加载的关键组件。有两种模块，根模块和功能模块。模块由`NgModule`类实现。`NgModule`包含呈现组件和注入服务所需的所有元数据。没有模块的组件没有多大作用。

角度应用程序由位于应用程序根的`NgModule`定义。这称为根模块。根模块负责呈现`index.html`文件中`<app-root>`元素中出现的内容。在下图中找到根模块：

<figure class="mediaobject">![](../Images/B14094_07_06.png)</figure>

图 7.6：角形结构的主要建筑构件

一个 NgModule 可以包含许多其他 NgModule。Angular 应用程序只有一个根模块，因此根据定义，每个其他模块都成为功能模块。在上图中，您可以看到您可以将一组组件（**Cmp**）和服务（**Svc**）组织到功能模块中。通过将功能分组到模块中，我们可以将代码组织成块，这些块可以与应用程序的初始负载分离。

根模块和功能模块的概念代表了父/子关系，这是一个扩展到其他功能和框架的概念。例如，请注意，前面的图将根路由器注入根模块。根路由器可以有子路由。可以将子路由配置为加载功能模块。类似地，NgRx 具有根和功能模块级存储，用于组织应用程序的状态数据。

出于所有意图和目的，本书中提到的子模块、子模块或功能模块都是指同一件事：不是根模块的模块。

功能模块和子路由允许在应用程序的主要组件之间分离关注点。两个团队可以在两个不同模块上工作，而不会相互干扰。这种分离意味着功能模块所需的任何依赖项都必须显式地添加到该模块的导入、声明或提供程序中。在模块之间共享代码时，这似乎是重复和恼人的，但这是一个必要的缺点。

在 Angular 中，默认情况下，服务是单例的——每个模块一个实例。在导入已经向根模块导入到特征模块的服务之前，请考虑这是否是真正需要的行为。根模块中提供的服务可以导入到功能模块中，而无需再次提供。在根模块和功能模块中提供服务将导致内存中存在该服务的多个实例，这打破了默认情况下服务是单例的预期。在*第 8 章**设计认证和授权*中，您将在我们实现`AuthService`时看到这一点。

随着 Angular 9 中 Ivy 渲染引擎的引入，道路被铺设以创建自描述组件。自描述组件不需要 NgModule 就可以使用。在 Angular 的未来版本中，可以实现简单的应用程序，而无需整个模块的仪式（阅读：样板代码）。

现在，让我们从高层次上回顾路由器优先架构的七个步骤。

## 制定路线图和范围

尽早制定路线图并确定项目范围对于正确使用高层体系结构至关重要。创建积压工作、线框、模型和交互式原型将帮助您在上路之前定义地图，并具体捕捉愿景。务必记住，只有在必要时才带工具。不要从 Photoshop 开始，一张纸和一支铅笔就可以了。如果利益相关者和团队成员了解正在开发的内容，那么就有可能以迭代和增量的方式交付您的解决方案。然而，不要落入完美的陷阱。将调整和家具重新布置留到基本面到位并达成一致意见后进行。

记录您创建的每个工件。在本章后面部分，我们将介绍如何利用 GitHub Wiki 存储工件。

在本章后面，我们将介绍如何开发路线图和技术来定义您的范围，在*第 3 章*中介绍的路线图构建技术基础上，*创建一个基本的角度应用程序*。

## 设计时要考虑延迟加载

第一幅画很重要，很多！根据 Angular 团队 2018 年收集的谷歌分析数据，53%的手机用户在加载时间超过 3 秒时放弃了网站。在同一时期，大多数网站都在移动设备上消费，美国约占 70%，中国约占 90%。正如我们在*第 5 章*中所述，*通过*材料提供高质量的用户体验，UI 库和静态资产可以显著增加应用程序的规模。鉴于大部分内容都是在移动设备上消费的，因此推迟非关键资产的加载是非常重要的。

我们通过将 Angular 应用程序的各个部分划分为功能模块来推迟资产的加载。这样，Angular 可以只加载渲染当前屏幕所需的资源，并根据需要动态下载更多资源。将应用程序划分为功能模块的一个好方法是定义应用程序可能使用的各种用户角色。用户角色通常表示用户的工作职能，例如经理或数据输入专家。在技术术语中，它们可以被认为是一组特定类别的用户可以执行的操作。毕竟，数据输入专家永远看不到管理者可以看到的大部分屏幕，那么为什么要将这些资产交付给这些用户并降低他们的体验呢？

延迟加载对于创建可扩展的应用程序体系结构至关重要，它允许您交付高质量和高效的产品。延迟加载是一个很容易解决的问题，我们将它作为基线设计目标来解决。事后实现延迟加载可能代价高昂。

开始加载单个角度组件是可能的。Angular 9 的 Ivy 渲染引擎支持自描述和独立组件。不需要 Angular 应用程序所需的所有自举功能的组件有可能彻底改变和简化我们设计应用程序的方式。然而，以这种方式设计应用程序还不可行。预计 Angular 的未来版本将引入公共 API，使其易于使用新功能，从而减少早期仔细设计功能模块的需要。

在本章后面，您将了解如何使用功能模块实现延迟加载。

## 实现行走骨架

配置延迟加载可能很棘手，这就是为什么必须尽早确定行走骨架导航体验的原因。实现应用程序的可点击版本将帮助您尽早收集用户反馈。这样，您将能够快速解决基本的工作流和集成问题。此外，您将能够建立当前开发工作范围的具体表示。开发人员和利益相关者都将能够更好地可视化最终产品的外观。

步行骨架还为多个团队协同工作奠定了基础。多人可以同时开始开发不同的功能模块或组件，而不必担心以后拼图块将如何组合在一起。到本章结束时，您将完成示例应用程序 LemonMart 的行走框架的实现。

## 实现无状态、数据驱动的设计

正如*第 10 章*、*RESTful API 和全栈实现*中强调的，全栈架构中的无状态设计对于实现可维护的应用程序至关重要。正如*第 1 章*、*Angular 及其概念简介*以及*第 12 章*、*配方-主/细节、数据表和 NgRx*中所述，通量模式和 NgRx 使您的应用能够实现不变的状态。然而，对于大多数应用来说，通量模式可能是过度的。NgRx 本身利用了 RxJS 中的许多核心技术。

我们将使用 RxJS 和反应式编程范式为我们的应用程序实现一个最小的、无状态的和数据驱动的模式。识别用户将使用的主要数据实体，如发票或人员，将有助于避免过度设计应用程序。围绕主要数据实体进行设计将在早期为 API 设计提供信息，并帮助定义`BehaviorSubject`数据锚，您将使用这些数据锚实现无状态、数据驱动的设计。该设计反过来将确保一个解耦的组件架构，如*第 6 章*、*表单、可观察对象和主体*中所述。

通过定义可观察的数据锚，您可以确保跨不同组件的数据保持同步。通过编写功能性的反应式代码、利用 RxJS 特性以及不在组件中存储状态，我们可以实现不可变的数据流。

我们将在*第 10 章*、*RESTful API 和完整堆栈实现*中介绍如何为您的应用程序设计数据模型，并将在以下章节中继续使用这些模型。

## 实施解耦的组件体系结构

正如我们在*第 1 章**Angular 及其概念简介*中所讨论的，您的体系结构的解耦组件对于确保可维护的代码库至关重要。在 Angular 中，您可以通过利用`@Input`和`@Output`绑定和路由器编排来解耦组件。

绑定将帮助您维护组件的简单层次结构，并避免在静态设计更有效的情况下使用动态模板，例如创建多页表单。

路由器出口和辅助路径允许您使用路由器组成视图。解析器可以通过使用路由器参数来帮助加载数据。Auth guards 可以帮助控制对各种模块和组件的访问。使用路由器链接，您可以动态定制用户将以不变和可预测的方式看到的元素，类似于我们在上一步中设计和开发数据锚的方式。

如果您确保每个组件都负责加载自己的数据，那么您可以通过 URL 组合组件。然而，过度使用路由器本身可能成为一种反模式。如果父组件在逻辑上拥有子组件，那么将它们解耦的努力将白费。

在*第 6 章**表单、可观察对象和主题*中，您学习了如何使用`BehaviorSubject`启用组件交互。在*第 11 章**配方-可重用性、路由和缓存*中，您将学习如何实现`@Input`和`@Output`绑定，在接下来的章节中，您将学习如何实现路由器功能。

## 区分用户控件和组件

另一个重要的想法是区分用户控件和组件。用户控件类似于自定义日期输入或自定义星级评定器。它通常是高度交互和动态的代码，最终成为高度耦合、卷积和复杂的代码。这些控件可能会使用以前没人听说过的角度特征，这很可能是本书中没有介绍的。

组件更像是带有字段的表单，其中可能包含简单的日期输入或星号评分器。因为表单封装了业务功能，所以它们的代码必须易于阅读和理解。您的代码应该遵循角度的基本原则，因此代码稳定且易于维护，就像本书中介绍的大多数代码一样。

通过区分用户控件和组件，您可以在决定要使哪种代码可重用时做出更好的决策。创建可重用代码的成本很高。如果您创建了正确的可重用代码，就可以节省时间和资源。如果您创建了错误的可重用代码，那么您可能会浪费大量的时间和资源。

线框允许您在早期识别可重用图元。用户控件将有助于将用户交互代码与业务逻辑分开。精心设计的组件重用将使您能够封装特定于域的行为，并在以后共享。

确定封装您希望为应用程序创建的独特行为的自包含用户控件非常重要。用户控件可能被创建为具有数据绑定属性和紧密耦合的控制器逻辑和模板的指令或组件。

另一方面，组件利用路由器生命周期事件解析参数并对数据执行 CRUD 操作。尽早识别这些组件重用将导致创建更灵活的组件，这些组件可以在多个上下文中重用（由路由器协调），从而最大限度地实现代码重用。

我们将在*第 11 章*、*配方——可重用性、路由和缓存*中介绍如何创建可重用组件和用户控件。

## 使用 TypeScript 和 ES 最大限度地实现代码重用

在你考虑角度、RXJS 和你使用的所有库所提供的特性之前，记住你所使用的语言的基本特征是很重要的。有几十年的软件工程基础，您可以利用这些基础编写可读和可维护的代码。

首先也是最重要的是干燥原则。它代表不要重复你自己。所以，不要复制粘贴代码。不要只改变一两个变量。主动重构代码，使函数无状态且可重用。几句话：不要重复你自己，不要重复你自己，不要重复你自己。

利用面向对象的设计。将行为移入课堂；如果你的人有一个`fullName`属性，不要在十几个不同的地方重新实现相同的逻辑，而是在`person`类中实现一次。这意味着您需要熟悉水合作用，也就是将 JSON 对象注入到新实例化的类中，以及使用`toJSON`进行序列化。重要的是不要滥用 OOP。通过避免将状态存储在类参数中，您仍然应该保持无状态和功能性。

通过利用泛型、继承和抽象类，您可以真正释放 OO 设计的威力。

TypeScript 将接口的概念引入 JavaScript。接口是一个主要为静态类型语言保留的概念。接口表示对象可以做什么的抽象概念，而不指定任何实现细节。此外，还可以使用接口记录数据的形状。例如，您可以编写第三方 API 的部分接口来记录您感兴趣使用的字段。当其他开发人员阅读您的代码时，他们对所使用的数据结构有着固有的理解，而无需阅读其他网站上的文档。

接口还允许您以定义良好的方式变形数据的形状。因此，您可以编写一个转换函数，将外部数据的形状转换为内部数据。TypeScript 将捕获您可能犯的任何错误。进一步考虑这个概念，您还可以使用接口来展平数据。如果接收到的数据具有多实体关系结构，则可以展平关系以将数据设计与 UI 代码分离。

不要过度平展数据。对于常见对象（例如名称对象或常用的特定于域的对象），可以使用数组和简单形状。

您还应该避免在代码中使用字符串文字。在比较`'apples' !== 'Oranges'`的地方编写业务逻辑会导致无法维护的代码。您应该在 TypeScript 中利用`enums`，这样您的代码就不会受到编码人员拼写错误或不断变化的业务需求的影响。所以`'oranges' === Fruit.Organes`。

除了 TypeScript 和 ECMAScript 之外，Angular 还为您提供了重用逻辑的有用函数。角度验证器、管道、路由解析程序和路由保护都允许您跨组件和模板共享代码。

以下章节将演示上述概念：

*   *第 8 章*、*设计认证授权*
*   *第 10 章*、*RESTful API 和全栈实现*
*   *第 11 章*、*配方——可重用性、路由和缓存*
*   *第 12 章*、*配方-主/明细、数据表和 NgRx*

接下来，让我们从创建 LemonMart 开始™, 一款功能齐全的业务线应用程序，可作为启动下一个专业项目的模板。Lemart 和 OnMa 的后端认证和可配置功能是完全不同的。

自推出以来，LemonMart 已经为 14000 多名开发者提供了 160000 多个柠檬。热情！![](../Images/B14094_07_001.png)

您始终可以从 GitHub[克隆完成的项目 https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart) ，只要你需要它。让我们直接开始吧。

# 创造柠檬艺术

LemonMart 将是一个中等规模的业务线应用程序，包含 90 多个代码文件。我们将开始我们的旅程，创建一个新的 Angular 应用程序，从一开始就配置路线和 Angular 材质。

假设您已经安装了*第 2 章**设置您的开发环境*中提到的所有必要软件。如果没有，请为操作系统执行以下命令以配置环境。

在 Windows PowerShell 上，执行：

```
PS> Install-Script -Name setup-windows-dev-env
PS> setup-windows-dev-env.ps1 
```

在 macOS 终端上，执行：

```
$> bash <(wget -O - https://git.io/JvHi1) 
```

有关更多信息，请参阅[https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup) 。

## 创建路由器第一个应用程序

使用路由器优先的方法，我们希望在应用程序的早期启用路由：

1.  You can create the new application, with routing already configured, by executing this command.

    确保`@angular/cli`未全局安装，否则可能会出错：

    ```
    $ npx @angular/cli new lemon-mart --routing --strict
    (Select CSS as the stylesheet format ) 
    ```

    从 Angular 9 开始，您可以使用`--strict`打开打字脚本功能，如`noImplicitAny`、`noImplicitReturns`、`noFallthroughCasesInSwitch`和`strictNullChecks`。这些选项将减少发生编码错误的机会，但会导致代码更加冗长。在我看来，这是一件好事，强烈建议将此选项用于面向生产的应用程序。

2.  A new `AppRoutingModule` file has been created for us:

    ```
    **src/app/app-routing.modules.ts**
    import { NgModule } from '@angular/core';
    import { Routes, RouterModule } from '@angular/router'; 
    const routes: Routes = [];
    @NgModule({
      imports: [RouterModule.forRoot(routes)],
      exports: [RouterModule],
    })
    export class AppRoutingModule { } 
    ```

    我们将在 routes 数组中定义路由。请注意，传入的 routes 数组将配置为应用程序的根路由；默认根路由为`/`。

    在配置您的`RouterModule`时，您可以传入其他选项以自定义路由器的默认行为，例如，当您尝试加载已在上的路由时。通常，如果您尝试导航到的路由与当前路由相同，路由器不会采取任何操作。但是，如果您希望路由器刷新页面，您可以自定义路由器的默认行为，例如使用`RouterModule.forRoot(routes, { onSameUrlNavigation: 'reload' })`。使用此设置后，如果导航到当前所在的 URL，将强制重新加载当前组件。

3.  最后，`AppRoutingModule`在`AppModule`注册，如图所示：

    ```
    **src/app/app.module.ts**
    ...
    import { AppRoutingModule } from './app-routing.module';
    @NgModule({ 
      ... 
      imports: [ AppRoutingModule, ... ], 
      ...
    }) 
    ```

## 配置角度和 VS 代码

要快速应用*第 2-6 章*所述的配置步骤，请运行以下命令：

以下脚本不要求您使用 VS 代码。如果您希望使用另一个 IDE，比如 WebStorm，那么配置的`npm`脚本将同样运行良好。

1.  安装角度 VS 代码任务：

    ```
    npm i -g mrm-task-angular-vscode 
    ```

2.  应用角度 VS 代码配置：

    ```
    npx mrm angular-vscode 
    ```

3.  为 Docker 任务安装 npm 脚本：

    ```
    npm i -g mrm-task-npm-docker 
    ```

4.  为 Docker 配置应用 npm 脚本：

    ```
    npx mrm npm-docker 
    ```

5.  实现一个 npm 脚本，在名为`build:prod`

    ```
    "scripts": {
      ...,
      "build:prod": "ng build --prod",
    } 
    ```

    的生产模式下构建应用程序

这些设置会不断调整，以适应不断发展的扩展、插件、Angular 和 VS 代码环境。始终确保重新运行`install`命令以获取最新版本，从而安装任务的新版本。或者，您可以使用 VS 代码的扩展名，只需单击一下即可运行配置命令。

请注意，如果前面的配置脚本无法执行，那么下面的 npm 脚本也将失败。在这种情况下，您有两个选项：恢复更改并忽略这些脚本，或者按照前面章节中的介绍（或在 GitHub 上演示）手动实现这些脚本。

1.  执行`npm run style:fix`
2.  执行`npm run lint:fix`
3.  执行`npm start`并确保您在`http://localhost:5000`上运行，而不是在默认端口`4200`上运行

请参阅*第 2 章**设置您的开发环境*，了解更多配置细节。

您可以选择使用`mrm-task-npm-aws`为 AWS ECS 设置 npm 脚本，用于 AWS 上的*第 13 章*、*高可用云基础设施。*

有关 mrm 任务的更多信息请参阅：

*   [https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)
*   [https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)
*   [https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)

## 配置材质和样式

我们还将需要设置角度材料并配置要使用的主题，如*第 5 章*所述，*使用材料*交付高质量用户体验：

1.  安装角材料：

    ```
    $ npx ng add @angular/material
    (select Custom, No to global typography, Yes to browser animations)
    $ npm i @angular/flex-layout 
    $ npx ng g m material --flat -m app 
    ```

2.  在`material.module.ts`中定义`const``modules`数组，导出`MatButtonModule`、`MatToolbarModule`和`MatIconModule`，删除`CommonModule`
3.  在`app.modules.ts`中，导入`FlexLayoutModule`以便激活角度柔性布局
4.  将公共 CSS 追加到`styles.css`中，如下代码所示：

    ```
    **src/styles.css**
    html,
    body { 
      height: 100%; 
    }
    body { 
      margin: 0;
      font-family: Roboto, "Helvetica Neue", sans-serif; 
    }
    .margin-top { 
      margin-top: 16px;
    }
    .horizontal-padding { 
      margin-left: 16px;
      margin-right: 16px;
    }
    .flex-spacer {
      flex: 1 1 auto;
    } 
    ```

5.  在`index.html`中更新您的申请标题

详见*第 5 章*、*以*材质交付高质量 UX，了解更多配置细节。

我们将在本章后面对应用程序应用自定义品牌。接下来，让我们开始设计我们的业务线应用程序。

## 设计柠檬艺术

从数据库到前端，建立一个基本的路线图是很重要的，同时也要避免过度工程化。初始设计阶段对项目的长期健康和成功至关重要，团队之间的任何现有筒仓都必须分解，团队所有成员都必须充分理解总体技术愿景。这说起来容易做起来难，而且有很多关于这个话题的书。

在工程学中，问题没有一个正确的答案，因此重要的是要记住，没有一个人能够得到所有的答案，也没有一个清晰的愿景。重要的是，技术和非技术领导者应创造一个安全的空间，提供开放式讨论和实验的机会，作为文化的一部分。作为一个团队，能够应对这种不确定性所带来的谦逊和同理心与任何团队成员的技术能力一样重要。每个团队成员都必须在门口检查自己的自我，因为我们的共同目标是在开发周期中根据不断变化的需求开发和发展应用程序。如果您创建的软件的各个部分很容易被任何人替换，您就会知道您已经成功了。

因此，让我们从开发路线图和确定应用程序的范围开始。为此，我们将定义用户角色，然后构建一个站点地图，以创建应用程序如何工作的愿景。

### 识别用户角色

我们设计的第一步是思考谁在使用这个应用程序以及为什么要使用它。

我们为 LemonMart 设想了四种用户状态或角色：

*   认证；任何经过身份验证的用户都可以访问其配置文件
*   出纳，其唯一职责是为客户结账
*   职员，其唯一职责是执行与库存相关的职能
*   经理，可以执行出纳和职员可以执行的所有操作，但也可以访问管理功能

考虑到这一点，我们可以开始为我们的应用程序创建高级设计。

### 使用站点地图识别高级模块

开发应用程序的高级站点地图，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_07.png)</figure>

图 7.7：用户登录页

我使用 MockFlow.com 的站点地图工具创建站点地图，如图所示：[https://sitemap.mockflow.com](https://sitemap.mockflow.com) 。

在第一次考试中，三个高级模块作为候选模块出现：

1.  **销售点（POS）**
2.  **存货**
3.  **经理**

出纳只能访问**POS**模块和组件。职员将只能访问**库存**模块，该模块将包括**库存录入**、**产品**和**类别**管理组件的附加屏幕：

<figure class="mediaobject">![](../Images/B14094_07_08.png)</figure>

图 7.8：库存页面

最后，**经理**将能够通过**经理**模块访问所有三个模块，包括用户管理和收据查询组件：

<figure class="mediaobject">![](../Images/B14094_07_09.png)</figure>

图 7.9：管理器页面

为所有三个模块启用延迟加载将带来巨大的好处；由于出纳员和办事员永远不会使用属于其他用户角色的组件，因此没有理由将这些字节发送到他们的设备。这意味着随着**管理器**模块获得更高级的报告功能，或者应用程序中添加了新的角色，**POS**模块将不受的带宽和内存影响。

这意味着更少的支持调用，以及在更长时间内在同一硬件上保持一致的性能。

# 生成支持路由器的模块

既然我们已经将高级组件定义为**管理器**、**库存**和**POS**，那么我们可以将它们定义为模块。这些模块将不同于您迄今为止创建的用于布线和角度材质的模块。我们可以将用户配置文件创建为应用程序模块上的组件；但是，请注意，用户配置文件将只用于已经认证的用户，因此定义第四个模块通常只用于认证用户是有意义的。这样，您将确保应用程序的第一个负载保持尽可能小。此外，我们将创建一个 Home 组件来包含我们的应用程序的登录体验，以便我们能够将实施细节排除在`app.component`之外：

1.  Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their target module and routing capabilities:

    ```
    $ npx ng g m manager -m app --routing
    $ npx ng g m inventory -m app --routing
    $ npx ng g m pos -m app --routing
    $ npx ng g m user -m app --routing 
    ```

    正如*第 2 章**设置开发环境*中所述，如果您已将`npx`配置为自动将`ng`识别为命令，则可以保存更多的击键，因为您不必每次都将`npx`附加到命令中。请勿全局安装`@angular/cli`。

    注意缩写的命令结构，其中`ng generate module manager`变为`ng g m manager`，同样地，`--module`变为`-m`。

2.  Verify that you don't have CLI errors.

    请注意，在 Windows 上使用`npx`可能会引发错误，如`Path must be a string. Received undefined`。此错误似乎对命令的成功运行没有任何影响，这就是为什么始终检查 CLI 工具生成的内容至关重要的原因。

3.  验证文件夹和文件是否已创建：

    ```
    **/src/app**
    │   app-routing.module.ts
    │   app.component.css
    │   app.component.html
    │   app.component.spec.ts
    │   app.component.ts
    │   app.module.ts
    │   material.module.ts
    ├───inventory
    │      inventory-routing.module.ts
    │      inventory.module.ts
    ├───manager
    │      manager-routing.module.ts
    │      manager.module.ts
    ├───pos
    │      pos-routing.module.ts
    │      pos.module.ts
    └───user
    │      user-routing.module.ts
    │      user.module.ts 
    ```

4.  检查`ManagerModule`是如何连接的。

特征模块实现了类似于`app.module`的`@NgModule`。最大的区别在于功能模块没有实现`bootstrap`属性，这是根模块初始化 Angular 应用程序所必需的：

```
**src/app/manager/manager.module.ts**
import { NgModule } from '@angular/core'
import { CommonModule } from '@angular/common'
import { ManagerRoutingModule } from './manager-routing.module'
@NgModule({
  imports: [CommonModule, ManagerRoutingModule],
  declarations: [],
})
export class ManagerModule {} 
```

由于我们已经指定了`-m`选项，该模块已经导入`app.module`：

```
**src/app/app.module.ts**
...
import { ManagerModule } from './manager/manager.module'
...
@NgModule({ 
  ... 
  imports: [..., ManagerModule], 
  ...
}) 
```

另外，由于我们还指定了`--routing`选项，所以已经创建了路由模块并导入`ManagerModule`：

```
**src/app/manager/manager-routing.module.ts**
import { NgModule } from '@angular/core'
import { Routes, RouterModule } from '@angular/router'
const routes: Routes = []
@NgModule({
  imports: [RouterModule.forChild(routes)], 
  exports: [RouterModule],
})
export class ManagerRoutingModule {} 
```

请注意，`RouterModule`正在使用`forChild`进行配置，与`AppRouting`模块的`forRoot`相反。通过这种方式，路由器理解在不同模块上下文中定义的路由之间的正确关系，并且能够正确地将`/manager`前置到本例中的所有子路由。

CLI 不尊重您的`tslint.json`设置。如果您已使用 Prettier 正确配置了 VS 代码环境，则在处理每个文件时或在运行`prettier`命令时，将应用您的代码样式首选项。

在继续之前，请务必运行`style:fix`和`lint:fix`命令。现在，让我们来设计 LemonMart 的登录页的外观和工作方式。

## 设计回家路线

考虑一下 To0T0.下面的模型损坏 LimoMald:

<figure class="mediaobject">![](../Images/B14094_07_10.png)</figure>

图 7.10：LemonMart 着陆体验

与`LocalCastWeather`应用程序不同，我们不希望所有这些标记都位于`App`组件中。`App`组件是整个应用程序的根元素；因此，它应该只包含在整个应用程序中持续出现的元素。在以下带注释的实体模型中，标记为**1**的工具栏将在整个应用程序中保持不变。

标记为**2**的区域将容纳`home`组件，该组件本身将包含一个登录用户控件，标记为**3**：

<figure class="mediaobject">![](../Images/B14094_07_11.png)</figure>

图 7.11:LemonMart 布局结构

最好的实践是在 Angular 中创建默认或着陆组件作为单独的元素。这有助于减少每页中必须加载的代码量和执行的逻辑，但在使用路由器时，它也会导致更灵活的体系结构。

使用内联模板和样式生成`home`组件：

```
$ npx ng g c home -m app --inline-template --inline-style 
```

注意，具有内联模板和样式的组件也称为**单文件组件**或**SFC**。

现在，您可以配置路由器了。

### 设置默认路由

让我们从为 LemonMart 设置一条简单的路线开始。我们需要设置`/`路由（也称为空路由）和`/home`路由来显示`HomeComponent`。我们还需要一个通配符路由来捕获所有未定义的路由并显示一个`PageNotFoundComponent`，它也需要创建：

1.  Configure your `home` route:

    ```
    **src/app/app-routing.module.ts**
    ...
    **import { HomeComponent } from './home/home.component'**
    const routes: Routes = [
     **{ path: '', redirectTo: '/home', pathMatch: 'full' },**
     **{ path: 'home', component: HomeComponent },**
    ]
    ... 
    ```

    我们首先为`'home'`定义一条路径，并通过设置`component`属性通知路由器渲染`HomeComponent`。然后，我们将应用程序`''`的默认路径设置为重定向到`'/home'`。通过设置`pathMatch`属性，我们始终确保`home`路线的这个非常具体的实例将被呈现为着陆体验。

2.  使用内联模板创建一个`pageNotFound`组件
3.  为`PageNotFoundComponent`

    ```
    **src/app/app-routing.module.ts**
    **import {** 
     **PageNotFoundComponent** 
    **} from './page-not-found/page-not-found.component'** 
    ...
    const routes: Routes = [
      ...
        **{ path: '**', component: PageNotFoundComponent },**
      ]
    ... 
    ```

    配置通配符路由

这样，任何不匹配的路由都将指向`PageNotFoundComponent`。

### 路由器链路

当用户登陆`PageNotFoundComponent`时，我们希望他们使用`routerLink`方向重定向到`HomeComponent`：

1.  在`PageNotFoundComponent`上，使用`routerLink`：

    ```
    **src/app/page-not-found/page-not-found.component.ts**
    ...
      template: `
     **<p>**
     **This page doesn't exist. Go back to**
     **<a routerLink="/home">home</a>.**
     **</p>**
      `,
    ... 
    ```

    替换内联模板以链接回`home`

这种导航也可以通过`<a href>`标签实现；但是，在更为动态和复杂的导航场景中，您将失去自动活动链接跟踪或动态链接生成等功能。

角度引导过程将确保`AppComponent`位于`index.html`中的`<app-root>`元素内。然而，我们必须手动定义我们希望`HomeComponent`呈现的位置，以最终确定路由器配置。

### 路由器出口

`AppComponent`被认为是`app-routing.module`中定义的根路由器的根元素，它允许我们在此根元素内定义出口，以便使用`<router-outlet>`元素动态加载我们希望的任何内容：

1.  配置`AppComponent`使用内联模板和样式，删除 html 和 css 文件中的任何现有内容
2.  为应用程序添加工具栏
3.  将应用程序的名称添加为按钮链接，以便在单击时将用户带到主页
4.  为要呈现的内容添加`<router-outlet>`：

    ```
    **src/app/app.component.ts**
    ...
    template: `
      <mat-toolbar color="primary">
        <a mat-button routerLink="/home"><h1>LemonMart</h1></a>
      </mat-toolbar>
      <router-outlet></router-outlet>
    `, 
    ```

现在，`home`的内容将在`<router-outlet>`内呈现。

# 品牌、自定义和材质图标

为了构建一个有吸引力和直观的工具栏，我们必须在应用程序中引入一些图标和品牌，以便用户可以借助熟悉的图标轻松浏览应用程序。

## 品牌创建

在品牌方面，您应该确保您的 web 应用程序具有自定义调色板，并与桌面和移动浏览器功能集成，以显示您的应用程序的名称和图像。

## 调色板

使用材质颜色工具选择调色板，如*第 5 章*所述，*使用材质*交付高质量 UX。这是我为 LemonMart 挑选的一个：

[https://material.io/resources/color/#!/?视图。左=0&视图。右=0&主视图。颜色=2E7D32&次视图。颜色=C6FF00](https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00)。

1.  将`custom-theme.scss`重命名为`lemonmart-theme.scss`
2.  用新的主题文件名

    ```
    **angular.json**
    "apps": [ {
      ... 
      "styles": [ 
        "src/lemonmart-theme.scss", 
        "src/styles.css" 
      ],
      ...
    }] 
    ```

    更新`angular.json`
3.  使用所选调色板配置自定义主题

您还可以在[从 GitHub 获取与 LemonMart 相关的资产 https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart) 。

对于本地天气应用程序，我们替换了`favicon.ico`文件，在浏览器中为我们的应用程序添加了品牌。虽然十年前这已经足够了，但今天的设备千差万别，每个平台都可以利用优化的资产在其操作系统中更好地表示您的 web 应用。接下来，让我们实现一个更健壮的 favicon。

## 实现浏览器清单和图标

您需要确保浏览器在**浏览器**选项卡中显示正确的标题文本和图标。此外，应创建一个清单文件，该文件实现各种移动操作系统的特定图标，这样，如果用户锁定了您的网站，则会显示一个与手机上其他应用程序图标类似的理想图标。这将确保如果用户在其移动设备的主屏幕上收藏或固定您的 web 应用程序，他们将获得一个本地应用程序图标：

1.  从设计师或类似[的网站上创建或获取网站徽标的 SVG 版本 https://www.flaticon.com](https://www.flaticon.com )
2.  In this case, I will be using the likeness of the Eureka Lemon:

    <figure class="mediaobject">![](../Images/B14094_07_12.png)</figure>

    图 7.12:LemonMart 的签名标志

    使用互联网上的图像时，请注意适用的版权。在这种情况下，我已经购买了能够发布此 lemon 徽标的许可证，但是您可以从以下 URL 获取您自己的副本，因为您提供了图像作者所需的属性：[https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070) 。

3.  使用[等工具生成`favicon.ico`和清单文件 https://realfavicongenerator.net](https://realfavicongenerator.net )
4.  根据您的喜好调整 iOS、Android、Windows Metro 和 macOS Safari 的设置
5.  确保您设置了一个版本号，因为 favicons 可能会因缓存而臭名昭著；随机版本号将确保用户始终获得最新版本
6.  将生成的`favicons.zip`文件下载并解压缩到您的`src`文件夹中
7.  编辑`angular.json`文件，将新资产包括在您的应用程序中：

    ```
    **angular.json**
    "apps": [
      {
      ...
        "assets": [
          "src/assets",
          "src/favicon.ico",
          "src/android-chrome-192x192.png",
          "src/favicon-16x16.png",
          "src/mstile-310x150.png",
          "src/android-chrome-512x512.png",
          "src/favicon-32x32.png",
          "src/mstile-310x310.png",
          "src/apple-touch-icon.png",
          "src/manifest.json",
          "src/mstile-70x70.png",
          "src/browserconfig.xml",
          "src/mstile-144x144.png",
          "src/safari-pinned-tab.svg",
          "src/mstile-150x150.png"
        ] 
    ```

8.  Insert the generated code in the `<head>` section of your `index.html`:

    ```
    **src/index.html**
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch- icon.png?v=rMlKOnvxlK">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=rMlKOnvxlK">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=rMlKOnvxlK">
    <link rel="manifest" href="/manifest.json?v=rMlKOnvxlK">
    <link rel="mask-icon" href="/safari-pinned-tab.svg?v=rMlKOnvxlK" color="#b3ad2d">
    <link rel="shortcut icon" href="/favicon.ico?v=rMlKOnvxlK">
    <meta name="theme-color" content="#ffffff"> 
    ```

    请将前面的 HTML 放在 favicon 声明之后，但在样式导入之前。顺序很重要。浏览器自上而下加载数据。您希望在用户等待 CSS 文件下载之前解析应用程序的图标。

9.  确保新 favicon 显示正确

一旦你的基本品牌工作已经完成，考虑一下，如果你想建立一个更独特的外观和感觉主题。

## 自定义主题

您可以利用[上列出的工具，进一步定制材料的外观和感觉，为您的应用程序提供独特的体验 https://material.io/tools](https://material.io/tools) 以及我发现的一些其他工具，如下所示：

*   Material Theme Editor（从 2020 年 3 月起退役）是 macOS 上流行的设计应用程序 Sketch 的一个插件，用于创建一个不仅仅是肤浅的主题。另一种工具尚未公布，但您可以在[链接的博客上找到您可以继续使用的资源 https://material.io/tools/theme-editor](https://material.io/tools/theme-editor)
*   Material ThemeBuilder 是在 Glitch.com 的[浏览器中构建自定义主题的替代方案 https://material-theme-builder.glitch.me](https://material-theme-builder.glitch.me )
*   Material设计主题调色板生成器将生成必要的代码来定义自定义调色板，以在[创建真正独特的主题 http://mcg.mbitson.com](http://mcg.mbitson.com )
*   颜色混合器有助于找到两种颜色之间的中间点，这在定义位于[的色样的颜色之间非常有用 https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend )

关于[有大量信息 https://material.io](https://material.io) 关于材料设计背后的深层理念，在色彩系统等方面有很多章节，[https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html) ，它深入地为你的品牌和其他主题选择正确的调色板，比如为你的应用程序创建一个黑色主题。

将您的品牌与其他应用程序或竞争对手区分开来非常重要。创建高质量的自定义主题将是一个耗时的过程；然而，给用户留下良好第一印象的好处是相当可观的。

接下来，我们将向您展示如何向 Angular 应用程序添加自定义图标。

## 定制图标

现在，让我们在 Angular 应用程序中添加您的自定义品牌。您将需要用于创建 favicon 的 svg 图标：

1.  将图像置于`src/assets/img/icons`下，命名为`lemon.svg`
2.  在`app.module.ts`中，将`HttpClientModule`导入`AppComponent`，以便通过 HTTP 请求`.svg`文件
3.  更新`AppComponent`将新 svg 文件注册为图标：

    ```
    **src/app/app.component.ts**
    **import { MatIconRegistry } from '@angular/material/icon'**
    **import { DomSanitizer } from '@angular/platform-browser'**
    ...
    export class AppComponent {
     **constructor(** 
     **iconRegistry: MatIconRegistry,** 
     **sanitizer: DomSanitizer**
     **) {** 
     **iconRegistry.addSvgIcon(**
     **'lemon',**
     **sanitizer.bypassSecurityTrustResourceUrl(**
     **'assets/img/icons/ lemon.svg'**
     **)** 
     **)**
      } 
    } 
    ```

4.  将图标添加到工具栏：

    ```
    **src/app/app.component.ts**
    template: ` 
      <mat-toolbar color="primary"> 
     **<mat-icon svgIcon="lemon"></mat-icon>** 
        <a mat-button routerLink="/home"><h1>LemonMart</h1></a> 
      </mat-toolbar> 
      <router-outlet></router-outlet> 
    `, 
    ```

现在，让我们为菜单、用户配置文件和注销添加其余图标。

## 材质图标

角度材质与材质设计图标字体一起开箱即用，该字体会自动导入到应用程序中，作为`index.html`中的 web 字体。可以自行设置字体的宿主；然而，如果你沿着这条路走下去，如果用户的浏览器已经缓存了他们访问另一个网站时的字体，你就不会得到好处，这可以节省下载 42-56 KB 文件的速度和延迟。完整的图标列表可在[找到 https://material.io/icons/](https://material.io/icons/) 。

现在，让我们用一些图标更新工具栏，并用一个最小的假登录按钮模板设置主页：

1.  Ensure that the Material icons `<link>` tag has been added to `index.html`:

    ```
    **src/index.html**
    <head>
      ...
      <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    </head> 
    ```

    在[的**自托管**部分可以找到如何自托管的说明 http://google.github.io/material-design-icons/#getting-图标](http://google.github.io/material-design-icons/#getting-icons)。

    配置后，使用材质图标很容易。

2.  在`AppComponent`上，更新工具栏，在标题左侧放置**菜单**按钮。
3.  添加`fxFlex`指令，使其余图标右对齐。
4.  添加用户配置文件和注销图标：

    ```
    **src/app/app.component.ts**
    template: `
      <mat-toolbar color="primary">
        <**button mat-icon-button><mat-icon>menu</mat-icon></button>**
        <mat-icon svgIcon="lemon"></mat-icon>
        <a mat-button routerLink="/home"><h1>LemonMart</h1></a>
        **<span class="flex-spacer"></span>**
     **<button mat-icon-button>**
     **<mat-icon>account_circle</mat-icon>**
     **</button>**
     **<button mat-icon-button>**
     **<mat-icon>lock_open</mat-icon>**
     **</button>**
      </mat-toolbar>
      <router-outlet></router-outlet>
    `, 
    ```

5.  在`HomeComponent`上，添加登录体验的最小模板，替换任何现有内容：

    ```
    **src/app/home/home.component.ts**
      styles: [`
        div[fxLayout] {margin-top: 32px;}
      `],
      template: `
        <div fxLayout="column" fxLayoutAlign="center center">
          <span class="mat-display-2">Hello, Limoncu!</span>
          <button mat-raised-button color="primary">Login</button>
        </div>
      ` 
    ```

您的应用程序应该与此屏幕截图相似：

<figure class="mediaobject">![](../Images/B14094_07_13.png)</figure>

图 7.13：最少登录的 LemonMart

考虑到用户的身份验证状态，在实现和显示/隐藏菜单、配置文件和注销图标方面还有一些工作要做。我们将在*第 8 章**设计认证和授权*中介绍此功能。

为了调试路由器，获得路由器的可视化，并使用 Angular Augure 紧密集成 Chrome 调试功能，请参见*附录 a、**调试 Angular*。

现在您已经为应用程序设置了基本路由，我们可以继续设置带有子组件的延迟加载模块。如果您不熟悉故障排除和角度调试，请参阅*附录 A**、角度调试*，然后再继续。

# 具有延迟加载的功能模块

加载资源有两种方式：急切地加载或懒散地加载。当浏览器为你的应用加载`index.html`时，它开始从上到下处理它。首先处理`<head>`元素，然后处理`<body>`。例如，我们在应用程序的`<head>`中定义的 CSS 资源将在呈现应用程序之前下载，因为我们的 Angular 应用程序在 HTML 文件的`<body>`中定义为`<script>`。

当您使用命令`ng build`时，Angular 利用 webpack 模块绑定器将所有 JavaScript、HTML 和 CSS 组合成小型和优化的 JavaScript 绑定。

如果你不利用 Angular 中的延迟加载，你的应用程序的全部内容都会被急切地加载。在下载并加载所有屏幕之前，用户不会看到应用程序的第一个屏幕。

延迟加载允许角度构建过程与 webpack 协同工作，将 web 应用程序分离为称为块的不同 JavaScript 文件。我们可以通过将应用程序的各个部分划分为功能模块来实现这种分块。功能模块及其依赖项可以捆绑到单独的块中。请记住，根模块及其依赖项将始终位于下载的第一个块中。因此，通过对应用程序的 JavaScript 包大小进行分块，我们将初始分块的大小保持在最小值。使用最小的第一块，无论应用程序增长多大，第一次有意义绘制的时间保持不变。否则，当您向应用程序添加更多功能时，它的下载和渲染时间将越来越长。延迟加载对于实现可伸缩的应用程序体系结构至关重要。

考虑下面的图形来确定哪些线路被急速加载，哪些线路负载缓慢：

<figure class="mediaobject">![](../Images/B14094_07_14.png)</figure>

图 7.14：角度加载与延迟加载

`rootRouter`定义了三条路由：`a`、`b`和`c`。`/master`和`/detail`代表命名路由器出口，在*第 12 章*、*配方-主/细节、数据表和 NgRx*中介绍。路由`a`是应用程序的默认路由。路由`a`和`c`通过实线连接到`rootRouter`，而路由`b`通过虚线连接。在此上下文中，路由`b`被配置为延迟加载路由。这意味着路由`b`将动态加载一个功能模块，称为**B 模块**，其中包含其`childRouter`。这个`childRouter`可以定义任意数量的组件，甚至可以重用在其他地方重用的路由名称。在这种情况下，`b`定义了三条额外的路由：`d`、`e`和`f`。

考虑 AutoT1A.T1 的路由器定义：

```
**rootRouter example**
const routes: Routes = [
  { path: '', redirectTo: '/a', pathMatch: 'full' },
  {
    path: 'a',
    component: AComponent,
    children: [
      { path: '', component: MasterComponent, outlet: 'master' },
      { path: '', component: DetailComponent, outlet: 'detail' },
    ],
  },
  {
    path: 'b',
    loadChildren: 
      () => import('./b/b.module')
        .then((module) => module.BModule), 
    canLoad: [AuthGuard],
  },
  { path: 'c', component: CComponent },
  { path: '**', component: PageNotFoundComponent },
] 
```

注意在`rootRouter`中不存在`d`、`e`和`f`路由的定义。参见`childRouter`的路由器定义示例：

```
**childRouter example**
const routes: Routes = [
  { path: '', redirectTo: '/b/d', pathMatch: 'full' },
  { path: 'd', component: DComponent },
  { path: 'e', component: EComponent },
  { path: 'f', component: FComponent },
] 
```

如您所见，`childRouter`中定义的路由独立于`rootRouter`中定义的路由。子路由存在于层次结构中，其中`/b`是父路径。要导航到`DComponent`，您必须使用路径`/b/d`，而要导航到`CComponent`，您只能使用`/c`。

考虑到这个示例配置，`rootRouter`中定义的每个组件及其依赖项都将位于我们应用程序的第一块中，因此迫切需要加载。第一块将包括组件`A`、`Master`、`Detail`、`C`和`PageNotFound`。第二个区块将包含组件`D`、`E`和`F`。在用户导航到以`/b`开头的路径之前，不会下载或加载第二个区块；因此，它是惰性加载的。

在本书中，我只介绍了延迟加载功能模块的成熟方法。查看John Papa 在[上关于创建延迟加载组件的博文 https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/) 。

现在，我们将介绍如何使用组件和布线设置功能模块。我们还将使用占卜来观察各种路由器配置的效果。

## 使用组件和路由配置功能模块

manager模块需要一个登录页，如本模型所示：

<figure class="mediaobject">![](../Images/B14094_07_15.png)</figure>

图 7.15：经理的仪表板

让我们从为`ManagerModule`创建主屏幕开始：

1.  Create the `ManagerHome` component:

    ```
    $ npx ng g c manager/managerHome -m manager -s -t 
    ```

    为了在`manager`文件夹下创建新组件，我们必须在组件名称前面加上前缀`manager/`。此外，我们指定组件应导入并使用`ManagerModule`声明。因为这是另一个登录页，所以它不太可能复杂到需要单独的 HTML 和 CSS 文件。您可以使用`--inline-style`（别名`-s`）和/或`--inline-template`（别名`-t`）来避免创建其他文件。

2.  确认您的文件夹结构如下所示：

    ```
    /src
    ├───app
    │ │
    │ ├───manager
    │ │ │ manager-routing.module.ts
    │ │ │ manager.module.ts
    │ │ │
    │ │ └───manager-home
    │ │ │ │ manager-home.component.spec.ts
    │ │ │ │ manager-home.component.ts 
    ```

3.  将`ManagerHome`组件的路由配置为`manager-routing.module`，类似于我们将`Home`组件配置为`app-route.module`：

    ```
    **src/app/manager/manager-routing.module.ts**
    import { 
      ManagerHomeComponent 
    } from './manager-home/manager-home.component' 
    const routes: Routes = [ 
      { path: '', redirectTo: '/manager/home', pathMatch: 'full' }, 
      { path: 'home', component: ManagerHomeComponent }, 
    ] 
    ```

请注意，`http://localhost:5000/manager`实际上尚未解析为组件，因为我们的 Angular 应用程序不知道`ManagerModule`存在。让我们首先尝试一下蛮力、渴望加载的方法来导入`ManagerModule`并在我们的应用程序中注册 manager 路由。

## 急装

让我们从开始，急切地加载`ManagerModule`，这样我们就可以看到在根模块中导入和注册路由不会产生可扩展的解决方案：

1.  Import the `ManagerModule` in `app.module.ts`:

    ```
    **src/app/app.module.ts**
    import { ManagerModule } from './manager/manager.module' 
    ...
    @NgModule({ 
      imports: [..., ManagerModule],
      ...
    }) 
    ```

    您将注意到，`http://localhost:5000/manager`仍然没有呈现其`home`组件。

2.  Use **Augury** to debug the router state, as shown:

    <figure class="mediaobject">![](../Images/B14094_07_16.png)</figure>

    图 7.16：具有急切加载的路由器树

    请注意，在发布时，Augury 对 Ivy 渲染引擎的支持不是很好。为了可靠地查看**路由器树**选项卡，您需要禁用常春藤。您可以通过在项目的`tsconfig.app.json`文件中添加以下设置来完成此操作：

    ```
     "angularCompilerOptions": {
        "enableIvy": false
      } 
    ```

    您需要重新启动 Angular 应用程序并重新加载占卜，以使更改生效。然而，获得漂亮的图表并不值得意外地将你的应用程序与常春藤禁用。小心这个！

3.  似乎`/manager`路径已正确注册并指向正确的组件`ManagerHomeComponent`。这里的问题是`app-routing.module`中配置的`rootRouter`不知道`/manager`路径，因此`**`路径优先，而呈现`PageNotFoundComponent`。
4.  Implement the `'manager'` path in `app-routing.module.ts` and assign `ManagerHomeComponent` to it, so we can see what happens:

    ```
    **src/app/app-routing.module.ts**
    **import {** 
     **ManagerHomeComponent** 
    **} from './manager/manager-home/ manager-home.component'** 
    ...
    const routes: Routes = [
      ...
      **{ path: 'manager', component: ManagerHomeComponent },**
      { path: '**', component: PageNotFoundComponent },
    ] 
    ```

    <figure class="mediaobject">![](../Images/B14094_07_17.png)</figure>

    图 7.17：具有重复路径注册的 Manager home 渲染

    如上图所示，`http://localhost:5000/manager`通过显示 manager home works 正确渲染！但是，当您通过 Augury 调试路由器状态时，请注意，`ManagerHomeComponent`已注册两次。这是因为`rootRouter`和`childRouter`注册都在接受。为了避免这个问题，我们必须将所有路径创建集中在`rootRouter`中，而不使用子路由器。

    将所有路径集中在`rootRouter`中并不能很好地扩展，因为它迫使所有开发人员维护一个主文件来导入和配置每个模块。合并冲突和团队成员之间令人沮丧的交流时机已经成熟。随着文件变大，引入错误的几率呈指数级增加，同一路径可能会被无意中注册多次。

    可以设计一个解决方案，将模块划分为多个文件。您可以在`ManagerModule`中实现一个新的路由数组，并将其导入`rootRouter`中，而不是标准的`*-routing.module`。让我们解决重复注册问题。

5.  在`manager.module.ts`中，从导入数组中移除`ManagerRoutingModule`。
6.  在`manager.module.ts`中，实现一个`Routes`数组，为组件`ManagerHomeComponent`设置一个空路径，如图所示：

    ```
    **src/app/manager/manager.module.ts**
    import { Routes } from '@angular/router'
    export const managerModuleRoutes: Routes = [
      { path: '', component: ManagerHomeComponent }
    ] 
    ```

7.  In `app-routing.module.ts`, import the array you just created and assign it to the `children` property of the `'manager'` path:

    ```
    **src/app/app-routing.module.ts**
    import { **managerModuleRoutes** } from './manager/manager.module'
    ...
    { path: 'manager', children: **managerModuleRoutes** }, 
    ```

    不要忘记删除`component`属性和`ManagerHomeModule`的导入。

让我们再次查看占卜上的**路由器树**，看看是否解决了重复注册问题：

<figure class="mediaobject">![](../Images/B14094_07_18.png)</figure>

图 7.18：带子路由的路由器树

提供的解决方案有效。没有重复注册，因为我们停止使用`manager-routing.module.ts`中的`childRouters`。此外，我们通过不在`ManagerModule`之外导入`ManagerHomeComponent`，保持了一些关注点分离，从而形成了一个更具可扩展性的解决方案。然而，随着应用程序的发展，我们仍然必须向`app.module.ts`注册所有模块。因此，功能模块仍然以潜在的不可预测的方式与根模块紧密耦合。此外，此代码不能分块，因为功能模块直接导入到`app.module.ts`中，因此 TypeScript 编译器将其视为必需的依赖项。

接下来，让我们将配置转换为延迟加载配置。

## 延迟加载

现在，您了解了模块的急切加载是如何工作的，您将能够更好地理解我们将要编写的代码，这可能看起来像是黑魔法，而神奇（也称为误解）的代码总是导致意大利面条式的架构。

现在，我们将把急切的加载解决方案发展为延迟加载解决方案。为了从不同的模块加载路由，我们知道我们不能简单地导入它们，否则它们将被急切地加载。答案在于使用带有内联导入语句的`loadChildren`属性配置路由，通知路由器如何在`app-routing.module.ts`中加载功能模块：

1.  确保您想要延迟加载的任何模块没有导入到`app.module.ts`中，因此从`imports`中删除`ManagerModule`。
2.  移除`ManagerModule`中添加的`Routes`数组。
3.  将`ManagerRoutingModule`添加回`ManagerModule`中的`imports`。
4.  In `app-routing.module.ts`, implement or update the `'manager'` path with the `loadChildren` attribute:

    ```
    **src/app/app-routing.module.ts**
    import { NgModule } from '@angular/core'
    import { RouterModule, Routes } from '@angular/router'
    import { HomeComponent } from './home/home.component'
    import { PageNotFoundComponent } from './page-not-found/page-not-found.component'
    ... 
      const routes: Routes = [ 
        ..., 
        { 
          path: 'manager', 
          loadChildren: 
            () => import('./manager/manager.module')
              . then(m=> m.ManagerModule), 
        }, 
        { path: '**', component: PageNotFoundComponent }, 
      ] 
    ... 
    ```

    延迟加载是通过一个巧妙的技巧实现的，它避免在文件级使用 import 语句。将函数委托设置为`loadChildren`属性，该属性包含定义功能模块文件位置的内联导入语句，如`./manager/manager.module`，允许我们以类型安全的方式引用`ManagerModule`，而无需实际完全加载它。内联导入语句可以在构建过程中进行解释，以创建一个单独的 JavaScript 块，该块只能在需要时下载。`ManagerModule`然后就好像它自己的 Angular 应用程序一样，管理它的所有子依赖项和路由。

5.  Update the `manager-routing.module` routes, considering that `manager` is now their root route:

    ```
    **src/app/manager/manager-routing.module.ts**
    const routes: Routes = [
      { path: '', redirectTo: '/manager/home', pathMatch: 'full' },
      { path: 'home', component: ManagerHomeComponent },
    ] 
    ```

    我们现在可以将`ManagerHomeComponent`的路径更新为更有意义的`'home'`路径。此路径不会与在`app-routing.module`中找到的路径冲突，因为在此上下文中，`'home'`解析为`'manager/home'`，同样，在`path`为空的地方，URL 将类似于`http://localhost:5000/manager`。

6.  重新启动`ng serve`或`npm start`命令，以便 Angular 可以正确地拦截应用程序。
7.  导航到`http://localhost:5000/manager`。
8.  Confirm that lazy loading is working by looking at Augury, as follows:

    <figure class="mediaobject">![](../Images/B14094_07_19.png)</figure>

    图 7.19：延迟加载的路由器树

`ManagerHomeComponent`的根节点现在命名为**管理器【懒惰】**。

我们已经成功地建立了一个延迟加载的功能模块。接下来，让我们实现 LemonMart 的行走骨架。

# 完成行走骨架

使用本章前面为 LemonMart 创建的站点地图，我们需要为应用程序完成行走骨架导航体验。为了创造这种体验，我们需要创建一些按钮来将所有模块和组件链接在一起。我们将一个模块一个模块地学习。

开始之前，更新`HomeComponent`上的登录按钮，使用`routerLink`属性导航到`'manager'`路径，并重命名按钮：

```
**src/app/home/home.component.ts**
  ...
  <button mat-raised-button color="primary" **routerLink="/manager"**>
    **Login as Manager**
  </button>
  ... 
```

现在，我们可以通过点击**登录**按钮导航到`ManagerHome`组件。

## 管理器模块

既然我们已经为`ManagerModule`启用了延迟加载，那么让我们继续完成的其余导航元素。

在当前设置中，`ManagerHomeComponent`呈现在`AppComponent`模板中定义的`<router-outlet>`中，因此当用户从`HomeComponent`导航到`ManagerHomeComponent`时，在`AppComponent`中实现的工具栏保持不变。参见**经理仪表板**的以下实体模型：

<figure class="mediaobject">![](../Images/B14094_07_20.png)</figure>

图 7.20：应用程序范围和功能模块工具栏

无论我们导航到何处，应用程序范围的工具栏都保持不变。我们可以在整个 T0 模块中实现类似的功能。因此，导航按钮**用户管理**和**收据查询**将始终可见。这允许我们创建一个一致的 UX，用于跨模块导航子页面。

要实现辅助工具栏，我们需要复制`AppComponent`和`HomeComponent`之间的父子关系，其中父级实现工具栏和`<router-outlet>`，以便在其中呈现子元素：

1.  Start by creating the base `manager` component:

    ```
    $ npx ng g c manager/manager -m manager --flat -s -t 
    ```

    `--flat`选项跳过目录创建，将组件直接放置在`manager`文件夹下，就像`app.component`直接位于`app`文件夹下一样。

2.  In `ManagerComponent`, implement a navigational toolbar with `activeLink` tracking:

    ```
    **src/app/manager/manager.component.ts**
    styles: [
      `
        div[fxLayout] {
          margin-top: 32px;
        }
      `, 
      `
        .active-link {
          font-weight: bold;
          border-bottom: 2px solid #005005;
        }
      `,
    ],
    template: `
    <mat-toolbar color="accent"> 
      <a mat-button 
        routerLink="/manager/home" 
        routerLinkActive="active-link"
       >
          Manager's Dashboard
      </a> 
      <a mat-button 
        routerLink="/manager/users" 
        routerLinkActive="active-link"
      >
        User Management
      </a> 
      <a mat-button 
         routerLink="/manager/receipts" 
         routerLinkActive="active-link"
       >
         Receipt Lookup
       </a> 
    </mat-toolbar> 
    <router-outlet></router-outlet>
    ` 
    ```

    必须注意的是，功能模块不会自动访问父模块中创建的服务或组件。这是一个重要的默认行为，可以保持解耦的体系结构。但是，在某些情况下，需要共享一些代码。在这种情况下，`mat-toolbar`需要重新导入。由于`MatToolbarModule`已经加载到`src/app/material.module.ts`中，我们只需将此模块导入`manager.module.ts`中，这样做不会导致性能或内存损失。

3.  确保`ManagerComponent`已申报且`MaterialModule`已进口`ManagerModule`:

    ```
    **src/app/manager/manager.module.ts**
    import { MaterialModule } from '../material.module' 
    import { ManagerComponent } from './manager.component'
    ...
    declarations: [..., **ManagerComponent**],
    imports: [..., **MaterialModule**], 
    ```

4.  为子页面创建组件：

    ```
    $ npx ng g c manager/userManagement -m manager
    $ npx ng g c manager/receiptLookup -m manager 
    ```

5.  创建父子路由。我们知道，我们需要以下路径才能导航到我们的子页面，如下所示：

    ```
    **example**
    { path: '', redirectTo: '/manager/home', pathMatch: 'full' },
    { path: 'home', component: ManagerHomeComponent },
    { path: 'users', component: UserManagementComponent },
    { path: 'receipts', component: ReceiptLookupComponent }, 
    ```

为了瞄准`ManagerComponent`中定义的`<router-outlet>`，我们需要先创建父路由，然后为子页面指定路由：

```
**src/app/manager/manager-routing.module.ts**
...
import { NgModule } from '@angular/core'
import { RouterModule, Routes } from '@angular/router'
import { ManagerHomeComponent } from './manager-home/manager-home.component'
import { ManagerComponent } from './manager.component'
import { ReceiptLookupComponent } from './receipt-lookup/receipt-lookup.component'
import { UserManagementComponent } from './user-management/user-management.component' 
const routes: Routes = [
  {
    path: '', 
    component: ManagerComponent, 
    children: [
      { path: '', redirectTo: '/manager/home', pathMatch: 'full' },
      { path: 'home', component: ManagerHomeComponent },
      { path: 'users', component: UserManagementComponent },
      { path: 'receipts', component: ReceiptLookupComponent },
    ],
  },
] 
```

你现在应该可以在应用程序中导航了。当您点击**以管理员身份登录**按钮时，您将进入此处显示的页面。将突出显示可单击的目标，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_21.png)</figure>

图 7.21：突出显示所有路由器链接的管理器仪表板

如果您点击**LemonMart**，您将被带到主页。如果您点击**经理仪表板**、**用户管理**或**收据查询**，您将被导航到相应子页面，而活动链接将在工具栏上以粗体显示并加下划线。

## 用户模块

登录后，用户将能够访问他们的个人资料，并通过侧导航菜单在LemonMart 应用程序中查看他们可以访问的操作列表。在*第 8 章*中*设计认证和授权*中，当我们实施认证和授权时，我们将从服务器接收用户的角色。根据用户的角色，我们将能够自动导航或限制用户可以看到的选项。我们将在该模块中实现这些组件，以便用户登录后才能加载它们。为了完成行走骨架，我们将忽略与身份验证相关的问题：

1.  创建必要的组件：

    ```
    $ npx ng g c user/profile -m user
    $ npx ng g c user/logout -m user -t -s
    $ npx ng g c user/navigationMenu -m user -t -s 
    ```

2.  Implement routing.

    首先在`app-routing.module.ts`中实现延迟加载：

    ```
    **src/app/app-routing.module.ts**
    ... 
    { 
      path: 'user', 
      loadChildren: 
        () => import('./user/user.module')
          .then(m => m.UserModule), 
    }, 
    ```

    确保的`PageNotFoundComponent`路线始终是`app-routing.module`中的最后一条路线。

    现在在`user-routing.module.ts`中实现子路由：

    ```
    **src/app/user/user-routing.module.ts**
    ...
    const routes: Routes = [
      { path: 'profile', component: ProfileComponent },
      { path: 'logout', component: LogoutComponent },
    ] 
    ```

    我们正在为`NavigationMenuComponent`实现路由，因为它将直接用作 HTML 元素。此外，由于`UserModule`没有登录页，因此没有定义默认路径。

3.  In `AppComponent`, wire up the user and logout icons:

    ```
    **src/app/app.component.ts**
    ... 
    <mat-toolbar> 
      ... 
      <button 
     **mat-mini-fab routerLink="/user/profile"** 
     **matTooltip="Profile" aria-label="User Profile"**
      > 
        <mat-icon>account_circle</mat-icon> 
      </button> 
      <button 
     **mat-mini-fab routerLink="/user/logout"** 
     **matTooltip="Logout" aria-label="Logout"**
      > 
        <mat-icon>lock_open</mat-icon> 
      </button> 
    </mat-toolbar> 
    ```

    图标按钮可能很神秘，因此最好向其添加工具提示。为了使工具提示生效，请从`mat-icon-button`指令切换到`mat-mini-fab`指令，并确保在`material.module.ts`中导入`MatTooltipModule`。此外，请确保为仅图标按钮添加`aria-label`，以便依赖屏幕阅读器的残疾用户仍然可以浏览您的 web 应用程序。

4.  Ensure that the app works.

    您会注意到这两个按钮彼此太近，如下所示：

    <figure class="mediaobject">![](../Images/B14094_07_22.png)</figure>

    图 7.22：带图标的工具栏

5.  您可以通过在`<mat-toolbar>`中添加`fxLayoutGap="8px"`来解决图标布局问题；但是，现在 lemon 徽标与应用程序名称的距离太远，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_23.png)</figure>

图 7.23：带有填充图标的工具栏

1.  通过合并图标和按钮

    ```
    **src/app/app.component.ts**
    ...
    <mat-toolbar>
      ...
      <a mat-icon-button routerLink="/home">
        <mat-icon svgIcon="lemon"></mat-icon>
        <span class="mat-h2">LemonMart</span>
      </a>
      ...
    </mat-toolbar> 
    ```

    可以解决徽标布局问题

如以下屏幕截图所示，分组解决了布局问题：

<figure class="mediaobject">![](../Images/B14094_07_24.png)</figure>

图 7.24：带有分组和填充元素的工具栏

从用户体验的角度来看，这也是更可取的；现在用户也可以通过点击柠檬返回主页。

## POS 和库存模块

我们的行走骨架假定是经理的角色。为了能够访问我们将要创建的所有组件，我们需要使经理能够访问 POS 和库存模块。

使用两个新按钮更新`ManagerComponent`：

```
**src/app/manager/manager.component.ts**
<mat-toolbar color="accent" **fxLayoutGap="8px"**> 
 **...** 
 **<span class="flex-spacer"></span>** 
 **<button** 
 **mat-mini-fab routerLink="/inventory"** 
 **matTooltip="Inventory" aria-label="Inventory"**
 **>** 
 **<mat-icon>list</mat-icon>** 
 **</button>** 
 **<button** 
 **mat-mini-fab routerLink="/pos"** 
 **matTooltip="POS" aria-label="POS"**
 **>** 
 **<mat-icon>shopping_cart</mat-icon>** 
 **</button>** 
</mat-toolbar> 
```

请注意，这些路由器链接将引导我们离开`ManagerModule`的领域，所以特定于管理器的辅助工具栏消失是正常的。

现在，由您来实现剩下的最后两个模块。对于这两个新模块，我提供了高级步骤，并让您参考可以对新模块进行建模的前一个模块。如果您被卡住，请参阅 GitHub 项目中位于[的`projects/ch7`文件夹 https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart) 。

### POS 模块

`PosModule`与`UserModule`非常相似，只是`PosModule`是默认路径。`PosComponent`将是默认组件。这可能是一个包含一些子组件的复杂组件，因此不要使用内联模板或样式：

1.  创建`PosComponent`
2.  将`PosComponent`注册为默认路径
3.  为`PosModule`配置延迟加载
4.  确保应用程序正常工作

现在让我们实现库存模块。

### 库存模块

`InventoryModule`与`ManagerModule`非常相似，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_25.png)</figure>

图 7.25：库存仪表板模型

1.  创建一个基础`Inventory`组件
2.  注册`MaterialModule`
3.  创建**库存主目录**、**库存分录**、**产品**、**类别**组件
4.  在`inventory-routing.module.ts`中配置父子路由
5.  为`InventoryModule`配置延迟加载
6.  在`InventoryComponent`中实现内部`InventoryModule`导航的辅助工具栏
7.  确保应用程序正常工作，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_26.png)</figure>

图 7.26:LemonMart 库存仪表板

现在，应用程序的行走框架已经完成，检查路由器树以确保延迟加载已正确配置，并且模块不会无意中被急切加载，这一点很重要。

## 检查路由器树

导航至应用程序的基本路径，使用 Augury 检查路由器树，如图所示：

<figure class="mediaobject">![](../Images/B14094_07_27.png)</figure>

图 7.27：延迟加载的路由器树

除了最初需要的组件之外的所有组件都应该用**【惰性】**属性表示。如果由于某种原因，路由没有用**[Lazy]**表示，则它们很可能被错误地导入到`app.module.ts`或其他组件中。

在路由器树中，您可能会注意到，`ProfileComponent`和`LogoutComponent`被急切地加载，而`UserModule`被正确地标记为**【懒惰】**。即使通过工具和代码库进行多次目视检查，也可能会让您寻找罪魁祸首。但是，如果您对`UserModule`进行全局搜索，您会很快发现它正被导入`app.module.ts`。在运行 CLI 命令时，您的模块可能会无意中重新导入到`app.module.ts`，因此请注意这一点！

为了安全起见，请检查您的`app.module.ts`文件，并确保删除不在根级别的模块或组件的任何导入语句。您的文件应该看起来像以下文件：

```
**src/app/app.module.ts**
import { HttpClientModule } from '@angular/common/http'
import { NgModule } from '@angular/core'
import { FlexLayoutModule } from '@angular/flex-layout'
import { BrowserModule } from '@angular/platform-browser'
import { 
  BrowserAnimationsModule 
} from '@angular/platform-browser/ animations'
import { AppRoutingModule } from './app-routing.module'
import { AppComponent } from './app.component'
import { HomeComponent } from './home/home.component'
import { MaterialModule } from './material.module'
import { 
  PageNotFoundComponent 
} from './page-not-found/page-not-found.component' 
@NgModule({
  declarations: [AppComponent, HomeComponent, PageNotFoundComponent],
  imports: [
    BrowserModule,
    AppRoutingModule,
    BrowserAnimationsModule,
    MaterialModule,
    HttpClientModule,
    FlexLayoutModule,
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {} 
```

如果您在使用 Augury 调试路线时禁用了 Ivy，现在是重新启用它的时候了。

读者应该在继续之前解决所有测试错误。确保`npm test`和`npm run e2e`执行时没有错误。

# 通用测试模块

现在我们有很多模块要处理，为每个 spec 文件分别配置导入和提供程序变得单调乏味。为此，我建议创建一个通用测试模块，以包含通用配置，您可以全面重用该配置。

首先创建一个新的`.ts`文件来启动

1.  创建`common/common.testing.ts`。
2.  Populate it with common testing providers, fakes, and modules.

    我提供了`ObservableMedia`、`MatIconRegistry`和`DomSanitizer`的假实现，以及`commonTestingProviders`和`commonTestingModules`的阵列：

    ```
    **src/app/common/common.testing.ts**
    import { 
      HttpClientTestingModule 
    } from '@angular/common/http/ testing'
    import { SecurityContext } from '@angular/core'
    import { MediaChange } from '@angular/flex-layout'
    import { ReactiveFormsModule } from '@angular/forms'
    import { 
      SafeResourceUrl, 
      SafeValue 
    } from '@angular/platform-browser' 
    import { 
      NoopAnimationsModule 
    } from '@angular/platform-browser/animations' 
    import { RouterTestingModule } from '@angular/router/testing'
    import { Observable, Subscription, of } from 'rxjs'
    import { MaterialModule } from '../material.module'
    const FAKE_SVGS = {
      lemon: '<svg><path id="lemon" name="lemon"></path></svg>',
    }
    export class MediaObserverFake {
      isActive(query: string): boolean {
        return false
      }
      asObservable(): Observable<MediaChange> {
        return of({} as MediaChange)
      }
      subscribe(
        next?: (value: MediaChange) => void,
        error?: (error: any) => void,
        complete?: () => void
      ): Subscription {
        return new Subscription()
      }
    }
    export class MatIconRegistryFake {
      // tslint:disable-next-line: variable-name
      _document = document
      addSvgIcon(iconName: string, url: SafeResourceUrl): this {
        // this.addSvgIcon('lemon', 'lemon.svg')
        return this
      }
      getNamedSvgIcon(name: string, namespace: string = ''): Observable<SVGElement> {
        return of(this._svgElementFromString(FAKE_SVGS.lemon))
      }
      private _svgElementFromString(str: string): SVGElement {
        const div = (this._document || document)
          . createElement('DIV') 
        div.innerHTML = str
        const svg = div.querySelector('svg') as SVGElement
        if (!svg) {
          throw Error('<svg> tag not found')
        }
        return svg
      }
    }
    export class DomSanitizerFake {
      bypassSecurityTrustResourceUrl(url: string): SafeResourceUrl {
        return {} as SafeResourceUrl
      }
      sanitize(
        context: SecurityContext, 
        value: SafeValue | string | null): 
          string | null 
      { 
        return value?.toString() || null
      }
    }
    export const commonTestingProviders: any[] = [
      // Intentionally Left Blank!!!
    ]
    export const commonTestingModules: any[] = [
      ReactiveFormsModule,
      MaterialModule,
      NoopAnimationsModule,
      HttpClientTestingModule,
      RouterTestingModule,
    ] 
    ```

现在让我们看一下这个共享配置文件的示例用法：

```
**src/app/app.component.spec.ts**
import { MediaObserver } from '@angular/flex-layout'
import { MatIconRegistry } from '@angular/material/icon'
import { DomSanitizer } from '@angular/platform-browser'
...
import {
  DomSanitizerFake,
  MatIconRegistryFake,
  MediaObserverFake,
  commonTestingModules,
} from './common/common.testing'
...
  TestBed.configureTestingModule({
    imports: commonTestingModules,
    providers: commonTestingProviders.concat([
      { provide: MediaObserver, useClass: MediaObserverFake },
      { provide: MatIconRegistry, useClass: MatIconRegistryFake },
      { provide: DomSanitizer, useClass: DomSanitizerFake },
    ]),
    declarations: [AppComponent],
... 
```

大多数其他模块只需要导入`commonTestingModules`。

停止您是否确保所有单元测试都通过了？为了确保您的测试在生产过程中始终通过【第 T2 章，第 T0 章】和【第 T3 章】的自动化测试。

随着您的测试的启动和运行，LemonMart 的行走骨架已经完成。现在，让我们展望未来，开始思考我们可能使用的数据实体类型。

# 围绕主要数据实体进行设计

路由器优先体系结构的第四步是实现无状态、数据驱动的设计。为了实现这一点，围绕主要数据组件组织 API 有很大帮助。这将大致符合您在 Angular 应用程序中使用各种组件中的数据的方式。首先，我们将通过创建粗略的数据**实体关系图**（**ERD**来定义我们的主要数据组件。在*第 10 章*、*RESTful API 和全栈实现*中，我们将使用 Swagger.io 和 Express.js 为用户数据实体设计并实现一个 API。

## 定义实体

让我们从开始，尝试一下您希望存储哪种实体，以及这些实体之间的关系。

下面是使用[draw.io](http://draw.io)创建的 LemonMart 设计示例：

<figure class="mediaobject">![](../Images/B14094_07_28.png)</figure>

图 7.28:LemonMart 的 ERD

此时，实体是存储在 SQL 数据库还是 NoSQL 数据库中无关紧要。我的建议是坚持您所知道的，但是如果您是从零开始，像 MongoDB 这样的 NoSQL 数据库将随着您的实现和需求的发展提供最大的灵活性。

一般来说，每个实体都需要 CRUD API。考虑到这些数据元素，我们还可以想象围绕这些 CRUDAPI 的一些用户界面。让我们下一步做。

# 高级用户体验设计

实物模型对于确定我们在整个应用程序中需要什么样的组件和用户控件非常重要。跨组件使用的任何用户控件或组件都需要在根级别定义，其他控件或组件的作用域为它们自己的模块。

在本章前面，我们确定了子模块，并为它们设计了登录页，以完成行走骨架。现在我们已经定义了主要的数据组件，我们可以完成应用程序其余部分的模型。在高水平设计屏幕时，请记住以下几点：

*   用户能否以尽可能少的导航完成其角色所需的常见任务？
*   用户能否通过屏幕上的可见元素轻松访问应用程序的所有信息和功能？
*   用户可以轻松搜索他们需要的数据吗？
*   一旦用户找到感兴趣的记录，他们可以轻松地深入查看详细记录或查看相关记录吗？
*   弹出式警报真的有必要吗？你知道用户不会读的，对吧？

请记住，没有一种正确的方法可以设计任何用户体验，这就是为什么在设计屏幕时，您应该始终牢记模块化和可重用性。

## 创建工件 Wiki

正如本章前面提到的，记录您创建的每个工件是很重要的。Wiki 提供了一种方法来创建可协作更新或编辑的动态文档。尽管 Slack、团队、电子邮件和白板提供了良好的协作机会，但它们短暂的特性仍有许多不足之处。

因此，当您生成各种设计工件（如模型或设计决策）时，请注意将它们发布在所有团队成员都可以访问的 wiki 上：

1.  在 GitHub 上，切换到**Wiki**选项卡
2.  You may check out my sample wiki at [https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki), as shown:

    <figure class="mediaobject">![](../Images/B14094_07_29.png)</figure>

    图 7.29:GitHub.com LemonMart wiki

3.  创建 wiki 页面时，请确保在任何其他可用文档（如**自述文件**）之间进行交叉链接
4.  请注意，GitHub 显示了 wiki 上**页面**下的子页面
5.  然而，另一个总结是有帮助的，例如**设计工件**部分，因为有些人可能会错过右侧的导航元素
6.  完成实体模型后，将其发布在 wiki 上

您可以在此处看到 wiki 的摘要视图：

<figure class="mediaobject">![](../Images/B14094_07_30.png)</figure>

图 7.30：LemonMart 实体模型的摘要视图

现在，您的工件位于一个集中的位置，所有团队成员都可以访问它。他们可以添加、编辑、更新或整理内容。这样，你的维基就变成了有用的、生动的文档，记录了你的团队需要的信息，而不是你觉得自己被迫创建的文档。如果你发现自己处于那种情况，请举手！

![](../Images/B14094_07_002.png)

接下来，将您的模型集成到您的应用程序中，这样您就可以从利益相关者那里收集早期反馈，并测试应用程序的流程。

## 在应用程序中利用实体模型

将模型放在行走骨架应用程序中，以便测试人员能够更好地预见尚未开发的功能。请参见此想法的实施示例：

<figure class="mediaobject">![](../Images/B14094_07_31.png)</figure>

图 7.31：在 UI 中使用实体模型验证应用程序流程

这也将有助于设计和实施您的身份验证和授权工作流程。实物模型完成后，我们现在可以继续执行*第 8 章*、*设计认证和授权*中 LemonMart 的认证和授权工作流。

# 总结

在本章中，您掌握了如何有效地使用 Angular CLI 创建主要的角度构件和支架。你熟悉了 80-20 规则。您创建了应用程序的品牌，利用自定义和内置材质图像。您学习了如何使用 Augury 调试复杂的路由器配置。最后，您开始构建路由器优先应用程序，在早期定义用户角色，在设计时考虑延迟加载，并在早期确定行走骨架导航体验。我们围绕主要的数据实体进行了设计。我们还讨论了完成和记录整个应用程序的高级用户体验设计的重要性，以便我们能够正确地设计一个良好的有条件导航体验。

总而言之，为了实现路由器优先，您需要执行以下操作：

1.  制定路线图和范围
2.  考虑到延迟加载的设计
3.  实现行走骨架导航体验
4.  实现无状态、数据驱动的设计
5.  实施解耦的组件体系结构
6.  区分用户控件和组件
7.  使用 TypeScript 和 ES6 最大限度地实现代码重用

在本章中，您执行了步骤 1-3；在接下来的四章中，您将执行步骤 4-7。在*第 8 章*、*设计认证和授权*中，我们将深入探讨 OOP 设计、继承和抽象，同时深入探讨安全考虑因素，设计有条件的导航体验。在*第 10 章*、*RESTful API 和完整堆栈实现*中，您将看到使用最小平均堆栈的具体完整堆栈实现。*第 11 章*、*配方——可重用性、路由和缓存*、*第 12 章*、*配方——主/细节、数据表和 NgRx*，我们将通过坚持解耦的组件体系结构将所有东西结合在一起，使用各种类型脚本、RxJS 和角度编码技术，在创建用户控件和组件，以及最大限度地实现代码重用之间进行灵活选择。

# 进一步阅读

*   *Ha，尚未准备好 Ri：舒哈 Ri 敏捷开发方法*，Brian Sjoberg，Ken Furlong，2015 年 7 月 29 日，[https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development) 。
*   *角度 9：惰性加载组件*，约翰·帕帕，2020 年 2 月 16 日，[https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/) 。
*   网页包模块绑定器，[https://webpack.js.org/](https://webpack.js.org/) 。

# 问题

尽可能回答以下问题，以确保您在不使用谷歌搜索的情况下理解了本章的关键概念。你需要帮助回答这些问题吗？参见*附录 D*、*自我评估答案*在线[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf) 或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment) 。

1.  什么是帕累托原理？
2.  路由器优先架构的主要目标是什么？
3.  根模块和功能模块之间的区别是什么？
4.  延迟加载的好处是什么？
5.  为什么要创建应用程序的动态框架？*