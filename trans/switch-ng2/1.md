# 一、开始学习 Angular 2

2014 年 9 月 18 日，第一次公开提交被推送到 Angular 2 存储库。几周后，在**ng europe**上，核心团队的 Igor 和 Tobias 简要概述了 Angular 2 的预期用途。当时的愿景远非最终目标；然而，有一点是肯定的，新版本的框架将与 AngularJS 1.x 完全不同。

这一宣布带来了许多问题和争议。这些剧烈变化背后的原因很明显，AngularJS 1.x 不再能够充分利用不断发展的 Web 并完全满足大规模 JavaScript 应用的需求。一个新的框架将使开发人员能够以更简单、更直接的方式利用 web 技术的发展。然而，人们还是很担心。对于开发人员来说，向后不兼容的最大噩梦之一就是将他们当前的代码库迁移到他们使用的第三方软件的新版本。在 Angular 的例子中，在第一次宣布之后，迁移看起来令人望而生畏，甚至是不可能的。随后，在 2015 年**ng conf**和**ng vegas**上，引入了不同的迁移策略。AngularJS 社区走到了一起，分享了更多的想法，期望 Angular2 的好处，同时保留从 AngularJS 1.x 学到的东西。

这本书是该项目的一部分。升级到 Angular 2 绝非易事，但值得。AngularJS 2 的巨大变化及其缺乏向后兼容性背后的主要驱动因素是 Web 的发展，以及从野外使用 AngularJS 1.x 中吸取的教训。切换到 Angular 2 将帮助您了解我们是如何来到这里的，以及 Angular 的新功能在构建高性能、可扩展、单页应用方面对现代 Web 具有直观意义的原因，从而了解新框架。

# 网络的演变——是时候建立一个新的框架了

在过去的几年里，网络有了长足的发展。在 ECMAScript 5 的实施过程中，ECMAScript 6 标准开始开发（现称为**ECMAScript 2015**或**ES2015**。ES2015 在语言中引入了许多变化，例如添加了对模块的内置语言支持、块范围变量定义，以及大量语法糖类和解构。

同时，发明了**Web 组件**。Web 组件允许我们定义自定义 HTML 元素并将行为附加到它们。由于很难用新的 HTML 元素（如对话框、图表、网格等）扩展现有的 HTML 元素，这主要是因为它们的 API 的整合和标准化需要时间，因此更好的解决方案是允许开发人员以他们想要的方式扩展现有的元素。Web 组件为我们提供了许多好处，包括更好的封装、我们生成的标记的更好语义、更好的模块化以及开发人员和设计人员之间更容易的通信。

我们知道 JavaScript 是一种单线程语言。最初，它是为简单的客户端脚本而开发的，但随着时间的推移，它的角色已经发生了很大的变化。现在有了 HTML5，我们有了不同的 API，允许音频和视频处理，通过双向通信通道与外部服务通信，传输和处理大块原始数据，等等。主线程中所有这些繁重的计算可能会造成糟糕的用户体验。当执行耗时的计算时，它们可能会导致用户界面冻结。这导致了**WebWorkers**的开发，允许在后台执行通过消息传递与主线程通信的脚本。这样，多线程编程就被引入到浏览器中。

其中一些 API 是在 AngularJS 1.x 开发开始后引入的；这就是为什么构建框架时没有考虑到其中的大部分内容。但是，利用 API 为开发人员带来了许多好处，例如：

*   显著的性能改进。
*   开发具有更好质量特性的软件。

现在，让我们简要地讨论一下这些技术是如何成为新的 Angle core 的一部分的，以及为什么。

# ECMAScript 的演变

如今，浏览器供应商在短时间内发布新功能，用户经常收到更新。这有助于推动网络向前发展，允许开发人员利用前沿技术，旨在改善网络。ES2015 已经标准化。该语言的最新版本已经在主要浏览器中开始实施。学习新语法并充分利用它不仅可以提高我们作为开发人员的工作效率，还可以让我们为不久的将来做好准备，那时所有的浏览器都将完全支持它。这使得现在就必须开始使用最新的语法。

一些项目的要求可能迫使我们支持旧浏览器，而旧浏览器不支持任何 ES2015 功能。在这种情况下，我们可以直接编写 ECMAScript 5，它与 ES2015 具有不同的语法，但语义相同。然而，我们可以利用**发丝**的过程。在构建过程中使用 transpiler 可以让我们通过编写 ES2015 并将其翻译成浏览器支持的目标语言来利用新语法。

AngularJS 自 2009 年以来一直存在。当时，大多数网站的前端都由 ECMAScript 3 提供支持，ECMAScript 3 是 ECMAScript 5 之前的最后一个主要版本。这自动意味着用于框架实现的语言是 ECMAScript 3。利用新版本的语言需要将整个 AngularJS 1.x 移植到 ES2015。

从一开始，Angular 2 就通过在框架中引入最新语法来考虑 Web 的当前状态。尽管 Angular 2 是用 ES2016 的超集（TypeScript，我们稍后会看一看）编写的，但它允许开发人员使用自己喜欢的语言。我们可以使用 ES2015，如果我们不想对代码进行任何中间预处理并简化构建过程，甚至可以使用 ECMAScript 5。

## Web 组件

在 AngularJS 1.x 发布大约三年后的 2012 年 5 月 22 日发布了 Web 组件的第一份公开草案。如前所述，Web 组件标准允许我们创建自定义元素并将行为附加到它们。听起来很熟悉；我们已经在 AngularJS 1.x 应用的用户界面开发中使用了类似的概念。Web 组件听起来像是角度指令的替代品；但是，它们有更直观的 API、更丰富的功能和内置的浏览器支持。他们引入了一些其他的好处，例如更好的封装，这在处理 CSS 样式冲突时非常重要。

在AngularJS 1.x 中添加 Web 组件支持的策略可能是更改指令实现，并在 DOM 编译器中引入新标准的原语。作为 Angular 开发者，我们知道指令 API 有多强大，但也有多复杂。它包括很多属性，比如`postLink`、`preLink`、`compile`、`restrict`、`scope`、`controller`等等，当然还有我们最喜欢的`transclude`。作为标准，Web 组件将在浏览器中的较低级别上实现，这带来了许多好处，例如更好的性能和本机 API。

在 Web 组件的实现过程中，许多 Web 专家遇到了 Angular 团队在开发指令 API 时遇到的相同问题，并提出了类似的想法。Web 组件背后的良好设计决策包括**内容**元素，它处理 AngularJS 1.x 中臭名昭著的转换问题。由于指令 API 和 Web 组件以不同的方式解决类似的问题，因此将指令 API 保持在 Web 组件之上是多余的，并增加了不必要的复杂性。这就是为什么 Angular 核心团队决定从一开始就在 Web 组件之上构建，并充分利用新标准。Web 组件涉及新功能，其中一些功能尚未由所有浏览器实现。如果我们的应用在本机不支持任何这些功能的浏览器中运行，Angular 2 将模拟这些功能。这方面的一个例子是填充了指令[T0]的内容元素。

## “T0。”网络工作者

JavaScript 以其事件循环而闻名。通常 JavaScript 程序在单个线程中执行，不同的事件通过在队列中推送和按到达顺序顺序处理来调度。然而，当一个预定事件需要大量的计算时间时，这种计算策略并不有效。在这种情况下，事件的处理将阻塞主线程，在耗时的计算完成并将执行传递给队列中的下一个线程之前，不会处理所有其他事件。一个简单的例子是鼠标点击触发一个事件，在这个事件中，我们使用 HTML5 音频 API 进行一些音频处理。如果处理后的音频曲目很大，而在其上运行的算法很重，则会冻结用户界面，直到执行完成，从而影响用户体验。

WebWorker API 的引入是为了防止此类陷阱。它允许在不同线程的上下文中执行繁重的计算，从而使执行的主线程保持自由，能够处理用户输入并呈现用户界面。

我们如何才能利用这一点呢？为了回答这个问题，让我们思考一下 AngularJS 1.x 中的工作原理。如果我们有一个企业应用，它处理大量需要使用数据绑定在屏幕上呈现的数据，该怎么办？对于每个绑定，将添加一个新的观察者。运行摘要循环后，它将在所有观察者上循环，执行与它们相关联的表达式，并将返回的结果与从上一次迭代中获得的结果进行比较。我们在这里有一些减速：

*   对大量观察者的迭代。
*   给定上下文中表达式的求值。
*   返回结果的副本。
*   表达式计算的当前结果与上一个结果之间的比较。

根据输入的大小，所有这些步骤都可能非常慢。如果摘要循环涉及大量计算，为什么不将其移动到 WebWorker？为什么不在 WebWorker 内部运行摘要循环，获取更改的绑定，并将其应用于 DOM？

社区进行了一些实验，目的就是为了得到这个结果。然而，它们与框架的集成并非微不足道。缺乏令人满意的结果的主要原因之一是框架与 DOM 的耦合。通常，在观察者的回调中，Angular 直接操纵 DOM，这使得不可能在 WebWorkers 中移动观察者，因为 WebWorkers 是在孤立的上下文中调用的，没有对 DOM 的访问权。在 AngularJS 1.x 中，不同观察者之间可能存在隐式或显式依赖关系，这需要对摘要循环进行多次迭代才能获得稳定的结果。结合最后两点，在计算除主执行线程之外的其他线程的变化时，很难获得实际结果。

在 AngularJS 1.x 中修复此问题会在内部实现中引入大量复杂性。框架根本没有考虑到这一点。由于WebWorkers 是在 Angular 2 设计过程开始之前引入的，因此核心团队从一开始就将其牢记在心。

# 从野外的 AngularJS 1.x 中学到的经验教训

尽管上一节为响应最新趋势重新实现框架提出了许多论据，但重要的是要记住，我们不是从零开始的。我们将带着从 AngularJS 1.x 中学到的知识。自 2009 年以来，网络并不是唯一进化的东西。我们还开始构建越来越复杂的应用。如今，单页应用已不再是什么异国情调，而是更像是对所有解决业务问题的 web 应用的严格要求，这些应用旨在获得高性能和良好的用户体验。

AngularJS 1.x 帮助我们构建了高效、大规模的单页应用。然而，通过在各种用例中应用它，我们也发现了它的一些缺陷。Angular 的核心团队从社区的经验中学习，致力于开发新的想法，以满足新的需求。当我们观察角 2 的新特性时，让我们根据当前的 ANGARLJS 1 .x 的实现来考虑它们，并考虑我们作为角度开发人员所做的事情，并且在过去的几年中进行了修改。

## 控制器

AngularJS 1.x 遵循**模型视图控制器**（**MVC**微架构模式。有些人可能会争辩说，它看起来更像**模型视图视图模型**（**MVVM**），因为视图模型的将作为属性附加到范围，或者在控制器作为语法的情况下，将作为当前上下文附加到范围。如果我们使用**模型视图演示者模式**（**MVP**的话，它可以以不同的方式再次接近。由于我们可以在应用中构造逻辑的各种不同形式，核心团队称为 AngularJS 1.x**模型视图**（**MVW**框架。

任何AngularJS 应用中的视图都应该是指令的组合。这些指令协同工作，以提供功能齐全的用户界面。服务负责封装应用的业务逻辑。在这里，我们应该通过 HTTP 与 RESTful 服务进行通信，与 WebSocket 甚至 WebRTC 进行实时通信。服务是我们应该在其中实现应用的域模型和业务规则的构建块。还有一个组件，主要负责处理用户输入并将执行委托给控制器提供的服务。

虽然服务和指令具有定义良好的角色，但我们经常可以看到 iOS 应用中常见的**海量视图控制器**的反模式。有时，开发人员会试图直接从他们的控制器访问甚至操纵 DOM。最初，这是为了实现一些简单的功能，例如更改元素的大小，或者快速而不精确地更改元素的样式。另一个值得注意的反模式是跨控制器复制业务逻辑。开发人员通常倾向于复制和粘贴逻辑，这些逻辑应该封装在服务中。

对于所有的应用，DOM 和 DOM 指令都不应该是孤立的。如果我们在控制器之间有一些重复的逻辑，我们很可能希望将其封装到一个服务中，并在所有需要该功能的控制器中使用 AngularJS 的依赖注入机制注入该服务。

这就是我们在 AngularJS 1.x 中的来源。尽管如此，控制器的功能似乎可以转移到指令的控制器中。由于指令支持依赖项注入 API，因此在收到用户输入后，我们可以直接将执行委托给已经注入的特定服务。这是 Angular 2 使用不同方法的主要原因，它通过使用[T0]指令取消了将控制器放置在任何地方的功能。我们将在[第 4 章](4.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting Started with Angular 2 Components and Directives")、*AngularJS 1.x 控制器如何从 Angular 2 组件和指令开始*中了解 AngularJS 1.x 控制器的职责。

## 范围

AngularJS 中的数据绑定是使用`scope`对象实现的。我们可以将属性附加到它，并在模板中明确声明要绑定到这些属性（单向或双向）。虽然范围的概念似乎很清楚，但范围还有两个职责，包括事件调度和与变更检测相关的行为。角度初学者很难理解什么是范围以及应该如何使用范围。AngularJS 1.2 引入了名为**控制器的语法**。它允许我们向给定控制器（`this`内的当前上下文添加属性，而不是显式注入`scope`对象，然后再向其添加属性。可以从以下代码段演示此简化语法：

```ts
<div ng-controller="MainCtrl as main">
  <button ng-click="main.clicked()">Click</button>
</div>

function MainCtrl() {
  this.name = 'Foobar';
}
MainCtrl.prototype.clicked = function () {
  alert('You clicked me!');
};
```

Angular 2 通过移除`scope`对象，将更进一步。所有的表达式都在给定 UI 组件的上下文中进行计算。删除整个范围的 API 带来了更高的简单性；我们不再需要显式地注入它，我们向 UI 组件添加属性，以后可以绑定到这些组件。这个 API 感觉更简单、更自然。

我们将在[第 4 章](4.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting Started with Angular 2 Components and Directives")*开始学习 Angular 2 组件和指令*中更详细地了解 Angular 2 的组件和变化检测机制。

## 依赖注入

可能市场上第一个通过 JavaScript 世界中的**依赖注入**（**DI**）包含**控制反转**（**IoC**）的框架是 AngularJS 1.x。DI 提供了许多好处，例如更容易测试、更好的代码组织和模块化以及简单性。虽然 1.x 中的 DI 做了一个惊人的工作，但 Angular 2 更进一步。由于 Angular 2 位于最新的 web 标准之上，因此它使用 ECMAScript 2016 decorators 的语法来注释使用 DI 的代码。修饰符与 Python 中的修饰符或 Java 中的注释非常相似。它们允许我们通过反射来*装饰*给定对象的行为。由于装饰器还没有标准化，主要浏览器也不支持装饰器，因此装饰器的使用需要一个中间的透明步骤；但是，如果您不想使用它，可以直接使用 ECMAScript 5 语法编写更详细的代码，并实现相同的语义。

新的 DI 更加灵活，功能更加丰富。它还修复了 AngularJS 1.x 的一些缺陷，比如不同的 API；在 1.x 中，一些对象按位置（如指令链接函数中的作用域、元素、属性和控制器）注入，另一些对象按名称注入（使用控制器、指令、服务和过滤器中的参数名称）。

我们将在[第 5 章](5.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 5. Dependency Injection in Angular 2")中进一步了解 Angular 2 的依赖项注入 API，在中进一步了解 Angular 2 的*依赖项注入 API。*

## 服务器端渲染

Web 的需求越大，Web 应用就变得越复杂。构建一个现实生活中的单页应用需要编写大量 JavaScript，包括所有必需的外部库可能会将页面上的脚本大小增加到几兆字节。应用的初始化在移动设备上可能需要几秒钟甚至几十秒钟，直到从服务器获取所有资源、解析并执行 JavaScript、呈现页面以及应用所有样式。在使用移动互联网连接的低端移动设备上，此过程可能会让用户放弃访问我们的应用。虽然有一些实践可以加快这一过程，但在复杂的应用中，并没有灵丹妙药。

在试图改善用户体验的过程中，开发人员发现了一种称为**服务器端渲染**的东西。它允许我们在服务器上呈现单个页面应用的请求视图，并直接向用户提供页面的 HTML。稍后，处理完所有资源后，可以通过脚本文件添加事件侦听器和绑定。这听起来是提高应用性能的好方法。这方面的先驱之一是 ReactJS，它允许使用 Node.js DOM 实现在服务器端预呈现用户界面。不幸的是，AngularJS 1.x 的体系结构不允许这样做。showstopper 是框架和浏览器 API 之间的强耦合，这与我们在 WebWorkers 中运行更改检测时遇到的问题相同。

服务器端渲染的另一个典型的用例是构建**搜索引擎优化**（**SEO**）友好的应用。过去曾有几次黑客让 AngularJS 1.x 应用可以被搜索引擎索引。例如，其中一种做法是使用无头浏览器遍历应用，该浏览器在每个页面上执行脚本，并将呈现的输出缓存到 HTML 文件中，从而使搜索引擎可以访问它。

尽管这种构建 SEO 友好型应用的变通方法可行，但服务器端呈现解决了上述两个问题，改善了用户体验，并使我们能够更轻松、更优雅地构建 SEO 友好型应用。

Angular 2 与 DOM 的解耦允许我们在浏览器的上下文之外运行 Angular 2 应用。社区利用了的优势，构建了一个工具，允许我们在服务器端预先呈现单页应用的视图，并将其转发到浏览器。在编写以下内容时，该工具仍处于开发的早期阶段，不在框架的核心范围内。我们将在[第 8 章](8.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582 "Chapter 8. Development Experience and Server-Side Rendering")、*开发经验和服务器端渲染*中进一步了解。

## 可扩展的应用

自从 Backbone.js 出现以来，MVW 一直是构建单页应用的默认选择。它允许通过将业务逻辑与视图隔离来分离关注点，从而允许我们构建设计良好的应用。利用观察者模式，MVW允许监听视图中的模型更改，并在检测到更改时进行更新。然而，这些事件处理程序之间存在一些显式和隐式依赖关系，这使得我们的应用中的数据流不明显，也很难解释。在 AngularJS 1.x 中，我们可以在不同的观察者之间建立依赖关系，这需要摘要循环在所有观察者之间迭代几次，直到表达式的结果稳定为止。Angular 2 使数据流单向流动，这有许多好处，包括：

*   更明确的数据流。
*   绑定之间没有依赖性，因此没有摘要的**生存时间**（**TTL**。
*   更好的性能：
    *   摘要循环只运行一次。
    *   我们可以创建对不可变/可观察模型友好的应用，使我们能够进行进一步优化。

数据流的变化在 AngularJS 1.x 体系结构中引入了一个更基本的变化。

当我们需要维护用 JavaScript 编写的大型代码库时，我们可以从另一个角度来看待这个问题。尽管 JavaScript 的 duck 类型使语言非常灵活，但它也使 IDE 和文本编辑器更难对其进行分析和支持。大型项目的重构变得非常困难并且容易出错，因为在大多数情况下，静态分析和类型推断是不可能的。由于缺少编译器，TypeScript太容易了，在我们运行测试套件或运行应用之前，很难注意到这一点。

![Applications that scale](img/00002.jpeg)

Angular core 团队决定使用 TypeScript，因为它提供了更好的工具和编译时类型检查，这有助于我们提高工作效率和减少错误。如上图所示，TypeScript 是 ECMAScript 的超集；它引入了显式类型注释和编译器。TypeScript 语言被编译成纯 JavaScript，并得到当今浏览器的支持。从 1.6 版开始，TypeScript 实现了 ECMAScript 2016 装饰器，这使它成为 Angular 2 的完美选择。

TypeScript 的使用使得 IDE 和文本编辑器能够更好地支持静态代码分析和类型检查。所有这些都通过减少我们所犯的错误和简化重构过程大大提高了我们的生产率。TypeScript 的另一个重要优点是通过静态类型隐式地提高了性能，它允许 JavaScript 虚拟机进行运行时优化。

我们将在[第三章](3.html#PNV61-a118c4c18dd64e8ab73e171b466b6582 "Chapter 3. TypeScript Crash Course")*TypeScript速成课*中详细介绍。

## 模板

模板是 AngularJS 1.x 的关键特性之一。它们是简单的 HTML，不需要任何中间处理和编译，不像大多数模板引擎（如 Mustach）。AngularJS 中的模板结合了简单性和强大性，允许我们通过在其内部创建一种具有自定义元素和属性的内部**领域特定语言**（**DSL**）来扩展 HTML。

然而，这也是 web 组件背后的主要用途之一。我们已经提到 Angular 2 是如何以及为什么利用这项新技术的。尽管 AngularJS 1.x 模板很棒，但它们仍然可以变得更好！Angular 2 模板采用了框架早期版本中最好的部分，并通过修复一些容易混淆的部分对其进行了增强。

例如，假设我们构建了一个指令，并希望允许用户通过使用属性向其传递属性。在 AngularJS 1.x 中，我们可以通过三种不同的方式来实现这一点：

```ts
<user name="literal"></user>
<user name="expression"></user>
<user name="{{interpolate}}"></user>
```

如果我们有一个指令`user`并且我们想要传递`name`属性，我们可以用三种不同的方法来处理。我们可以传递一个文本（在本例中为字符串`"literal"`），一个将作为表达式计算的字符串（在本例中为`"expression"`），或者在`{{ }}`中传递一个表达式。应该使用哪种语法完全取决于该指令的实现，这使得它的 API 很复杂，很难记住。

每天处理大量具有不同设计决策的组件是一项令人沮丧的任务。通过引入共同公约，我们可以处理这些问题。然而，为了获得好的结果和一致的 API，整个社区都需要同意它。

Angular 2 还通过为属性提供特殊语法（其值需要在当前组件的上下文中进行计算）和用于传递文本的不同语法来处理此问题。

根据 AngularJS 1.x 的经验，我们习惯的另一件事是在模板指令中使用的微语法，如[T0]、[T1]。例如，如果我们想迭代一个用户列表并在 AngularJS 1.x 中显示他们的名字，我们可以使用：

```ts
<div ng-for="user in users">{{user.name}}</div>
```

尽管这种语法对我们来说很直观，但它允许有限的工具支持。然而，Angular 2 采用了更明确的语法和更丰富的语义来实现这一点：

```ts
<template ngFor var-user [ngForOf]="users">
  {{user.name}}
</template>
```

在`users`中，我们明确地定义了【T】的当前迭代（【T】的当前迭代】。

然而，这种[T0]语法对于键入来说太冗长了。开发人员可以使用以下语法，这些语法稍后会转换为更详细的语法：

```ts
<li *ngFor="#user of users">
  {{user.name}}
</li>
```

新模板中的改进还将使文本编辑器和 IDE 能够更好地提供高级支持。我们将在[第 4 章](4.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting Started with Angular 2 Components and Directives")中讨论 Angular 2 的模板，*开始使用 Angular 2 组件和指令*。

## 变更检测

在*WebWorkers*部分中，我们已经提到了在另一个线程的上下文中运行摘要循环的机会，该线程被实例化为 WebWorker。然而，AngularJS 1.x 中摘要循环的实现并不是非常高效的内存，并阻止 JavaScript 虚拟机进行进一步的代码优化，从而显著提高了性能。其中一个优化是内联缓存（[http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html) ）。Angular 团队进行了大量研究，发现了改进摘要循环的性能和效率的不同方法。这导致了一种全新的变化检测机制的发展。

为了允许进一步的灵活性，Angular 团队抽象了变更检测，并将其实现与框架的核心分离。这允许开发不同的变化检测策略，在不同的环境中增强不同的功能。

因此，Angular 2 具有两个内置的更改检测机制：

*   **动态变化检测**：类似AngularJS 1.x 使用的变化检测机制。它用于具有不允许的`eval()`的系统，如 CSP 和 Chrome 扩展。
*   **JIT 变更检测**：生成执行变更检测运行时的代码，允许JavaScript 虚拟机执行进一步的代码优化。

我们将在[第 4 章](4.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting Started with Angular 2 Components and Directives")*开始学习 Angular 2 组件和指令*中，了解新的变更检测机制以及如何配置它们。

# 总结

在本章中，我们考虑了 Angular 核心团队所做决定背后的主要原因，以及框架的最后两个主要版本之间缺乏向后兼容性。我们看到，这些决策是由两个因素推动的：Web 的发展和前端开发的发展，以及从 AngularJS 1.x 应用开发中吸取的经验教训。

在第一节中，我们了解了为什么我们需要使用最新版本的 JavaScript 语言，为什么我们希望利用 Web 组件和 WebWorkers，为什么不值得在 1.x 版中集成所有这些强大的工具。

我们观察了前端发展的当前方向和过去几年中的经验教训。我们描述了为什么 AngularJS 2 中删除了控制器和作用域，以及为什么 AngularJS 1.x 的体系结构发生了变化，以便为 SEO 友好、高性能、单页应用提供服务器端呈现。我们研究的另一个基本主题是构建大规模应用，以及如何激发框架中的单向数据流以及静态类型语言 TypeScript 的选择。

在下一章中，我们将研究 Angular 2 应用的主要构建块如何使用它们以及它们之间的关系。AngularJS 2 重用了 AngularJS 1.x 引入的一些组件命名，但通常会完全更改单页应用的构建块。我们将浏览一下新的组件，并将它们与以前版本的框架中的组件进行比较。我们将快速介绍指令、组件、路由器、管道和服务，并描述如何将它们结合起来构建一流的单页应用。

### 提示

**下载示例代码**

您可以从您的帐户[下载本书的示例代码文件 http://www.packtpub.com](http://www.packtpub.com) 。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

*   使用您的电子邮件地址和密码登录或注册我们的网站。
*   将鼠标指针悬停在顶部的**支架**选项卡上。
*   点击**代码下载&勘误表**。
*   在**搜索**框中输入图书名称。
*   选择要下载代码文件的书籍。
*   从您购买本书的下拉菜单中选择。
*   点击**代码下载**。

下载文件后，请确保使用以下最新版本解压或解压缩文件夹：

*   WinRAR/7-Zip for Windows
*   适用于 Mac 的 Zipeg/iZip/UnRarX
*   适用于 Linux 的 7-Zip/PeaZip